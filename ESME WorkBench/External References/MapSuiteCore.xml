<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MapSuiteCore</name>
    </assembly>
    <members>
        <member name="T:ThinkGeo.MapSuite.Core.MapResizeMode">
            <summary>
            The enumeration represents which mode will use for map resize.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.MapResizeMode.PreserveScale">
            <summary>
            This item represents that preserve the scale the same when map resize.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.MapResizeMode.PreserveScaleAndCenter">
            <summary>
            This item represents that preserve the scale the same and fix the center point of extent when map resize.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.MapResizeMode.PreserveExtent">
            <summary>
            This item represents that preserve the extent the same as before when map resize.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DotDensityStyle">
            <summary>
            This class allows you to display information by drawing points on an area based
            on a value from the features data.
            </summary>
            <remarks>
            This class allows you to display information by drawing points on an area based
            on a value from the features data. The higher the value is in the data, the greater
            the number of points that are drawn. The points themselves are distributed randomly inside of
            the polygon.<br/>
            	<br/>
            You would use this style if you have areas (such as counties) and numeric data (such as
            the number of births in those counties). In this example, you could plot a point in each county
            to represent each birth. A county will show a higher density of points if it is smaller or
            if there are more births there.<br/>
            	<br/>
            When you have data values that are too large to represent by plotting an individual point 
            for each, or data that is too
            sparse, you can set the PointToValueRatio. Setting this will control the ratio of points
            drawn to the value in the data. For example, if you have a value of 100 in the data and
            you have the ratio set to 1, then you will get 100 points drawn. A ratio of higher than 1
            will draw more points than the data value; in our example, a ratio of 2 will draw 200 points.
            Conversely, a ratio of less than 1 will draw fewer points than the data value; in our example,
            a ratio of 0.5 would draw 50 points.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Style">
            <summary>This abstract class is the root for all styles used for drawing features.</summary>
            <remarks>
            If you need to create your own style in the future, we suggest that you first
            consider extending an existing style. If you are doing something new, then you can
            inherit from this class.<br/>
            	<br/>
            The key method to override is DrawCore. If you want to provide a sample for the
            legend, you will also want to extend the DrawSampleCore.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Style.#ctor">
            <summary>
            This is the default constructor for the style and should be called by inherited
            classes.
            </summary>
            <returns>None</returns>
            <remarks>
            This is the default constructor for the style and should be called by inherited
            classes.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Style.CloneDeep">
            <summary>Create a copy of style using the deep clone process.</summary>
            <returns>A cloned style.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Style.CloneDeepCore">
            <summary>Create a copy of style using the deep clone process. The default implementation method uses serialization.</summary>
            <returns>A cloned style.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Style.Draw(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method DrawCore. In this
                method, we take the features you passed in and draw them on the canvas you provided.
                Each style (based on its properties) may draw each feature differently.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Style.Draw(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.BaseShape},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the shapes on the canvas you provided.</summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method DrawCore. In this
                method, we take the shapes you passed in and draw them on the canvas you provided.
                Each style (based on its properties) may draw each shape differently.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="shapes">This parameter represents the shapes you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the shapes on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Style.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This abstract method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties to
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Style.GetRequiredColumnNames">
            <summary>
            This method returns the column data for each feature that is required for the
            style to properly draw.
            </summary>
            <returns>This method returns a collection of column names that the style needs.</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method
                GetRequiredColumnNamesCore. In this method, we return the column names that are
                required for the style to draw the feature properly. For example, if you have a
                style that colors areas blue when a certain column value is over 100, then you need
                to be sure you include that column name. This will ensure that the column data is
                returned to you in the feature when it is ready to draw.<br/>
            		<br/>
                In many of the styles, we add properties to allow the user to specify which field
                they need; then, in the GetRequiredColumnNamesCore we read that property and add it
                to the collection.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Style.GetRequiredColumnNamesCore">
            <remarks>
            This abstract method is called from the concrete public method
            GetRequiredFieldNames. In this method, we return the column names that are required for
            the style to draw the feature properly. For example, if you have a style that colors
            areas blue when a certain column value is over 100, then you need to be sure you include
            that column name. This will ensure that the column data is returned to you in the
            feature when it is ready to draw.<br/>
            	<br/>
            In many of the styles, we add properties to allow the user to specify which field they
            need; then, in the GetRequiredColumnNamesCore we read that property and add it to the
            collection.
            </remarks>
            <summary>
            This method returns the column data for each feature that is required for the
            style to properly draw.
            </summary>
            <returns>This method returns a collection of column names that the style needs.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Style.DrawSample(ThinkGeo.MapSuite.Core.GeoCanvas)">
            <summary>This method draws a sample feature on the canvas you provided.</summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method DrawSampleCore.
                In this method we draw a sample style on the canvas you provided. This is typically
                used to display a legend or other sample area.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Style.DrawSampleCore(ThinkGeo.MapSuite.Core.GeoCanvas)">
            <summary>This method draws a sample feature on the canvas you provided.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. In this
            method, we draw a sample style on the canvas you provided. This is typically used to
            display a legend or other sample area.<br/>
            	<br/>
            	<br/>
            	<br/>
            When implementing this virtual method, consider the canvas size and draw the sample
            image appropriately. You should keep in mind that the sample typically shows up on a
            legend.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Style.Name">
            <summary>This property gets and set the name of the style.</summary>
            <value>This property gets the name of the style.</value>
            <remarks>
            This name is not used by the system; it is only for the developer. However, it can be used if
            you generate your own legend.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Style.IsActive">
            <summary>This property gets and sets the active status of the style.</summary>
            <value>This property gets the active status of the style.</value>
            <remarks>If the style is not active then it will not draw.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Style.RequiredColumnNames">
            <summary>
            This property gets the collection of fields that are required for the
            style.
            </summary>
            <value>
            This property gets the collection of fields that are required for the
            style.
            </value>
            <remarks>
            This property gets the collection of fields that are required for the style.
            These are in addition to any other columns you specify in styles that inherit from this
            one. For example, if you have use a ValueStyle and it requires a column name for the
            value comparison, then that column does not need to be in this collection. You only use
            the RequiredColumnNames for columns you need beyond those required by specific
            inherited styles.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DotDensityStyle.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, you should set the
            values by the properties.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DotDensityStyle.#ctor(System.String,System.Double,System.Int32,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify the column name, point-to-value ratio,
            point size and point color.
            </overloads>
            <returns>None</returns>
            <remarks>
            This constructor allows you to set everything you need to a standard
            scenario.
            </remarks>
            <param name="columnName">
            This parameter is the name of the column in the FeatureSource that will supply
            the data.
            </param>
            <param name="pointToValueRatio">This parameter controls the point-to-value ratio for the random dots.</param>
            <param name="pointSize">
            This parameter controls the size of each randomly placed point in the
            area.
            </param>
            <param name="pointColor">
            This parameter controls the color of each randomly placed point in the
            area.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DotDensityStyle.#ctor(System.String,System.Double,ThinkGeo.MapSuite.Core.PointStyle)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the column name, point-to-value ratio and
            a custom point style.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you require a custom point symbol, this constructor allows you to set everything you need.
            Custom points can include bitmaps and points that require custom fill
            brushes.
            </remarks>
            <param name="columnName">
            This parameter is the name of the column in the FeatureSource that will supply
            the data.
            </param>
            <param name="pointToValueRatio">This parameter controls the point-to-value ratio for the random dots.</param>
            <param name="customPointStyle">This parameter represents a custom point you want to draw.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DotDensityStyle.GetRequiredColumnNamesCore">
            <remarks>
            This abstract method is called from the concrete public method
            GetRequiredFieldNames. In this method, we return the column names that are required for
            the style to draw the feature properly. For example, if you have a style that colors
            areas blue when a certain column value is over 100, then you need to be sure you include
            that column name. This will ensure that the column data is returned to you in the
            feature when it is ready to draw.<br/>
            	<br/>
            In many of the styles, we add properties to allow the user to specify which field they
            need; then, in the GetRequiredColumnNamesCore, we read that property and add it to the
            collection.
            </remarks>
            <summary>
            This method returns the column data for each feature that is required for the
            style to properly draw.
            </summary>
            <returns>This method returns a collection of column names that it needs.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DotDensityStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DotDensityStyle.CustomPointStyle">
            <summary>This property gets and sets a custom point style.</summary>
            <value>This property gets a custom point style.</value>
            <remarks>
            You will use this property when you want to specify a point style that is not
            just a simple colored dot. You may want to use a bitmap or take advantage of a
            custom fill brush.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DotDensityStyle.ColumnName">
            <summary>
            This property gets and sets the column name that will be used for the density
            value.
            </summary>
            <value>
            This property gets the column name that will be used for the density
            value.
            </value>
            <remarks>
            This value should represent a value in the FeatureSource that is numeric. It will
            be used in conjunction with the PointToValueRatio property to deterime how many points
            are drawn in the area.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DotDensityStyle.PointSize">
            <summary>This property gets and sets the point size of the density points.</summary>
            <value>This property gets the point size of the density points.</value>
            <remarks>
            If you have sparse data, one way to better fill the area is to use larger point
            sizes. The opposite is also true; if you have lots of data, smaller point sizes look
            better.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DotDensityStyle.PointColor">
            <summary>This property gets and sets the color of the density points.</summary>
            <value>This property gets the color of the density points.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DotDensityStyle.PointToValueRatio">
            <summary>This property gets and sets the ratio of points to value in the data.</summary>
            <value>This property gets the ratio of points to value in the data.</value>
            <remarks>
            This property controls the ratio of points on the screen to numeric value in the
            data. For example, if you have a value of 100 in the data and
            you have the ratio set to 1, then you will get 100 points drawn. A ratio of higher than 1
            will draw more points than the data value; in our example, a ratio of 2 will draw 200 points.
            Conversely, a ratio of less than 1 will draw fewer points than the data value; in our example,
            a ratio of 0.5 would draw 50 points.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DotDensityStyle.CachedPoints">
            <summary>
            The cachedPoints for the dotdensity style to speed it up.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ClassBreak">
            <summary>This class represents a single class break.</summary>
            <remarks>
            Class breaks are used in the ClassBreakStyle. They allow you to display data
            differently depending on ranges of data in the FeatureSource.<br/>
            	<br/>
            How class breaks work:<br/>
            	<br/>
            You add a number of ClassBreak classes to the ClassBreak collection. The numeric values
            of the breaks are important and you must place the breaks in numerical order. For
            example, break 0 must be added before break 100. In each ClassBreak, you specify the
            style you want to represent that break. Additionally, in the ColumnName property, you specify the
            name of the column where we will find the data used to compare the breaks. The column
            name must point to a column that is numeric.<br/>
            	<br/>
            When we proceed to draw the style, we look through the ClassBreaks and select the ClassBreak
            that is where the features column data is greater than and closest to the break
            value.<br/>
            	<br/>
            Example:<br/>
            	<br/>
            Feature Value = 42<br/>
            	<br/>
            ClassBreak1.Value = 0<br/>
            ClassBreak2.Value = 20<br/>
            ClassBreak3.Value = 40<br/>
            ClassBreak4.Value = 60<br/>
            	<br/>
            In this case, the break closest to the feature value without exceeding it is
            ClassBreak3(40). If the feature value had been less than zero, nothing would have been
            drawn. If the feature value were 1000, then ClassBreak4 would draw.<br/>
            	<br/>
            If you wanted to represent a value that is less then zero, you could do that as shown in the
            sample below.<br/>
            	<br/>
            Feature Value = -1<br/>
            	<br/>
            ClassBreak1.Value = Double.Min<br/>
            ClassBreak2.Value = 0<br/>
            ClassBreak3.Value = 20<br/>
            ClassBreak4.Value = 40<br/>
            	<br/>
            In this example, the first class break would be used.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClassBreak.#ctor">
            <summary>This is the class constructor.</summary>
            <overloads>This is the default constructor.</overloads>
            <remarks>
            If you use this default constructor, then you should set the properties
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClassBreak.#ctor(System.Double,ThinkGeo.MapSuite.Core.AreaStyle)">
            <summary>This is the class constructor.</summary>
            <overloads>This overload allows you to pass in a break value and an AreaStyle to use.</overloads>
            <returns>None</returns>
            <remarks>This overload allows you to pass in a break value and an AreaStyle to use.</remarks>
            <param name="value">The parameter represents the break value.</param>
            <param name="areaStyle">This parameter is the AreaStyle you want to use to represent this break.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClassBreak.#ctor(System.Double,ThinkGeo.MapSuite.Core.PointStyle)">
            <summary>This is the class constructor.</summary>
            <overloads>This overload allows you to pass in a break value and a Point to use.</overloads>
            <returns>None</returns>
            <remarks>This overload allows you to pass in a break value and a Point to use.</remarks>
            <param name="value">The parameter represents the break value.</param>
            <param name="pointStyle">This parameter is the PointStyle you want to use to represent this break.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClassBreak.#ctor(System.Double,ThinkGeo.MapSuite.Core.LineStyle)">
            <summary>This is the class constructor.</summary>
            <overloads>This overload allows you to pass in a break value and a LineStyle to use.</overloads>
            <returns>None</returns>
            <remarks>This overload allows you to pass in a break value and a LineStyle to use.</remarks>
            <param name="value">The parameter represents the break value.</param>
            <param name="lineStyle">This parameter is the LineStyle you want to use to represent this break.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClassBreak.#ctor(System.Double,ThinkGeo.MapSuite.Core.TextStyle)">
            <summary>This is the class constructor.</summary>
            <overloads>This overload allows you to pass in a break value and a TextStyle to use.</overloads>
            <returns>None</returns>
            <remarks>This overload allows you to pass in a break value and a TextStyle to use.</remarks>
            <param name="value">The parameter represents the break value.</param>
            <param name="textStyle">This parameter is the TextStyle you want to use to represent this break.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClassBreak.#ctor(System.Double,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.Style})">
            <summary>This is the class constructor.</summary>
            <overloads>This overload allows you to pass in a break value and a collection of TextStyles to use.</overloads>
            <returns>None</returns>
            <remarks>This overload allows you to pass in a break value and a collection of TextStyles to use.</remarks>
            <param name="value">The parameter represents the break value.</param>
            <param name="customStyles">This parameter is the TextStyles you want to use to represent this break.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ClassBreak.Value">
            <summary>This property get and sets the break value.</summary>
            <value>This property get the break value.</value>
            <remarks>
            This value determines where the break is in the ClassBreakStyle.<br/>
            	<br/>
            Please see the ClassBreakStyle class remarks for a full description of how the
            ClassBreakStyle works.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ClassBreak.DefaultAreaStyle">
            <summary>
            This property gets and sets the default AreaStyle used to draw the class
            break.
            </summary>
            <value>This property gets the default AreaStyle used to draw the class break.</value>
            <remarks>
            If you set this style, then when the data for a feature is within the current
            break it will use this style to draw.<br/>
            	<br/>
            If you use the default styles, then you should only use one. The one you use should
            match your feature data. For example, if your features are lines, then you should use the
            DefaultLineStyle.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ClassBreak.DefaultLineStyle">
            <summary>
            This property gets and sets the default LineStyle used to draw the class
            break.
            </summary>
            <value>This property gets the default LineStyle used to draw the class break.</value>
            <remarks>
            If you set this style, then when the data for a feature is within the current
            break it will use this style to draw.<br/>
            	<br/>
            If you use the default styles, then you should only use one. The one you use should
            match your feature data. For example, if your features are lines, then you should use the
            DefaultLineStyle.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ClassBreak.DefaultPointStyle">
            <summary>
            This property gets and sets the default PointStyle used to draw the class
            break.
            </summary>
            <value>This property gets the default PointStyle used to draw the class break.</value>
            <remarks>
            If you set this style, then when the data for a feature is within the current
            break it will use this style to draw.<br/>
            	<br/>
            If you use the default styles, then you should only use one. The one you use should
            match your feature data. For example, if your features are lines, then you should use the
            DefaultLineStyle.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ClassBreak.DefaultTextStyle">
            <summary>
            This property gets and sets the default TextStyle used to draw the class
            break.
            </summary>
            <value>This property gets the default TextStyle used to draw the class break.</value>
            <remarks>
            If you set this style, then when the data for a feature is within the current
            break it will use this style to draw.<br/>
            	<br/>
            If you use the default styles, then you should only use one. The one you use should
            match your feature data. For example, if your features are lines then you should use the
            DefaultLineStyle.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ClassBreak.CustomStyles">
            <summary>
            This property gets a collection of custom styles used to draw the class
            break.
            </summary>
            <value>
            This property gets a collection of custom styles used to draw the class
            break.
            </value>
            <remarks>
            If you set these styles, then when the data for a feature is within the current
            break it will use this style to draw.<br/>
            	<br/>
            If you do not wish to use the default style properties, then you can use this collection
            to specify any types of styles you want to use.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RegexMatching">
            <summary>
            This enumeration defines the matching criteria for regular expression
            matching.
            </summary>
            <remarks>
            This is used to determine how much of a string needs to match a regular expression in order
            to declare it a match for that expression.
            Sometimes, you only need one part of the string to match in order for the expression to
            be considered a match; other times you may want the entire string to match.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.RegexMatching.MatchFirstOnly">
            <summary>Only part of the string must match the regular expression.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.RegexMatching.MatchAll">
            <summary>The entire string must match the regular expression.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource">
            <summary>This class represents a FeatureSource backed by ESRI a Shape File.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.FeatureSource">
            <summary>
            	<para>The abstract class from which all feature sources inherit. Feature
                sources represent feature data that can be integrated into Map Suite.</para>
            	<para>This class is key, as it is the abstract class from which all other feature
                sources are derived. In this sense it encapsulates much of the logic for handling
                transactions and ensuring the data is consistent regardless of any projections
                applied.</para>
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.#ctor">
            <summary>This is the default constructor for the abstract FeatureSource class.</summary>
            <returns>None</returns>
            <remarks>
            As this method is protected, you may only add code to this method if you override
            it from an inheriting class.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.OnCustomColumnFetch(ThinkGeo.MapSuite.Core.CustomColumnFetchEventArgs)">
            <summary>
            This method allows you to raise the CustomColumnFetch event from a derived
            class.
            </summary>
            <returns>None</returns>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            CustomColumnFetch event. This may be useful if you plan to extend the FeatureSource and
            you need access to user-definable field data.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is raised when fields are requested in a feature source method that do not
            exist in the feature source. It allows you supplement the data from any outside source
            you may have.<br/>
            	<br/>
            It is used primarily when you have data relating to a particular feature or set of
            features that is not within source of the data. For example, you may have a shape file
            of the world whose .dbf component describes the area and population of each country.
            Additionally, in an outside SQL Server table, you may also have data about the countries,
            and it is this data that you wish to use for determining how you want to color
            each country.<br/>
            	<br/>
            To integrate this SQL data, you simply create a file name that does not exist in the
            .dbf file.  Whenever Map Suite is queried to return records that specifically require
            this field, the FeatureSource will raise this event and allow you the developer to
            supply the data. In this way, you can query the SQL table and store the
            data in some sort of collection, and then when the event is raised, simply supply that
            data.<br/>
            	<br/>
            As this is an event, it will raise for each feature and field combination requested.
            This means that the event can be raised quite often, and we suggest that you cache the
            data you wish to supply in memory. We recommend against sending out a new SQL query
            each time this event is raised. Image that you are supplementing two columns and your query
            returns 2,000 rows. This means that if you requested those fields, the event would be raised
            4,000 times.
            </remarks>
            <param name="e">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.OnCommittingTransaction(ThinkGeo.MapSuite.Core.CommittingTransactionEventArgs)">
            <summary>
            This method allows you to raise the CommittingTransaction event from a derived
            class.
            </summary>
            <returns>None</returns>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            CommittingTransaction event. This may be useful if you plan to extend the FeatureSource
            and you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is raised before the CommitTransactionCore is called and allows you access
            to the TransactionBuffer before the transaction is committed. It also allows you to
            cancel the pending transaction. The TransactionBuffer is the object that stores all of
            the pending transactions and is accessible through this event to allow you either add,
            remove or modify transactions.<br/>
            	<br/>
            In the event that you cancel the CommitTransaction method, the transaction remains intact and
            you will still be editing. This makes it a nice place to possibly check for
            connectivity before the TransactionCore code is run, which is where the records are
            actually committed. Calling the RollBackTransaction method is the only way to
            permanently cancel a pending transaction without committing it.
            </remarks>
            <param name="e">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.OnCommittedTransaction(ThinkGeo.MapSuite.Core.CommittedTransactionEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the CommittedTransaction event from a derived
            class.
            </summary>
            <remarks>
                You can call this method from a derived class to enable it to raise the
                CommittedTransaction event. This may be useful if you plan to extend the
                FeatureSource and you need access to the event.<br/>
            	<br/>
                Details on the event:<br/>
            	<br/>
            	<para>This event is raised after the CommitTransactionCore is called and allows you
                access to the TransactionBuffer and the TransactionResults object before
                CommitTransaction method is returned.<br/>
            		<br/>
                With this event, you can analyze the results of the transaction and do any cleanup
                code necessary. In the event some of the records did not commit, you can handle
                these items here. The TransactionResults object is passed out of the
                CommitTransaction method so you could analyze it then; however, this is the only
                place where you have access to both the TransactionResults object and the
                TransactionBuffer object at the same time. These are useful together to try and
                determine what went wrong and possibly try and re-commit them.<br/>
            		<br/>
                At the time of this event, you will technically be out of the current
                transaction.</para>
            </remarks>
            <param name="e">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.OnOpeningFeatureSource(ThinkGeo.MapSuite.Core.OpeningFeatureSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the OpeningFeatureSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            OpeningFeatureSource event. This may be useful if you plan to extend the FeatureSource
            and you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called before the opening of the FeatureSource. Technically, this event is
            called after the calling of the Open method on the FeatureSource, but before the
            protected OpenCore method.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.OnOpenedFeatureSource(ThinkGeo.MapSuite.Core.OpenedFeatureSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the OpenedFeatureSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            OpenedFeatureSource event. This may be useful if you plan to extend the FeatureSource
            and you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called after the opening of the FeatureSource. Technically, this event is
            called after the calling of the Open method on the FeatureSource and after the
            protected OpenCore method is called.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.OnClosingFeatureSource(ThinkGeo.MapSuite.Core.ClosingFeatureSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the ClosingFeatureSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            ClosingFeatureSource event. This may be useful if you plan to extend the FeatureSource
            and you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called before the closing of the FeatureSource. Technically, this event is
            called after the calling of the Close method on the FeatureSource, but before the
            protected CloseCore method.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.OnClosedFeatureSource(ThinkGeo.MapSuite.Core.ClosedFeatureSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the ClosedFeatureSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            ClosedFeatureSource event. This may be useful if you plan to extend the FeatureSource
            and you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called after the closing of the FeatureSource. Technically, this event is
            called after the calling of the Close method on the FeatureSource and after the
            protected CloseCore method.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ExecuteNonQuery(System.String)">
            <summary>Executes a SQL statement against a connection object.</summary>
            <returns>The number of rows affected.</returns>
            <remarks>
            	You can use ExecuteNonQuery to perform catalog
                operations (for example, querying the structure of a database or creating database
                objects such as tables), or to change the data in a database by executing UPDATE,
                INSERT, or DELETE statements.
            	Although ExecuteNonQuery does not return any
                rows, any output parameters or return values mapped to parameters are populated
                with data.
            	For UPDATE, INSERT, and DELETE statements, the return value is the number of
                rows affected by the command.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ExecuteNonQueryCore(System.String)">
            <summary>Executes a SQL statement against a connection object.</summary>
            <returns>The number of rows affected.</returns>
            <remarks>
            	You can use ExecuteNonQuery to perform catalog
                operations (for example, querying the structure of a database or creating database
                objects such as tables), or to change the data in a database by executing UPDATE,
                INSERT, or DELETE statements.
            	Although ExecuteNonQuery does not return any
                rows, any output parameters or return values mapped to parameters are populated
                with data.
            	For UPDATE, INSERT, and DELETE statements, the return value is the number of
                rows affected by the command.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesByColumnValue(System.String,System.String,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
            <param name="returningColumnType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesByColumnValue(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesByColumnValue(System.String,System.String)">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesByColumnValueCore(System.String,System.String)">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesByColumnValueCore(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ExecuteScalar(System.String)">
            <summary>
            Executes the query and returns the first column of the first row in the result
            set returned by the query. All other columns and rows are ignored.
            </summary>
            <returns>The first column of the first row in the result set.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            requires less code than using the ExcuteQuery method and then performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ExecuteScalarCore(System.String)">
            <summary>
            Executes the query and returns the first column of the first row in the result
            set returned by the query. All other columns and rows are ignored.
            </summary>
            <returns>The first column of the first row in the result set.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            requires less code than using the ExcuteQuery method and then performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ExecuteQuery(System.String)">
            <summary>
            Executes the query and returns the result returned by the query.
            </summary>
            <returns>The result set in the format of dataTable.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            requires less code than using the ExcuteQuery method and then performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ExecuteQueryCore(System.String)">
            <summary>
            Executes the query and returns the result returned by the query.
            </summary>
            <returns>The result set in the format of dataTable.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            requires less code than using the ExcuteQuery method and then performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetColumns">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns the columns available for the FeatureSource and caches
            them.
            </summary>
            <returns>This method returns the columns available for the FeatureSource.</returns>
            <remarks>
            As this is the concrete method wrapping the GetColumnsCore, it is important to
            note that this method will cache the results to GetColumnsCore. What this means is that
            the first time this method is called it will call GetCollumnsCore, which is protected,
            and cache the results. The next time this method is called it will not call
            GetColumnsCore again. This was done to increase speed, as this is a critical method that
            is used very often in the internal code of the class.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetColumnsCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the columns available for the FeatureSource.</summary>
            <remarks>
            As this is the virtual core version of the Columns method, it is intended to
            be overridden in inherited version of the class. When overriding, you will be
            responsible for getting a list of all of the columns supported by the FeatureSource. In
            this way, the FeatureSource will know what columns are available and will remove any
            extra columns when making calls to other core methods. For example, if you have a
            FeatureSource that has three columns of information and the user calls a method that
            requests four columns of information (something they can do with custom fields), we will
            first compare what they are asking for to the results of the GetColumnsCore. This
            way we can strip out custom columns before calling other Core methods, which are only
            responsible for returning data in the FeatureSource. For more information on custom
            fields, please see the documentation on OnCustomFieldsFetch.
            </remarks>
            <returns>This method returns the columns available for the FeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.RefreshColumns">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method refresh the columns available for the FeatureSource and caches
            them.
            </summary>
            <returns>This method refresh the columns available for the FeatureSource.</returns>
            <remarks>
            None.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetCount">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns the count of the number of records in this
            FeatureSource.
            </summary>
            <returns>
            This method returns the count of the number of records in this
            FeatureSource.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method GetCountCore. It will
            return whatever is returned by the GetCountCore method, along with any additions
            or subtractions made if you are in a transaction and that transaction is configured to
            be live. To determine what the default implementation of the abstract GetCountCore
            method is, please see the documentation for it.<br/>
            	<br/>
            The default implementation of GetCountCore uses the GetAllRecordsCore method to
            calculate how many records there are in the FeatureSource. We strongly recommend that
            you provide your own implementation for this method that will be more efficient.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetCountCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <summary>
            This method returns the count of the number of records in this
            FeatureSource.
            </summary>
            <returns>
            This method returns the count of the number of records in this
            FeatureSource.
            </returns>
            <remarks>
            	<para>This protected virtual method is called from the concrete public method
                GetCount. It does not take into account any transaction activity, as this is the
                responsibility of the concrete public method GetCount. This way, as a developer,
                if you choose to override this method you do not have to consider transactions at
                all.<br/>
            		<br/>
                The default implementation of GetCountCore uses the GetAllRecordsCore method to
                calculate how many records there are in the FeatureSource. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient.<br/>
            		<br/>
                If you do not override this method, it will get the count by calling the
                GetAllFeatureCore method and counting each feature. This is a very inefficient way
                to get the count in most data sources. It is highly recommended that you override
                this method and replace it with a highly optimized version. For example, in a
                ShapeFile the record count is in the main header of the file. Similarly, if you are
                using Oracle Spatial, you can execute a simple query to get the count of all of the
                records without returning them. In these ways you can greatly improve the
                performance of this method.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetBoundingBox">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </summary>
            <returns>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method GetBoundingBoxCore. It
            will return whatever is returned by the GetBoundingBoxCore method, along with any
            additions or subtractions made if you are in a transaction and that transaction is
            configured to be live. To determine what the default implementation of the abstract
            GetBoundingBoxCore method is, please see the documentation for it.<br/>
            	<br/>
            The default implementation of GetBoundingBoxCore uses the GetAllRecordsCore method to
            calculate the bounding box of the FeatureSource. We strongly recommend that you provide
            your own implementation for this method that will be more efficient.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state, it will throw a InvalidOperationException.</exception>
            <remarks>
            	<para>This protected virtual method is called from the concrete public method
                GetBoundingBox. It does not take into account any transaction activity, as this is
                the responsibility of the concrete public method GetBoundingBox. In this way, as a
                developer, if you choose to override this method you do not have to consider
                transactions at all.<br/>
            		<br/>
                The default implementation of GetBoundingBoxCore uses the GetAllRecordsCore method
                to calculate the bounding box of the FeatureSource. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.<br/>
            		<br/>
                If you do not override this method, it will get the BoundingBox by calling
                the GetAllFeatureCore method and deriving it from each feature. This is a very
                inefficient way to get the BoundingBox in most data sources. It is highly
                recommended that you override this method and replace it with a highly optimized
                version. For example, in a ShapeFile the BoundingBox is in the main header of the
                file. Similarly, if you are using Oracle Spatial, you can execute a simple query to
                get the BoundingBox of all the records without returning them. In these ways you
                can greatly improve the performance of this method.</para>
            </remarks>
            <summary>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </summary>
            <returns>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.CloneDeep">
            <summary>Create a copy of a FeatureSource using the deep clone process.</summary>
            <returns>A cloned FeatureSource.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.CloneDeepCore">
            <summary>Create a copy of a FeatureSource using the deep clone process. The default implementation uses serialization.</summary>
            <returns>A cloned FeatureSource.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.Open">
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method OpenCore. The
                Open method plays an important role, as it is responsible for initializing the
                FeatureSource. Most methods on the FeatureSource will throw an exception if the
                state of the FeatureSource is not opened. When the map draws each layer, it will
                open the FeatureSource as one of its first steps, then after it is finished drawing
                with that layer it will close it. In this way we are sure to release all resources
                used by the FeatureSource.<br/>
            		<br/>
                When implementing the abstract method, consider opening files for file-based sources,
                connecting to databases in the database-based sources and so on. You will get a
                chance to close these in the Close method of the FeatureSource.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concrete public method Open.
            The Open method plays an important role, as it is responsible for initializing the
            FeatureSource. Most methods on the FeatureSource will throw an exception if the state
            of the FeatureSource is not opened. When the map draws each layer, it will open the
            FeatureSource as one of its first steps, then after it is finished drawing with that
            layer it will close it. In this way we are sure to release all resources used by the
            FeatureSource.<br/>
            	<br/>
            When implementing this virtual method ,consider opening files for file-based sources,
            connecting to databases in the database-based sources and so on. You will get a chance
            to close these in the Close method of the FeatureSource.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.Close">
            <remarks>
            This method is the concrete wrapper for the abstract method CloseCore. The Close
            method plays an important role in the life cycle of the FeatureSource. It may be called
            after drawing to release any memory and other resources that were allocated since the
            Open method was called.<br/>
            	<br/>
            If you override the Core version of this method, it is recommended that you take
            the following things into account: This method may be called multiple times, so we
            suggest you write the method so that that a call to a closed FeatureSource is ignored and does
            not generate an error. We also suggest that in the Close you free all resources that
            have been opened. Remember that the object will not be destroyed, but will be re-opened
            possibly in the near future.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>
            This method closes the FeatureSource and releases any resources it was using.
            </summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.CloseCore">
            <summary>
            This method closes the FeatureSource and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concrete public method Close.
            The close method plays an important role in the life cycle of the FeatureSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed FeatureSource is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.BeginTransaction">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is in transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not editable, it will throw an InvalidOperationException.</exception>
            <summary>This method starts a new transaction if the FeasuteSource allows editing</summary>
            <returns>None</returns>
            <remarks>
            This method is used to start a transaction, assuming that the FeatureSource allows
            editing. There are some additional prerequisites to beginning a transaction, such as ensuring
            that a transaction is not already in progress. You must also be sure that the FeatureSource has
            been opened.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureSource sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureSource. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureSource is responsible for integrating your changes into the underlying
            FeatureSource. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureSource API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureSource that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureSource reflect the
            changes.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.AddFeature(ThinkGeo.MapSuite.Core.Feature)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction it will throw an InvalidOperationException.</exception>        
            <summary>This method adds a new Feature to an existing transaction.</summary>
            <remarks>
            This method adds a new Feature to an existing transaction. You will need to
            ensure that you have started a transaction by calling BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureSource sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureSource. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureSource is responsible for integrating your changes into the underlying
            FeatureSource. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureSource API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureSource that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureSource reflect the
            changes.
            </remarks>
            <returns>
            This string is the ID that will uniquely identify this Feature while it is in a
            transaction.
            </returns>
            <param name="feature">
            This parameter represents the new Feature that will be added to the
            transaction.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.AddFeature(ThinkGeo.MapSuite.Core.BaseShape)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction, it will throw an InvalidOperationException.</exception>        
            <summary>This method adds a new Feature (composed of the passed-in BaseShape) to an existing transaction.</summary>
            <remarks>
            This method adds a new Feature (composed of the passed-in BaseShape) to an existing transaction. You will need to
            ensure that you have started a transaction by calling BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureSource sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureSource. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureSource is responsible for integrating your changes into the underlying
            FeatureSource. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureSource API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureSource that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureSource reflect the
            changes.
            </remarks>
            <returns>
            This string is the ID that will uniquely identify this Feature while it is in a
            transaction.
            </returns>
            <param name="shape">
            This parameter represents the BaseShape that will be used to make the new Feature that will be added to the
            transaction.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.AddFeature(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.IDictionary{System.String,System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction, it will throw an InvalidOperationException.</exception>        
            <summary>This method adds a new Feature composes of the passed in BaseShape to an existing transaction.</summary>
            <remarks>
            This method adds a new Feature (composed of the passed-in BaseShape) to an existing transaction. You will need to
            ensure that you have started a transaction by calling the BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureSource sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureSource. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureSource is responsible for integrating your changes into the underlying
            FeatureSource. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureSource API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureSource that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureSource reflect the
            changes.
            </remarks>
            <returns>
            This string is the ID that will uniquely identify this Feature while it is in a
            transaction.
            </returns>
            <param name="shape">
            This parameter represents the BaseShape that will be used to make new Feature that will be added to the
            transaction.
            </param>
            <param name="columnValues">This parameter represents the columnValues for the new features taht will be added to the transaction.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.DeleteFeature(System.String)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the id, we will throw an ArgumentNullException.</exception>
            <remarks>
            This method deletes a Feature from an existing transaction. You will need to
            ensure that you have started a transaction by calling the BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureSource sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureSource. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureSource is responsible for integrating your changes into the underlying
            FeatureSource. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureSource API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureSource that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureSource reflect the
            changes.
            </remarks>
            <summary>This method deletes a Feature from an existing transaction.</summary>
            <returns>None</returns>
            <param name="id">
            This string is the Id of the feature in the FeatureSource you wish to
            delete.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.UpdateFeature(ThinkGeo.MapSuite.Core.Feature)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the feature, we will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method updates a Feature in an existing transaction. You will need to
                ensure that you have started a transaction by calling the BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited implementation
            	of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            	the same way for every FeatureSource. You start by calling BeginTransaction. This
            	allocates a collection of in-memory change buffers that are used to store changes until
            	you commit the transaction. So, for example, when you call the Add, Delete or Update
            	method, the changes to the feature are stored in memory only. If for any reason you
            	choose to abandon the transaction, you can call RollbackTransaction at any time and the
            	in-memory buffer will be deleted and the changes will be lost. When you are ready to
            	commit the transaction, you call CommitTransaction and the collections of changes
            	are then passed to the CommitTransactionCore method and the implementer of the specific
            	FeatureSource is responsible for integrating your changes into the underlying
            	FeatureSource. By default the IsLiveTransaction property is set to false, which means
            	that until you commit the changes, the FeatureSource API will not reflect any changes
            	that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
            	differently. The live transaction concept means that all of the modifications you
            	perform during a transaction are live from the standpoint of the querying methods on
            	the object.</para>
            	<para>As an example, imagine that you have a FeatureSource that has 10 records in it.
            	Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            	records. After that, you call a delete on one of the records and call the GetAllFeatures
            	again.  This time you only get nine records, even though the
            	transaction has not yet been committed. In the same sense, you could have added a new
            	record or modified an existing one and those changes would be considered live, though not
            	committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
            	changes are reflected as well. For example, you expand a polygon by doubling its size
            	and then do a spatial query that would not normally return the smaller record, but instead
            	would return the larger records.  In this case, the larger records are returned. You can set this
            	property to be false, as well; in which case, all of the spatially related methods would
            	ignore anything that is currently in the transaction buffer waiting to be committed. In
            	such a case, only after committing the transaction would the FeatureSource reflect the
            	changes.</para>
            </remarks>
            <summary>This method updates a Feature in an existing transaction.</summary>
            <param name="feature">The Feature you wish to update in the transaction.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.UpdateFeature(ThinkGeo.MapSuite.Core.BaseShape)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the feature, we will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method updates a Feature (composed of the passed-in BaseShape) in an existing transaction. You will need to
                ensure that you have started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited implementation
            	of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            	the same way for every FeatureSource. You start by calling BeginTransaction. This
            	allocates a collection of in-memory change buffers that are used to store changes until
            	you commit the transaction. So, for example, when you call the Add, Delete or Update
            	method, the changes to the feature are stored in memory only. If for any reason you
            	choose to abandon the transaction, you can call RollbackTransaction at any time and the
            	in-memory buffer will be deleted and the changes will be lost. When you are ready to
            	commit the transaction, you call CommitTransaction and the collections of changes
            	are then passed to the CommitTransactionCore method and the implementer of the specific
            	FeatureSource is responsible for integrating your changes into the underlying
            	FeatureSource. By default the IsLiveTransaction property is set to false, which means
            	that until you commit the changes, the FeatureSource API will not reflect any changes
            	that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
            	differently. The live transaction concept means that all of the modifications you
            	perform during a transaction are live from the standpoint of the querying methods on
            	the object.</para>
            	<para>As an example, imagine that you have a FeatureSource that has 10 records in it.
            	Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            	records. After that, you call a delete on one of the records and call the GetAllFeatures
            	again.  This time you only get nine records, even though the
            	transaction has not yet been committed. In the same sense, you could have added a new
            	record or modified an existing one and those changes would be considered live, though not
            	committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
            	changes are reflected as well. For example, you expand a polygon by doubling its size
            	and then do a spatial query that would not normally return the smaller record, but instead
            	would return the larger records.  In this case, the larger records are returned. You can set this
            	property to be false, as well; in which case, all of the spatially related methods would
            	ignore anything that is currently in the transaction buffer waiting to be committed. In
            	such a case, only after committing the transaction would the FeatureSource reflect the
            	changes.</para>
            </remarks>
            <summary>This method updates a Feature (composed of the passed-in BaseShape) in an existing transaction.</summary>
            <param name="shape">The shape that will be used to make the new Feature that you wish to update in the transaction.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.UpdateFeature(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.IDictionary{System.String,System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the feature, we will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method updates a Feature (composed of the passed in BaseShape) in an existing transaction. You will need to
                ensure that you have started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited implementation
            	of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            	the same way for every FeatureSource. You start by calling BeginTransaction. This
            	allocates a collection of in-memory change buffers that are used to store changes until
            	you commit the transaction. So, for example, when you call the Add, Delete or Update
            	method, the changes to the feature are stored in memory only. If for any reason you
            	choose to abandon the transaction, you can call RollbackTransaction at any time and the
            	in-memory buffer will be deleted and the changes will be lost. When you are ready to
            	commit the transaction, you call CommitTransaction and the collections of changes
            	are then passed to the CommitTransactionCore method and the implementer of the specific
            	FeatureSource is responsible for integrating your changes into the underlying
            	FeatureSource. By default the IsLiveTransaction property is set to false, which means
            	that until you commit the changes, the FeatureSource API will not reflect any changes
            	that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
            	differently. The live transaction concept means that all of the modifications you
            	perform during a transaction are live from the standpoint of the querying methods on
            	the object.</para>
            	<para>As an example, imagine that you have a FeatureSource that has 10 records in it.
            	Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            	records. After that, you call a delete on one of the records and call the GetAllFeatures
            	again.  This time you only get nine records, even though the
            	transaction has not yet been committed. In the same sense, you could have added a new
            	record or modified an existing one and those changes would be considered live, though not
            	committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
            	changes are reflected as well. For example, you expand a polygon by doubling its size
            	and then do a spatial query that would not normally return the smaller record, but instead
            	would return the larger records.  In this case, the larger records are returned. You can set this
            	property to be false, as well; in which case, all of the spatially related methods would
            	ignore anything that is currently in the transaction buffer waiting to be committed. In
            	such a case, only after committing the transaction would the FeatureSource reflect the
            	changes.</para>
            </remarks>
            <summary>This method updates a Feature (composed of the passed-in BaseShape) in an existing transaction.</summary>
            <param name="shape">The shape that will be used to make the new Feature that you wish to update in the transaction.</param>
            <param name="columnValues">This parameter represents the columnValues for the new features that will be added to the transaction.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.RollbackTransaction">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method will cancel an existing transaction. It will free up the internal
                memory cache of any InternalFeatures added, updated or deleted. You will need to ensure
                that you have started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited implementation
            	of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            	the same way for every FeatureSource. You start by calling BeginTransaction. This
            	allocates a collection of in-memory change buffers that are used to store changes until
            	you commit the transaction. So, for example, when you call the Add, Delete or Update
            	method, the changes to the feature are stored in memory only. If for any reason you
            	choose to abandon the transaction, you can call RollbackTransaction at any time and the
            	in-memory buffer will be deleted and the changes will be lost. When you are ready to
            	commit the transaction, you call CommitTransaction and the collections of changes
            	are then passed to the CommitTransactionCore method and the implementer of the specific
            	FeatureSource is responsible for integrating your changes into the underlying
            	FeatureSource. By default the IsLiveTransaction property is set to false, which means
            	that until you commit the changes, the FeatureSource API will not reflect any changes
            	that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
            	differently. The live transaction concept means that all of the modifications you
            	perform during a transaction are live from the standpoint of the querying methods on
            	the object.</para>
            	<para>As an example, imagine that you have a FeatureSource that has 10 records in it.
            	Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            	records. After that, you call a delete on one of the records and call the GetAllFeatures
            	again.  This time you only get nine records, even though the
            	transaction has not yet been committed. In the same sense, you could have added a new
            	record or modified an existing one and those changes would be considered live, though not
            	committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
            	changes are reflected as well. For example, you expand a polygon by doubling its size
            	and then do a spatial query that would not normally return the smaller record, but instead
            	would return the larger records.  In this case, the larger records are returned. You can set this
            	property to be false, as well; in which case, all of the spatially related methods would
            	ignore anything that is currently in the transaction buffer waiting to be committed. In
            	such a case, only after committing the transaction would the FeatureSource reflect the
            	changes.</para>
            </remarks>
            <summary>
            This method will cancel an existing transaction. It will free up the internal
            memory cache of any InternalFeatures added, updated or deleted.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.CommitTransaction">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <returns>
            The returned decimalDegreesValue of this method is a TransactionResult class, which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful and any errors that were encountered during the
            committing of the transaction.
            </returns>
            <remarks>
            	<para>This method is the concrete wrapper for the virtual method
                CommitTransactionCore. As this is the concrete version, the real work is done in the
                Core version of the method. It will commit the existing transaction to its
                underlying source of data. It will then pass back the results of the commit, including
                any error(s) received. Lastly, it will free up the internal memory cache
                of any InternalFeatures added, updated or deleted. You will need to ensure that you have
                started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited implementation
            	of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            	the same way for every FeatureSource. You start by calling BeginTransaction. This
            	allocates a collection of in-memory change buffers that are used to store changes until
            	you commit the transaction. So, for example, when you call the Add, Delete or Update
            	method, the changes to the feature are stored in memory only. If for any reason you
            	choose to abandon the transaction, you can call RollbackTransaction at any time and the
            	in-memory buffer will be deleted and the changes will be lost. When you are ready to
            	commit the transaction, you call CommitTransaction and the collections of changes
            	are then passed to the CommitTransactionCore method and the implementer of the specific
            	FeatureSource is responsible for integrating your changes into the underlying
            	FeatureSource. By default the IsLiveTransaction property is set to false, which means
            	that until you commit the changes, the FeatureSource API will not reflect any changes
            	that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
            	differently. The live transaction concept means that all of the modifications you
            	perform during a transaction are live from the standpoint of the querying methods on
            	the object.</para>
            	<para>As an example, imagine that you have a FeatureSource that has 10 records in it.
            	Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            	records. After that, you call a delete on one of the records and call the GetAllFeatures
            	again.  This time you only get nine records, even though the
            	transaction has not yet been committed. In the same sense, you could have added a new
            	record or modified an existing one and those changes would be considered live, though not
            	committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
            	changes are reflected as well. For example, you expand a polygon by doubling its size
            	and then do a spatial query that would not normally return the smaller record, but instead
            	would return the larger records.  In this case, the larger records are returned. You can set this
            	property to be false, as well; in which case, all of the spatially related methods would
            	ignore anything that is currently in the transaction buffer waiting to be committed. In
            	such a case, only after committing the transaction would the FeatureSource reflect the
            	changes.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.CommitTransactionCore(ThinkGeo.MapSuite.Core.TransactionBuffer)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
            <remarks>
            	<para>This method will commit the existing transaction to its underlying source of
                data. It will then pass back the results of the commit, including any error(s)
                received. If you are implementing your own FeatureSource, this is one of the
                crucial methods you must create. It should be fairly straightforward that you will
                loop through the transaction buffer and add, edit or delete the InternalFeatures in your
                underlying data source. Remember to build and pass back the TransactionResult class
                so that users of your FeatureSource can respond to failures you may encounter while
                committing the InternalFeatures. We will handle the end of the transaction and also the
                cleanup of the transaction buffer. Your task will be to commit the records and
                produce a TransactionResult return.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited implementation
            	of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            	the same way for every FeatureSource. You start by calling BeginTransaction. This
            	allocates a collection of in-memory change buffers that are used to store changes until
            	you commit the transaction. So, for example, when you call the Add, Delete or Update
            	method, the changes to the feature are stored in memory only. If for any reason you
            	choose to abandon the transaction, you can call RollbackTransaction at any time and the
            	in-memory buffer will be deleted and the changes will be lost. When you are ready to
            	commit the transaction, you call CommitTransaction and the collections of changes
            	are then passed to the CommitTransactionCore method and the implementer of the specific
            	FeatureSource is responsible for integrating your changes into the underlying
            	FeatureSource. By default the IsLiveTransaction property is set to false, which means
            	that until you commit the changes, the FeatureSource API will not reflect any changes
            	that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
            	differently. The live transaction concept means that all of the modifications you
            	perform during a transaction are live from the standpoint of the querying methods on
            	the object.</para>
            	<para>As an example, imagine that you have a FeatureSource that has 10 records in it.
            	Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            	records. After that, you call a delete on one of the records and call the GetAllFeatures
            	again.  This time you only get nine records, even though the
            	transaction has not yet been committed. In the same sense, you could have added a new
            	record or modified an existing one and those changes would be considered live, though not
            	committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
            	changes are reflected as well. For example, you expand a polygon by doubling its size
            	and then do a spatial query that would not normally return the smaller record, but instead
            	would return the larger records.  In this case, the larger records are returned. You can set this
            	property to be false, as well; in which case, all of the spatially related methods would
            	ignore anything that is currently in the transaction buffer waiting to be committed. In
            	such a case, only after committing the transaction would the FeatureSource reflect the
            	changes.</para>
            </remarks>
            <returns>
            The returned decimalDegreesValue of this method is a TransactionResult class which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful, as well as any error(s) that were encountered during the
            committing of the transaction.
            </returns>
            <param name="transactions">
            This parameter encapsulates all of the adds, edits and deletes that make up the
            transaction. You will use this data to write the changes to your underlying data
            source.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetAllFeatures(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. It will return
            whatever is returned by the GetAllFeaturesCore method, along with any of the additions or
            subtractions made if you are in a transaction and that transaction is configured to be
            live.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We as the framework developers wanted to provide you
            the user with as much default virtual implementation as possible. To do this, we needed
            a way to get access to all of the features. For example, let's say we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class, we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all of the records, then we can brute-force
            the answer. In this way, if you inherited from this class and only implemented this one
            method, we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource,
            it comes with a price: namely, it is very inefficient. In the example we just
            discussed (about finding all of the InternalFeatures in a bounding box), we would not want to look
            at every record to fulfil this method. Instead, we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be faster. For
            example, in Oracle Spatial there is a specific SQL statement to perform this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore, which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. This will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetAllFeatures(ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. It will return
            whatever is returned by the GetAllFeaturesCore method, along with any of the additions or
            subtractions made if you are in a transaction and that transaction is configured to be
            live.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We as the framework developers wanted to provide you
            the user with as much default virtual implementation as possible. To do this, we needed
            a way to get access to all of the features. For example, let's say we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class, we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all of the records, then we can brute-force
            the answer. In this way, if you inherited from this class and only implemented this one
            method, we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource,
            it comes with a price: namely, it is very inefficient. In the example we just
            discussed (about finding all of the InternalFeatures in a bounding box), we would not want to look
            at every record to fulfil this method. Instead, we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be faster. For
            example, in Oracle Spatial there is a specific SQL statement to perform this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore, which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. This will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetAllFeaturesCore(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. You will not need
            to consider anything about pending transactions, as this will be handled in the non-Core
            version of the method.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We as the framework developers wanted to provide you
            the user with as much default virtual implementation as possible. To do this, we needed
            a way to get access to all of the features. For example, let's say we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class, we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all of the records, then we can brute-force
            the answer. In this way, if you inherited from this class and only implemented this one
            method, we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource,
            it comes with a price: namely, it is very inefficient. In the example we just
            discussed (about finding all of the InternalFeatures in a bounding box), we would not want to look
            at every record to fulfil this method. Instead, we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be faster. For
            example, in Oracle Spatial there is a specific SQL statement to perform this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore, which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. This will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.
            </remarks>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesOutsideBoundingBox(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<para>This method returns all of the InternalFeatures of this FeatureSource outside of the
                specified bounding box. If you are in a transaction and that transaction is live,
                this method will also take that into consideration.<br/>
            		<br/>
            		<br/>
                The default implementation of GetFeaturesOutsideBoundingBoxCore uses the
                GetAllRecordsCore method to determine which InternalFeatures are outside of the bounding
                box. We strongly recommend that you provide your own implementation for this method
                that will be more efficient.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </summary>
            <returns>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </returns>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesOutsideBoundingBox(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<para>This method returns all of the InternalFeatures of this FeatureSource outside of the
                specified bounding box. If you are in a transaction and that transaction is live,
                this method will also take that into consideration.<br/>
            		<br/>
            		<br/>
                The default implementation of GetFeaturesOutsideBoundingBoxCore uses the
                GetAllRecordsCore method to determine which InternalFeatures are outside of the bounding
                box. We strongly recommend that you provide your own implementation for this method
                that will be more efficient.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </summary>
            <returns>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </returns>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesOutsideBoundingBoxCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </returns>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </summary>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box. If you are in a transaction and that transaction is live,
            this method will also take that into consideration.<br/>
            	<br/>
            	<br/>
            The default implementation of GetFeaturesOutsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are outside of the bounding box.
            We strongly recommend that you provide your own implementation for this method that
            will be more efficient.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesInsideBoundingBox(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box.
            </summary>
            <remarks>
            	<para>This method returns all of the InternalFeatures of this FeatureSource inside of the
                specified bounding box. If you are in a transaction and that transaction is live,
                this method will also take that into consideration.<br/>
            		<br/>
            		<br/>
                The default implementation of GetFeaturesInsideBoundingBoxCore uses the
                GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding
                box. We strongly recommend that you provide your own implementation for this method
                that will be more efficient. That is especially important for this method, as many
                other default virtual methods use this for their calculations. When you override this
                method, we recommend that you use any spatial indexes you have at your disposal
                to make this method as fast as possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesInsideBoundingBox(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box.
            </summary>
            <remarks>
            	<para>This method returns all of the InternalFeatures of this FeatureSource inside of the
                specified bounding box. If you are in a transaction and that transaction is live,
                this method will also take that into consideration.<br/>
            		<br/>
            		<br/>
                The default implementation of GetFeaturesInsideBoundingBoxCore uses the
                GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding
                box. We strongly recommend that you provide your own implementation for this method
                that will be more efficient. That is especially important for this method, as many
                other default virtual methods use this for their calculations. When you override this
                method, we highly recommend that you use any spatial indexes you have at your disposal
                to make this method as fast as possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesInsideBoundingBoxCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource that are inside of the
            specified bounding box.
            </summary>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource that are inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions, as this is handled by the concrete version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesInsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding box. We
            strongly recommend that you provide your own implementation for this method that will
            be more efficient. That is especially important for this method, as many other default
            virtual methods use this for their calculations. When you override this method, we highly recommend
            that you use any spatial indexes you have at your disposal to make this
            method as fast as possible.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data that you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesForDrawing(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method returns the InternalFeatures that will be used for drawing.</summary>
            <returns>This method returns the InternalFeatures that will be used for drawing.</returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures of this FeatureSource that are inside of the
                specified bounding box. If you are in a transaction and that transaction is live,
                this method will also take that into consideration.<br/>
            		<br/>
            		<br/>
                The default implementation of GetFeaturesForDrawing uses the
                GetFeaturesInsodeBoundingBoxCore with some optimizations based on the screen width
                and height. For example, we can determine if a feature is going to draw in only one
                to four pixels and in that case we may not draw the entire feature but just a
                subset of it instead.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="boundingBox">This parameter is the bounding box of the InternalFeatures you want to draw.</param>
            <param name="screenWidth">
            This parameter is the width of the canvas, in screen pixels, that you will draw on.
            </param>
            <param name="screenHeight">
            This parameter is the height of the canvas, in screen pixels, that you will draw on.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesForDrawing(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,System.Double,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <summary>This method returns the InternalFeatures that will be used for drawing.</summary>
            <returns>This method returns the InternalFeatures that will be used for drawing.</returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures of this FeatureSource that are inside of the
                specified bounding box. If you are in a transaction and that transaction is live,
                this method will also take that into consideration.<br/>
            		<br/>
            		<br/>
                The default implementation of GetFeaturesForDrawing uses the
                GetFeaturesInsodeBoundingBoxCore with some optimizations based on the screen width
                and height. For example, we can determine if a feature is going to draw in only one
                to four pixels and in that case we may not draw the entire feature but just a
                subset of it instead.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="boundingBox">This parameter is the bounding box of the InternalFeatures that you want to draw.</param>
            <param name="screenWidth">
            This parameter is the width of the canvas, in screen pixels, that you will draw on.
            </param>
            <param name="screenHeight">
            This parameter is the height of the canvas, in screen pixels, that you will draw on.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType you wish to return with each Feature.</param> 
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesForDrawingCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource that are inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions, as this is handled by the concrete version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesForDrawingCore uses the
            GetFeaturesInsodeBoundingBoxCore with some optimizations based on the screen width and
            height. For example, we can determine if a feature is going to draw in only one
            to four pixels and in that case we may not draw the entire feature but just a
            subset of it instead.
            </remarks>
            <summary>This method returns the InternalFeatures that will be used for drawing.</summary>
            <returns>This method returns the InternalFeatures that will be used for drawing.</returns>
            <param name="boundingBox">This parameter is the bounding box of the InternalFeatures that you want to draw.</param>
            <param name="screenWidth">
            This parameter is the width of the canvas, in screen pixels, that you will draw on.
            </param>
            <param name="screenHeight">
            This parameter is the height of the canvas, in screen pixels, that you will draw on.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.SpatialQuery(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.QueryType,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and the
            spatial query type specified.
            </summary>
            <returns>
            The returned decimalDegreesValue is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures based on the target Feature and the
                spatial query type specified below. If there is a current transaction and it is
                marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
            		<strong>Spatial Query Types:</strong><br/>
            		<br/>
            		<strong>Disjoint</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have no points in common.<br/>
            		<br/>
            		<strong>Intersects</strong> - This method returns InternalFeatures where the specific
                Feature and the targetShape have at least one point in common.<br/>
            		<br/>
            		<strong>Touches</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have at least one boundary point in common, but no interior
                points.<br/>
            		<br/>
            		<strong>Crosses</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all interior points.<br/>
            		<br/>
            		<strong>Within</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the targetShape.<br/>
            		<br/>
            		<strong>Contains</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the current shape.<br/>
            		<br/>
            		<strong>Overlaps</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all points in common.<br/>
            		<br/>
            		<strong>TopologicalEqual</strong> - This method returns InternalFeatures where the specific
                Feature and the target Shape are topologically equal.<br/>
            		<br/>
                The default implementation of SpatialQueryCore uses the
                GetFeaturesInsideBoundingBoxCore method to pre-filter the spatial query. We
                strongly recommend that you provide your own implementation for this method that
                will be more efficient. When you override this method, we recommend that you use any
                spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="queryType">This parameter specifies what kind of spatial query you wish to perform.</param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a queryType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.SpatialQuery(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.QueryType,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and the
            spatial query type specified.
            </summary>
            <returns>
            The return decimalDegreesValue is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures based on the target Feature and the
                spatial query type specified below. If there is a current transaction and it is
                marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
            		<strong>Spatial Query Types:</strong><br/>
            		<br/>
            		<strong>Disjoint</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have no points in common.<br/>
            		<br/>
            		<strong>Intersects</strong> - This method returns InternalFeatures where the specific
                Feature and the targetShape have at least one point in common.<br/>
            		<br/>
            		<strong>Touches</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have at least one boundary point in common, but no interior
                points.<br/>
            		<br/>
            		<strong>Crosses</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all interior points.<br/>
            		<br/>
            		<strong>Within</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the targetShape.<br/>
            		<br/>
            		<strong>Contains</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the current shape.<br/>
            		<br/>
            		<strong>Overlaps</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all points in common.<br/>
            		<br/>
            		<strong>TopologicalEqual</strong> - This method returns InternalFeatures where the specific
                Feature and the target Shape are topologically equal.<br/>
            		<br/>
                The default implementation of SpatialQueryCore uses the
                GetFeaturesInsideBoundingBoxCore method to pre-filter the spatial query. We
                strongly recommend that you provide your own implementation for this method that
                will be more efficient. When you override this method, we recommend that you use any
                spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="queryType">This parameter specifies what kind of spatial query you wish to perform.</param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a queryType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.SpatialQuery(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.QueryType,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and the
            spatial query type specified.
            </summary>
            <returns>
            The returned decimalDegreesValue is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures based on the target Feature and the
                spatial query type specified below. If there is a current transaction and it is
                marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
            		<strong>Spatial Query Types:</strong><br/>
            		<br/>
            		<strong>Disjoint</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have no points in common.<br/>
            		<br/>
            		<strong>Intersects</strong> - This method returns InternalFeatures where the specific
                Feature and the targetShape have at least one point in common.<br/>
            		<br/>
            		<strong>Touches</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have at least one boundary point in common, but no interior
                points.<br/>
            		<br/>
            		<strong>Crosses</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all interior points.<br/>
            		<br/>
            		<strong>Within</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the targetShape.<br/>
            		<br/>
            		<strong>Contains</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the current shape.<br/>
            		<br/>
            		<strong>Overlaps</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all points in common.<br/>
            		<br/>
            		<strong>TopologicalEqual</strong> - This method returns InternalFeatures where the specific
                Feature and the target Shape are topologically equal.<br/>
            		<br/>
                The default implementation of SpatialQueryCore uses the
                GetFeaturesInsideBoundingBoxCore method to pre-filter the spatial query. We
                strongly recommend that you provide your own implementation for this method that
                will be more efficient. When you override this method, we recommend that you use any
                spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="feature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="queryType">This parameter specifies what kind of spatial query you wish to perform.</param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a queryType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.SpatialQuery(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.QueryType,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and the
            spatial query type specified.
            </summary>
            <returns>
            The returned decimalDegreesValue is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures based on the target Feature and the
                spatial query type specified below. If there is a current transaction and it is
                marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
            		<strong>Spatial Query Types:</strong><br/>
            		<br/>
            		<strong>Disjoint</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have no points in common.<br/>
            		<br/>
            		<strong>Intersects</strong> - This method returns InternalFeatures where the specific
                Feature and the targetShape have at least one point in common.<br/>
            		<br/>
            		<strong>Touches</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape have at least one boundary point in common, but no interior
                points.<br/>
            		<br/>
            		<strong>Crosses</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all interior points.<br/>
            		<br/>
            		<strong>Within</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the targetShape.<br/>
            		<br/>
            		<strong>Contains</strong> - This method returns InternalFeatures where the specific Feature
                lies within the interior of the current shape.<br/>
            		<br/>
            		<strong>Overlaps</strong> - This method returns InternalFeatures where the specific Feature
                and the targetShape share some but not all points in common.<br/>
            		<br/>
            		<strong>TopologicalEqual</strong> - This method returns InternalFeatures where the specific
                Feature and the target Shape are topologically equal.<br/>
            		<br/>
                The default implementation of SpatialQueryCore uses the
                GetFeaturesInsideBoundingBoxCore method to pre-filter the spatial query. We
                strongly recommend that you provide your own implementation for this method that
                will be more efficient. When you override this method, we recommend that you use any
                spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="feature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="queryType">This parameter specifies what kind of spatial query you wish to perform.</param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a queryType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>       
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.SpatialQueryCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.QueryType,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method returns all of the InternalFeatures based on the target Feature and the
            spatial query type specified below. If you override this method, you do not need to
            consider transactions. It is suggested that if you are looking to speed up this method
            that you first override the GetFeaturesInsideBoundingBoxCore and then re-test this
            method, as it relies heavily on that method internally. See more information
            below.<br/>
            	<br/>
            	<strong>Spatial Query Types:</strong><br/>
            	<br/>
            	<strong>Disjoint</strong> - This method returns InternalFeatures where the specific Feature and
            the targetShape have no points in common.<br/>
            	<br/>
            	<strong>Intersects</strong> - This method returns InternalFeatures where the specific Feature
            and the targetShape have at least one point in common.<br/>
            	<br/>
            	<strong>Touches</strong> - This method returns InternalFeatures where the specific Feature and
            the targetShape have at least one boundary point in common, but no interior
            points.<br/>
            	<br/>
            	<strong>Crosses</strong> - This method returns InternalFeatures where the specific Feature and
            the targetShape share some but not all interior points.<br/>
            	<br/>
            	<strong>Within</strong> - This method returns InternalFeatures where the specific Feature lies
            within the interior of the targetShape.<br/>
            	<br/>
            	<strong>Contains</strong> - This method returns InternalFeatures where the specific Feature
            lies within the interior of the current shape.<br/>
            	<br/>
            	<strong>Overlaps</strong> - This method returns InternalFeatures where the specific Feature and
            the targetShape share some but not all points in common.<br/>
            	<br/>
            	<strong>TopologicalEqual</strong> - This method returns InternalFeatures where the specific
            Feature and the target Shape are topologically equal.<br/>
            	<br/>
            The default implementation of SpatialQueryCore uses the
            GetFeaturesInsideBoundingBoxCore method to pre-filter the spatial query. We strongly
            recommend that you provide your own implementation for this method that will be more
            efficient. When you override this method, we recommend that you use any
            spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and the
            spatial query type specified.
            </summary>
            <returns>
            The return decimalDegreesValue is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="queryType">This parameter specifies what kind of spatial query you wish to perform.</param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a queryType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesNearestTo(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource must use
                the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live,
                then the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided creates a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.
                When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetShape">This parameter is the shape you want to find InternalFeatures close to.</param>
            <param name="unitOfFeatureSource">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="numberOfItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesNearestTo(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Int32,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource must use
                the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live,
                then the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided creates a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.
                When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetShape">This parameter is the shape you want to find InternalFeatures close to.</param>
            <param name="unitOfFeatureSource">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="numberOfItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesNearestTo(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource must use
                the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live,
                then the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided creates a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.
                When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetFeature">This parameter is the feature you want to find InternalFeatures close to.</param>
            <param name="unitOfData">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="numberOfItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesNearestTo(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeographyUnit,System.Int32,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource must use
                the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live,
                then the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided creates a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.
                When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetFeature">This parameter is the target feature you want to find InternalFeatures close to.</param>
            <param name="unitOfData">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="numberOfItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesNearestTo(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String},System.Double,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource must use
                the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live,
                then the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided creates a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.
                When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetShape">This parameter is the shape you want to find InternalFeatures close to.</param>
            <param name="unitOfData">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="numberOfItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <param name="distanceLimits">
            Limit the maximize distance proximately to search closest records.
            </param>
            <param name="unitOfDistance">
            The unit of distanceLimits parameter.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesNearestTo(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String},System.Double,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource must use
                the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live,
                then the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided creates a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.
                When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetFeature">This parameter is feature you want to find InternalFeatures close to.</param>
            <param name="unitOfData">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="numberOfItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <param name="distanceLimits">
            Limit the maximize distance proximately to search closest records.
            </param>
            <param name="unitOfDistance">
            The unit of distanceLimits parameter.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesNearestToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape. It is important to note that the TargetShape and the FeatureSource must use
            the same unit, such as feet or meters. If they do not, then the results will not be
            predictable or correct. If there is a current transaction and it is marked as live,
            then the results will include any transaction Feature that applies.<br/>
            <br/>
            The implementation we provided creates a small bounding box around the TargetShape
            and then queries the features inside of it. If we reach the number of items to find,
            then we measure the returned InternalFeatures to find the nearest. If we do not find enough
            records, we scale up the bounding box and try again. As you can see, this is not the
            most efficient method. If your underlying data provider exposes a more efficient way,
            we recommend you override the Core version of this method and implement it.<br/>
            <br/>
            The default implementation of GetFeaturesNearestCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient.
            When you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
            any spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetShape">This parameter is the shape you want to find InternalFeatures close to.</param>
            <param name="unitOfData">
            This parameter is the unit of measurement that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="numberOfItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfItemsToFind that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns a collection of InternalFeatures that are within a certain
                distance of the TargetShape. It is important to note that the TargetShape and the
                FeatureSource must use the same unit, such as feet or meters. If they do not, then the
                results will not be predictable or correct. If there is a current transaction and
                it is marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
                The implementation we provided creates a bounding box around the TargetShape using
                the distance supplied and then queries the features inside of it. This may not be the
                most efficient method for this operation. If your underlying data provider exposes a
                more efficient way, we recommend you override the Core version of this method and
                implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesWithinDistanceOfCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When
                you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="targetShape">The shape you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the measurement unit for the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit,System.Double,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures that are within a certain
            distance of the TargetShape. It is important to note that the TargetShape and the
            FeatureSource must use the same unit, such as feet or meters. If they do not, then the
            results will not be predictable or correct. If there is a current transaction and
            it is marked as live, then the results will include any transaction Feature that
            applies.<br/>
            <br/>
            The implementation we provided creates a bounding box around the TargetShape using
            the distance supplied and then queries the features inside of it. This may not be the
            most efficient method for this operation. If your underlying data provider exposes a
            more efficient way, we recommend you override the Core version of this method and
            implement it.<br/>
            <br/>
            The default implementation of GetFeaturesWithinDistanceOfCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient. When
            you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
            any spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetShape">The shape you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the measurement unit for the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures that are within a certain
            distance of the TargetShape. It is important to note that the TargetShape and the
            FeatureSource must use the same unit, such as feet or meters. If they do not, then the
            results will not be predictable or correct. If there is a current transaction and
            it is marked as live, then the results will include any transaction Feature that
            applies.<br/>
            <br/>
            The implementation we provided creates a bounding box around the TargetShape using
            the distance supplied and then queries the features inside of it. This may not be the
            most efficient method for this operation. If your underlying data provider exposes a
            more efficient way, we recommend you override the Core version of this method and
            implement it.<br/>
            <br/>
            The default implementation of GetFeaturesWithinDistanceOfCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient. When
            you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
            any spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetFeature">The feature you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the measurement unit for the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit,System.Double,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures that are within a certain
            distance of the TargetShape. It is important to note that the TargetShape and the
            FeatureSource must use the same unit, such as feet or meters. If they do not, then the
            results will not be predictable or correct. If there is a current transaction and
            it is marked as live, then the results will include any transaction Feature that
            applies.<br/>
            <br/>
            The implementation we provided creates a bounding box around the TargetShape using
            the distance supplied and then queries the features inside of it. This may not be the
            most efficient method for this operation. If your underlying data provider exposes a
            more efficient way, we recommend you override the Core version of this method and
            implement it.<br/>
            <br/>
            The default implementation of GetFeaturesWithinDistanceOfCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient. When
            you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
            any spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetFeature">The feature you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the measurement unit for the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesWithinDistanceOfCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures that are within a certain
            distance of the TargetShape. It is important to note that the TargetShape and the
            FeatureSource must use the same unit, such as feet or meters. If they do not, then the
            results will not be predictable or correct. If there is a current transaction and
            it is marked as live, then the results will include any transaction Feature that
            applies.<br/>
            <br/>
            The implementation we provided creates a bounding box around the TargetShape using
            the distance supplied and then queries the features inside of it. This may not be the
            most efficient method for this operation. If your underlying data provider exposes a
            more efficient way, we recommend you override the Core version of this method and
            implement it.<br/>
            <br/>
            The default implementation of GetFeaturesWithinDistanceOfCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient. When
            you override GetFeaturesInsideBoundingBoxCore method, we recommend that you use
            any spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetShape">The shape you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the measurement unit for the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeatureById(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns a Feature by providing its Id in the FeatureSource.</summary>
            <returns>This method returns a Feature by providing its Id in the FeatureSource.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetFeaturesByIdsCore and only passes one Id in the
            collection. That method in turn calls the GetAllFeaturesCore. Because of this, if you
            want a more efficient version of this method, we highly suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <param name="id">
            This parameter is the Id which uniquely identifies it in the
            FeatureSource.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the id, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>                
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeatureById(System.String,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the id, we will throw an ArgumentNullException.</exception>        
            <summary>This method returns a Feature by providing its Id in the FeatureSource.</summary>
            <returns>This method returns a Feature by providing its Id in the FeatureSource.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetFeaturesByIdsCore and only passes one Id in the
            collection. That method in turn calls the GetAllFeaturesCore. Because of this, if you
            want a more efficient version of this method, then we highly suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <param name="id">
            This parameter is the Id which uniquely identifies it in the
            FeatureSource.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesByIds(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns a collection of InternalFeatures by providing a group of Ids.</summary>
            <returns>This method returns a collection of InternalFeatures by providing a group of Ids.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetFeaturesByIdsCore. That method in turn calls the
            GetAllFeaturesCore. Because of this, if you want a more efficient version of this method,
            then we highly suggest you override the GetFeaturesByIdsCore method and provide a fast
            way to find a group of InternalFeatures by their Id.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids which uniquely identifies the InternalFeatures
            in the FeatureSource.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the ids, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesByIds(System.Collections.Generic.IEnumerable{System.String},ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns a collection of InternalFeatures by providing a group of Ids.</summary>
            <returns>This method returns a collection of InternalFeatures by providing a group of Ids.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetFeaturesByIdsCore. That method in turn calls the
            GetAllFeaturesCore. Because of this, if you want a more efficient version of this method,
            then we highly suggest you override the GetFeaturesByIdsCore method and provide a fast
            way to find a group of InternalFeatures by their Id.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids which uniquely identifies the InternalFeatures
            in the FeatureSource.
            </param>
            <param name="returningColumnNamesType">This parameter allows you to select a type from the ReturningColumnsType that you wish to return with each Feature.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the ids, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetBoundingBoxById(System.String)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method returns a bounding box by providing an Id. The internal
            implementation calls the GetFeaturesByIdsCore and only passes one Id in the collection.
            That method in turn calls the GetAllFeaturesCore. Because of this, if you want a more
            efficient version of this method, then we highly suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <summary>This method returns a bounding box based on the InternalFeatures Id specified.</summary>
            <returns>This method returns a bounding box based on the InternalFeatures Id specified.</returns>
            <param name="id">
            This parameter represents the Id for the InternalFeatures whose bounding box you
            want.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the id, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetBoundingBoxByIds(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of bounding boxes based on the Feature Ids
            specified.
            </summary>
            <returns>
            This method returns a collection of bounding boxes based on the Feature Ids
            specified.
            </returns>
            <remarks>
            This method returns a bounding boxes by providing a goupd of Ids. The internal
            implementation calls the GetFeaturesByIdsCore. That method in turn calls the
            GetAllFeaturesCore. Because of this, if you want a more efficient version of this method,
            then we highly suggest you override the GetFeaturesByIdsCore method and provide a fast
            way to find a group of InternalFeatures by their Id.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids for the InternalFeatures whose bounding boxes
            you want.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the ids, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetBoundingBoxesByIds(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of bounding boxes based on the Feature Ids
            specified.
            </summary>
            <returns>
            This method returns a collection of bounding boxes based on the Feature Ids
            specified.
            </returns>
            <remarks>
            This method returns a bounding boxes by providing a goupd of Ids. The internal
            implementation calls the GetFeaturesByIdsCore. That method in turn calls the
            GetAllFeaturesCore. Because of this, if you want a more efficient version of this method,
            then we highly suggest you override the GetFeaturesByIdsCore method and provide a fast
            way to find a group of InternalFeatures by their Id.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids for the InternalFeatures whose bounding boxes
            you want.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the ids, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFirstFeaturesWellKnownType">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the well known type that represents the first feature from FeatureSource.</summary>
            <returns>This method returns the well known type that represents the first feature from FeatureSource.</returns>
            <remarks>
            This method is the concrete wrapper for the virtual method GetFirstFeaturesWellKnownTypeCore. It will
            return whatever is returned by the GetFirstFeaturesWellKnownTypeCore method, along with any additions
            or subtractions made if you are in a transaction and that transaction is configured to
            be live. To determine what the default implementation of the abstract GetCountCore
            method is, please see the documentation for it.<br/>
            	<br/>
            The default implementation of GetFirstFeaturesWellKnownTypeCore uses the GetAllFeaturesCore method to
            get WellKnownType of the first feature from all features. We strongly recommend that
            you provide your own implementation for this method that will be more efficient.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFirstFeaturesWellKnownTypeCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the well known type that represents the first feature from FeatureSource.</summary>
            <returns>This method returns the well known type that represents the first feature from FeatureSource.</returns>
            <remarks>
            	<para>This protected virtual method is called from the concrete public method
                GetFirstFeaturesWellKnownType. It does not take into account any transaction activity, as this is the
                responsibility of the concrete public method GetFirstFeaturesWellKnownType. This way, as a developer,
                if you choose to override this method you do not have to consider transactions at
                all.<br/>
            		<br/>
                The default implementation of GetCountCore uses the GetAllRFeaturesCore method to
                get WellKnownType of the first feature from all features. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient.<br/>
            		<br/>
                If you do not override this method, it will get the count by calling the
                GetAllFeaturesCore method and get WellKnownType of the first feature from all features. This is a very inefficient way
                to get the count in most data sources. It is highly recommended that you override
                this method and replace it with a highly optimized version. For example, in a
                ShapeFile the record count is in the main header of the file. Similarly, if you are
                using Oracle Spatial, you can execute a simple query to get the count of all of the
                records without returning them. In these ways you can greatly improve the
                performance of this method.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetFeaturesByIdsCore(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns a collection of InternalFeatures by providing a group of Ids.</summary>
            <returns>This method returns a collection of InternalFeatures by providing a group of Ids.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetAllFeaturesCore. Because of this, if you want a more
            efficient version of this method, then we highly suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids which uniquely identified the InternalFeatures
            in the FeatureSource.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the ids, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ConvertToExternalProjection(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.RectangleShape})">
            <summary>This method projects items based on the Projection of the FeatureSource.</summary>
            <overloads>
            This method projects a Feature based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method projects a Feature based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="rectangles">This parameter represents a group of RectangleShapes that you wish to project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ConvertToInternalProjection(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.RectangleShape})">
            <summary>
            This method de-projects items based on the Projection of the
            FeatureSource.
            </summary>
            <overloads>
            This method de-projects a BaseShape based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method de-projects a BaseShape based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="rectangles">This parameter represents a group of RectangleShapes that you wish to de-project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ConvertToExternalProjection(ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This method projects items based on the Projection of the FeatureSource.</summary>
            <overloads>
            This method projects a RectangleShape based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method projects a RectangleShape based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="rectangle">This parameter represents the rectangle you wish to project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ConvertToInternalProjection(ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>
            This method de-projects items based on the Projection of the
            FeatureSource.
            </summary>
            <overloads>
            This method de-projects a RectangleShape based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method de-projects a RectangleShape based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="rectangle">This parameter represents the rectangle you wish to de-project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ConvertToInternalProjection(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method de-projects items based on the Projection of the
            FeatureSource.
            </summary>
            <overloads>
            This method de-projects a BaseShape based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method de-projects a BaseShape based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="baseShape">This parameter represents the BaseShape you wish to de-project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ConvertToExternalProjection(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature})">
            <summary>This method projects items based on the Projection of the FeatureSource.</summary>
            <overloads>
            This method projects a Feature based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method projects a Feature based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="features">This parameter represents a group of Features that you wish to project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ConvertToInternalProjection(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature})">
            <summary>
            This method de-projects items based on the Projection of the
            FeatureSource.
            </summary>
            <overloads>
            This method de-projects a Feature based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method de-projects a Feature based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="features">This parameter represents the group of Features that you wish to de-project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ConvertToExternalProjection(ThinkGeo.MapSuite.Core.Feature)">
            <summary>This method projects items based on the Projection of the FeatureSource.</summary>
            <overloads>
            This method projects a Feature based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method projects a Feature based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="feature">This parameter represents the Feature you wish to project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.ConvertToInternalProjection(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method de-projects items based on the Projection of the
            FeatureSource.
            </summary>
            <overloads>
            This method de-projects a Feature based on the Projection of the
            FeatureSource.
            </overloads>
            <returns>
            This method de-projects a Feature based on the Projection of the
            FeatureSource.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that
                projection, as a general rule, happens inside the non-Core methods and we usually
                take care of it. However, as a developer, if you wish to add a new public method, then
                you will need to handle the projection yourself.<br/>
            		<br/>
                With these projection methods it is very easy to handle the projection and
                de-projection. Remember that when adding your own public methods you always
                de-project incoming shapes and alway project outgoing shapes. Also remember that the
                Core methods do not consider projection, and they assume the data being passed into
                them and out of them is the same unit as the underlying data.<br/>
            		<br/>
                Example of a New Public Method:<br/>
            		<br/>
                public Feature ProcessFeature(Feature incomingFeature)<br/>
                {<br/>
            		<br/>
                //Be sure that you use the FromProjection on the incomingFeatureParameter as the
                first thing you do in this method.</para>
            	<para>// Call a Core Method or do your own processing</para>
            	<para><br/>
                //Be sure that you call the ToProjection on the return result of the method before
                you pass it out.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="feature">This parameter represents the Feature you wish to de-project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetColumnNamesInsideFeatureSource(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method returns the field names that are in the FeatureSource from a list of
            provided field names.
            </summary>
            <returns>
            This method returns the field names that are in the FeatureSource from a list of
            provided field names.
            </returns>
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that, as a
                general rule, returning column data of a Feature or a set of InternalFeatures happens
                inside the non-Core methods and we usually take care of it. However, as a developer,
                if you wish to add a new public method, then you will need to handle the projection
                yourself.<br/>
            		<br/>
                Let's say, for example, that you want to add a new Find method called FindLargeFeatures.
                You pass in a group of columns to return. Most of the time, the requested columns will
                actually be in the FeatureSource, but sometimes they will not. The way we allow users to get
                data from outside of the Feature Source is by raising an event called 
                CustomColumnFetch. This way, we allow people to provide data that is outside of the
                FeatureSource. Since you will be implementing your own public method, you will want
                to support this as all of our other public methods do.<br/>
            		<br/>
                When you first enter the public method, you will want to separate out the fields
                that are in the FeatureSource from those that are not. You can call this method and
                the GetColumnNamesOutsideFeatureSource. If inside your public method you need to
                call any of our Core methods, then you need to make sure that you only pass in the
                list of column names that are in the FeatureSource. We assume that Core methods are
                simple and they do not handle this complexity.<br/>
            		<br/>
                With the list of non-FeatureSource column names, you simply loop through each column
                name for each record and call the OnCustomColumnFetch method while passing in the proper
                parameters. This will allow you give the user a chance to provide the values for
                the Feature's fields that were not in the FeatureSource. After that, you combine
                your results and pass them back out as the return.<br/>
            		<br/>
                public Collection&lt;Feature&gt; FindLargeFeatures(double AreaSize, IEnumerable
                &lt;string&gt; columnsToReturn)<br/>
                {</para>
            	<para>//Step 1: Separate the columns that are in the FeatureSource from those that
                are not.<br/>
            		<br/>
                // Step 2: Call any Core Methods and only pass in the columns that are in the
                FeatureSource</para>
            	<para>//Step3: For Each feature/column name combination, call the OnCustomFiedlFetch
                and allow your user to provide the custom data.<br/>
            		<br/>
                // Step4: Integrate the custom data with the result of the Core method plus any
                processing you did. Then return the consolidated result.<br/>
            		<br/>
                }</para>
            </remarks>
            <param name="returningColumnNames">
            This parameter is a list of column names, where not every field name may be in the
            FeatureSource.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetColumnNamesOutsideFeatureSource(System.Collections.Generic.IEnumerable{System.String})">
            <remarks>
            	<para>This is a protected method that is intended to help developers who want to
                implement or extend one of our FeatureSources. It is important to note that, as a
                general rule, returning column data of a Feature or a set of InternalFeatures happens
                inside the non-Core methods and we usually take care of it. However, as a developer,
                if you wish to add a new public method, then you will need to handle the projection
                yourself.<br/>
            		<br/>
                Let's say, for example, that you want to add a new Find method called FindLargeFeatures.
                You pass in a group of columns to return. Most of the time, the requested columns will
                actually be in the FeatureSource, but sometimes they will not. The way we allow users to get
                data from outside of the Feature Source is by raising an event called 
                CustomColumnFetch. This way, we allow people to provide data that is outside of the
                FeatureSource. Since you will be implementing your own public method, you will want
                to support this as all of our other public methods do.<br/>
            		<br/>
                When you first enter the public method, you will want to separate out the fields
                that are in the FeatureSource from those that are not. You can call this method and
                the GetColumnNamesOutsideFeatureSource. If inside your public method you need to
                call any of our Core methods, then you need to make sure that you only pass in the
                list of column names that are in the FeatureSource. We assume that Core methods are
                simple and they do not handle this complexity.<br/>
            		<br/>
                With the list of non-FeatureSource column names, you simply loop through each column
                name for each record and call the OnCustomColumnFetch method while passing in the proper
                parameters. This will allow you give the user a chance to provide the values for
                the Feature's fields that were not in the FeatureSource. After that, you combine
                your results and pass them back out as the return.<br/>
            		<br/>
                public Collection&lt;Feature&gt; FindLargeFeatures(double AreaSize, IEnumerable
                &lt;string&gt; columnsToReturn)<br/>
                {</para>
            	<para>//Step 1: Separate the columns that are in the FeatureSource from those that
                are not.<br/>
            		<br/>
                // Step 2: Call any Core Methods and only pass in the columns that are in the
                FeatureSource</para>
            	<para>//Step3: For Each feature/column name combination, call the OnCustomFiedlFetch
                and allow your user to provide the custom data.<br/>
            		<br/>
                // Step4: Integrate the custom data with the result of the Core method plus any
                processing you did. Then return the consolidated result.<br/>
            		<br/>
                }</para>
            </remarks>
            <summary>
            This method returns the field names that are not in the FeatureSource from a list
            of provided field names.
            </summary>
            <returns>
            This method returns the field names that are not in the FeatureSource from a list
            of provided field names.
            </returns>
            <param name="returningColumnNames">
            This parameter is a list of field names, where not every field name may be in the
            FeatureSource.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.SplitColumnNames(System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method will split the column names based on our column syntax.</summary>
            <returns>This returns a single list of column names.</returns>
            <remarks>
            This method is meant to be used by advanced users who are creating their own new methods
            on the FeatureSource. We have a system where you can concatenate column names you specify
            anywhere in the system to create a unique string. For example, let's say you have
            a dataset that has the following columns: Name, Grade and Class, and you want to
            create a custom label for it. Whenever you specify the column you wanted to use in the
            label, you could use a string like this: "[Name] received a [Grade] in [Class]" and
            this would be valid. Behind the scenes, this method parses the string and returns the
            column names separately. Then, after we have the data, there is another helper
            method called CombineFieldValues that will add them back together again.<br/>
            	<br/>
            All of this happens normally in the concrete methods of the FeatureSource and
            inheriting classes; however, if you want to extend the classes and create your own
            concrete methods, then we suggest you use this to be compliant with the concatenation
            system.
            </remarks>
            <param name="returningColumnNames">This parameter represents the column names you want to split.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.CombineFieldValues(System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method returns the re-combined collection of columns.</summary>
            <remarks>
            This method is meant to be used by advanced users who are creating their own new methods
            on the FeatureSource. We have a system where you can concatenate column names you specify
            anywhere in the system to create a unique string. For example, let's say you have
            a dataset that has the following columns: Name, Grade and Class, and you want to
            create a custom label for it. Whenever you specify the column you wanted to use in the
            label, you could use a string like this: "[Name] received a [Grade] in [Class]" and
            this would be valid. Behind the scenes, this method recombines the strings that were
            split in the SplitColumNames method.<br/>
            	<br/>
            All of this happens normally in the concrete methods of the FeatureSource and
            inheriting classes; however, if you want to extend the classes and create your own
            concrete methods, then we suggest you use this to be compliant with the concatenation
            system.
            </remarks>
            <returns>This method returns the re-combined collection of columns.</returns>
            <param name="columnValues">This parameter represents the split columns and their values.</param>
            <param name="originalColumnNames">This parameter is the original list of column names that may be combined.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSource.GetReturningColumnNames(ThinkGeo.MapSuite.Core.ReturningColumnsType)">
             <summary>
             Get returning columnNames according to the returningColumnType.
             </summary>
             <param name="returningColumnNamesType">The passed in returningColumnType.</param>
             <returns>The returning ColumnNames based on the given returningColumnNamesType.</returns>
            <remarks>The concreted FeatureSource can override this logic if needed.</remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.FeatureSource.CustomColumnFetch">
            <summary>
            This event is raised when fields are requested in a feature source method that do
            not exist in the feature source. It allows you to supplement the data from any outside
            source you have.
            </summary>
            <remarks>
            This event is raised when fields are requested in a feature source method that do
            not exist in the feature source. It allows you to supplement the data from any outside
            source you have.<br/>
            	<br/>
            It is used primarily when you have data relating to a particular feature or set of
            features that is not within source of the data. For example, you may have a shape file
            of the world whose .dbf component describes the area and population of each country.
            Additionally, in an outside SQL Server table, you may also have data about the countries,
            and it is this data that you wish to use for determining how you want to color
            each country.<br/>
            	<br/>
            To integrate this SQL data, you simply create a file name that does not exist in the
            .dbf file.  Whenever Map Suite is queried to return records that specifically require
            this field, the FeatureSource will raise this event and allow you the developer to
            supply the data. In this way, you can query the SQL table and store the
            data in some sort of collection, and then when the event is raised, simply supply that
            data.<br/>
            	<br/>
            As this is an event, it will raise for each feature and field combination requested.
            This means that the event can be raised quite often, and we suggest that you cache the
            data you wish to supply in memory. We recommend against sending out a new SQL query
            each time this event is raised. Image that you are supplementing two columns and your query
            returns 2,000 rows. This means that if you requested those fields, the event would be raised
            4,000 times.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.FeatureSource.CommittingTransaction">
            <summary>
            This event is raised after the CommitTransaction method is called, but before the
            CommitTransactionCore is called.  This allows you access to the TransactionBuffer before the
            transaction is committed. It also allows you to cancel the pending commit of the
            transaction.
            </summary>
            <remarks>
            This event is raised before the CommitTransactionCore is called and allows you
            access to the TransactionBuffer before the transaction is committed. It also allows you
            to cancel the pending transaction. The TransactionBuffer is the object that stores all
            of the pending transactions and is accessible through this event to allow you to either
            add, remove or modify transactions.<br/>
            	<br/>
            In the event that you cancel the CommitTransaction method, the transaction remains intact and
            you will still be editing. This makes it a nice place to possibly check for
            connectivity before the TransactionCore code is run, which is where the records are
            actually committed. Calling the RollBackTransaction method is the only way to
            permanently cancel a pending transaction without committing it.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.FeatureSource.CommittedTransaction">
            <summary>
            This event is raised after the CommitTransaction and the CommitTransactionCore
            are called and allows you access to the TransactionBuffer and the TransactionResults
            object before CommitTransaction method is returned.
            </summary>
            <remarks>
            	<para>This event is raised after the CommitTransactionCore is called and allows you
                access to the TransactionBuffer and the TransactionResults object before
                CommitTransaction method is returned.<br/>
            		<br/>
                With this event, you can analyse the results of the transaction and do any cleanup
                code necessary. In the event some of the records did not commit, you can handle
                those items here. The TransactionResults object is passed out of the
                CommitTransaction method so you could analyze it then; however, this is the only
                place where you have access to both the TransactionResults object and the
                TransactionBuffer object at the same time. These are useful together to try and
                determine what went wrong and possibly try and re-commit them.<br/>
            		<br/>
                At the time of this event you will technically be out of the current
                transaction.</para>
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.FeatureSource.OpeningFeatureSource">
            <summary>This event is called before the opening of the FeatureSource.</summary>
            <remarks>
            This event is called before the opening of the FeatureSource. Technically, this
            event is called after the calling of the Open method on the FeatureSource, but before
            the protected OpenCore method.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.FeatureSource.OpenedFeatureSource">
            <summary>This event is called after the opening of the FeatureSource.</summary>
            <remarks>
            This event is called after the opening of the FeatureSource. Technically, this
            event is called after the calling of the Open method on the FeatureSource and after the
            protected OpenCore method is called.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.FeatureSource.ClosingFeatureSource">
            <summary>This event is called before the closing of the FeatureSource.</summary>
            <remarks>
            This event is called before the closing of the FeatureSource. Technically, this
            event is called after the calling of the Close method on the FeatureSource, but before
            the protected CloseCore method.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.FeatureSource.ClosedFeatureSource">
            <summary>This event is called after the closing of the FeatureSource.</summary>
            <remarks>
            This event is called after the closing of the FeatureSource. Technically, this
            event is called after the calling of the Close method on the FeatureSource and after
            the protected CloseCore method.<br/>
            	<br/>
            It is typical that the FeatureSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a FeatureSource is in the Ajax or Post Back part of the page cycle, it will close the
            FeatureSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the FeaureSources open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSource.CanExecuteSqlQuery">
            <summary>
            This property specifies whether the FeatureSource can excute a SQL query or not.
            If it is false, then it will throw exception when these APIs are calleds: ExecuteScalar, ExecuteNonQuery, ExecuteQuery
            </summary>
            <remarks>The default implementation is false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSource.CanExecuteSqlQueryCore">
            <summary>
            This property specifies whether the FeatureSource can excute a SQL query or not.
            If it is false, then it will throw exception when these APIs are calleds: ExecuteScalar, ExecuteNonQuery, ExecuteQuery
            </summary>
            <remarks>The default implementation is false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSource.IsOpen">
            <summary>
            This property returns true if the FeatureSource is open and false if it is
            not.
            </summary>
            <decimalDegreesValue>
            This property returns true if the FeatureSource is open and false if it is
            not.
            </decimalDegreesValue>
            <remarks>
            Various methods on the FeatureSource require that it be in an open state. If one
            of those methods is called when the state is not open, then the method will throw an
            exception. To enter the open state, you must call the FeatureSource's Open method. The
            method will raise an exception if the current FeatureSource is already open.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSource.IsOpenCore">
            <summary>
            This property returns true if the FeatureSource is open and false if it is
            not.
            </summary>
            <decimalDegreesValue>
            This property returns true if the FeatureSource is open and false if it is
            not.
            </decimalDegreesValue>
            <remarks>
            Various methods on the FeatureSource require that it be in an open state. If one
            of those methods is called when the state is not open, then the method will throw an
            exception. To enter the open state, you must call the FeatureSource's Open method. The
            method will raise an exception if the current FeatureSource is already open.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSource.FeatureSourceColumns">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this property on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This property gets the columns of the feature source.
            </summary>
            <decimalDegreesValue>
            This property gets the columns of the feature source.
            </decimalDegreesValue>
            <remarks>
            None.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSource.IsInTransaction">
            <summary>
            This property returns true if the FeatureSource is in a transaction and false if
            it is not.
            </summary>
            <decimalDegreesValue>
            This property returns true if the FeatureSource is in a transaction and false if
            it is not.
            </decimalDegreesValue>
            <remarks>
            To enter a transaction, you must first call the BeginTransaction method of the
            FeatureSource. It is possible that some FeatureSources are read-only and do not allow
            edits. To end a transaction, you must either call CommitTransaction or
            RollbackTransaction.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSource.IsTransactionLive">
            <summary>
            This property returns true if the features currently modified in a transaction
            are expected to reflect their state when calling other methods on the FeatureSource,
            such as spatial queries.
            </summary>
            <decimalDegreesValue>
            This property returns true if the features currently modified in a transaction
            are expected to reflect their state when calling other methods on the
            FeatureSource.
            </decimalDegreesValue>
            <remarks>
            The live transaction concept means that all of the modifications you perform during
            a transaction are live from the standpoint of the querying methods on the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureSource that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureSource reflect the
            changes.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSource.IsEditable">
            <summary>This property returns whether the FeatureSource allows edits or is read-only.</summary>
            <decimalDegreesValue>
            This property returns whether the FeatureSource allows edits or is read-only. The
            property returns true if the FeatureSource allows edits and false if the FeatureSource
            is read-only.
            </decimalDegreesValue>
            <remarks>
            	<para>This property is useful to check if a specific FeatureSource accepts editing.
                If you call BeginTransaction and this property is false, then an exception will
                be raised.<br/>
            		<br/>
                For developers who are creating or extending a FeatureSource, it is expected that
                you override this virtual method if the new FeatureSource you are creating allows
                edits. By default, the decimalDegreesValue is false, meaning that if you want to allow edits you
                must override this method and return true.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSource.Projection">
            <summary>
            This property holds the projection object that is used within the FeatureSource
            to ensure that features inside of the FeatureSource are projected.
            </summary>
            <decimalDegreesValue>This property returns the projections selected by the developer.</decimalDegreesValue>
            <remarks>
            By default this property is null, meaning that the data being passed back from any
            methods on the FeatureSource will be in the coordinate system of the raw data. When you
            specify a projection object in the property, all incoming and outgoing method
            calls will subject the features to projection.<br/>
            	<br/>
            For example, if the spatial database you are using has all of its data stored in decimal
            degrees, but you want to see the data in UTM, you would create a projection object
            that goes from decimal degrees to UTM and set that as the projection. With this one
            property set, we will ensure that it will seem to you the developer that all of the data
            in the FeatureSource is in UTM. That means every spatial query will return UTM projected
            shapes. You can even pass in UTM shapes for the parameters. Internally, we will ensure
            that the shapes are converted to and from the projection without any intervention
            on the developer's part.<br/>
            	<br/>
            In fact, even when you override virtual or abstract core methods in the FeatureSource,
            you will not need to know about projections at all. Simply work with the data in its
            native coordinate system. We will handle all of the projection at the high level
            method.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSource.GeoCache">
            <summary>
            The cache system.
            </summary>
            <remarks>You must set IsActive to true for the Cache system. The default is not active.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSource.FeatureIdsToExclude">
            <summary>
            A collection of strings representing record id of features not to get in the Layer. 
            </summary>
            <remarks>
            This string collection is a handy place to specify what records not to get from the source. 
            Suppose you have a shape file of roads and you want to hide the roads within a particular 
            rectangle, simply execute GetFeaturesInsideBoundingBox() and add the id of the return 
            features to the collection and forget about them. Since you can set this by Layer it 
            makes is easy to determine what to and what not to. 
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSource.TransactionBuffer">
            <summary>
            The TransactionBuffer used in the Transaction System.
            </summary>
            <remarks>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureSource sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureSource. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureSource is responsible for integrating your changes into the underlying
            FeatureSource. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureSource API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureSource that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureSource reflect the
            changes.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.#ctor">
            <summary>This is the class constructor.</summary> 
            <overloads>
            This is the default constructor and requires you to set the properties after you
            create the class.
            </overloads>
            <remarks>None</remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.#ctor(System.String)">
            <summary>This is the class constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <overloads>
            This constructor allows you to pass in a path and file name to the shape
            file.
            </overloads>
            <param name="shapePathFilename">This parameter represents the path and file name to the .shp file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.#ctor(System.String,ThinkGeo.MapSuite.Core.ShapeFileReadWriteMode)">
            <summary>This is the class constructor.</summary>
            <overloads>
            This constructor allows you to pass in a path, file name and files access mode to
            the shape file.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="shapePathFilename">This parameter represents the path and file name to the .shp file.</param>
            <param name="readWriteMode">This parameters represents the mode that we will open the file in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify the shape file and the index file to
            use.
            </overloads>
            <returns>None</returns>
            <remarks>
            This constructor allows you to specify the shape file and the index file to use.
            In some cases you may want to build custom index files or want the index file to have a
            different name that the shape file.
            </remarks>
            <param name="shapePathFilename">This parameter is the shape file name you want to load.</param>
            <param name="indexPathFilename">This parameter is the index file you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.#ctor(System.String,System.String,ThinkGeo.MapSuite.Core.ShapeFileReadWriteMode)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify the shape file and the index file to use
            along with the read and write level.
            </overloads>
            <returns>None</returns>
            <remarks>
            This constructor allows you to specify the shape file and the index file to use.
            In some cases you may want to build custom index files or want the index file to have a
            different name that the shape file. It also allows you to specify is you want to open
            the files for read or read and write. You will need to open the file for read and write
            if you plan on doing any editing to the files.
            </remarks>
            <param name="shapePathFilename">This parameter is the shape file name you want to load.</param>
            <param name="indexPathFilename">This parameter is the index file you want to use.</param>
            <param name="readWriteMode">
            This parameter reflects if you want to open shape file and index for read or read
            write mode.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.#ctor(System.String,System.String,ThinkGeo.MapSuite.Core.ShapeFileReadWriteMode,System.Text.Encoding)">
             <summary>This is a constructor for the class.</summary>
             <overloads>
             This constructor allows you to specify the shape file and the index file to use
             along with the read and write level.
             </overloads>
             <returns>None</returns>
             <remarks>
             This constructor allows you to specify the shape file and the index file to use.
             In some cases you may want to build custom index files or want the index file to have a
             different name that the shape file. It also allows you to specify is you want to open
             the files for read or read and write. You will need to open the file for read and write
             if you plan on doing any editing to the files.
             </remarks>
             <param name="shapePathFilename">This parameter is the shape file name you want to load.</param>
             <param name="indexPathFilename">This parameter is the index file you want to use.</param>
             <param name="readWriteMode">
             This parameter reflects if you want to open shape file and index for read or read
             write mode.
             </param>
            <param name="encoding">The encoding to read and write the dbf file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.OnStreamLoading(ThinkGeo.MapSuite.Core.StreamLoadingEventArgs)">
            <summary>This method allows you to raise the StreamLoading event.</summary>
            <returns>None</returns>
            <remarks>
            This method allows you to raise the StreamLoading event. Normally events are not
            accessible to derived classes so we exposed a way to raise the event is necessary
            through this protected method.
            </remarks>
            <param name="e">
            This parameter represents the event arguments you want to raise the StreamLoading
            event with.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.OnBuildingIndex(ThinkGeo.MapSuite.Core.BuildingIndexShapeFileFeatureSourceEventArgs)">
            <summary>This method allows you to raise the BuildingIndex event.</summary>
            <returns>None</returns>
            <remarks>
            This method allows you to raise the BuildingIndex event. Normally events are not
            accessible to derived classes so we exposed a way to raise the event is necessary
            through this protected method.
            </remarks>
            <param name="e">
            This parameter represents the event arguments you want to raise the BuildingIndex
            event with.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.Rebuild(System.String)">
            <summary>
            This method rebuilds the SHP, SHX, DBF, IDX and IDS files for the given shape
            file.
            </summary>
            <returns>None</returns>
            <remarks>
            This method rebuilds the SHP, SHX, DBF, IDX and IDS files for the given shape
            file. When we do editing we have optimized the updates so that we do not need to
            rebuild the entire shape file. This leads to the shape file being out of order which
            may cause it not to open in other tools. One optimization is if you update a record
            instead of rebuilding a new shape file we mark the old record as null and add the
            edited record at the end of the shape file. This greatly increases the speed of
            committing shape file changes but will over time unorder the shape file. In addition we
            do a delete the DBF file will simply mark the record deleted and not compact the space.
            Rebuilding the shape file will correctly order the SPX and SHX along with compacting
            the DBF file and rebuild any index with the same any of the shape file if it
            exists.<br/>
            	<br/>
            Note that if you have build custom index files where the name of the index differs from
            that of the shape file you will need to rebuild those manually using the BuildIndex
            methods.
            </remarks>
            <param name="shapePathFilename">This parameter is the shape file you want to rebuild.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildIndexFile(System.String)">
            <summary>
            This method build a spatial index for the shape file which increases access
            speed.
            </summary>
            <overloads>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. It will not do a rebuild if there is an existing
            index.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. It will not do a rebuild if there is an existing
            index.
            </remarks>
            <param name="shapePathFilename">
            This parameter is the shape file name and path that you want to build an index
            for.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildIndexFile(System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>
            This method build a spatial index for the shape file which increases access
            speed.
            </summary>
            <overloads>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. You can also specify if you want to rebuild an existing
            index file.
            </overloads>
            <remarks>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="shapePathFilename">
            This parameter is the shape file name and path that you want to build an index
            for.
            </param>
            <param name="buildIndexMode">
            This parameter determines what will happen if there is an existing index
            file.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildIndexFile(System.String,System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>
            This method build a spatial index for the shape file which increases access
            speed.
            </summary>
            <overloads>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. You can also specify if you want to rebuild an existing
            index file.
            </overloads>
            <remarks>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="shapePathFilename">
            This parameter is the shape file name and path that you want to build an index
            for.
            </param>
            <param name="indexPathFilename">
            This parameter specifies the index file name.
            </param>
            <param name="buildIndexMode">
            This parameter determines what will happen if there is an existing index
            file.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildIndexFile(System.String,System.String,ThinkGeo.MapSuite.Core.Projection,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>
            This method build a spatial index for the shape file which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression,besides this, this overloads will pass in a target index projection.
            You can also specify if you want to rebuild an existing index file.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="shapePathFilename">This parameter is the shape file name and path that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="projection"> This parameter specifies the projection used to build index file.</param>
            <param name="buildIndexMode">This parameter determines what will happen if there is an existing index file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildIndexFile(System.String,System.String,System.String,System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>
            This method build a spatial index for the shape file which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression. You can also specify if you want to rebuild an existing
            index file.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="shapePathFilename">This parameter is the shape file name and path that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="columnName"> The columnName to be used to get the value to match the regex expression.</param>
            <param name="regularExpression">This parameter specifies the regex expression to filter out thoese records to build index with.</param>
            <param name="buildIndexMode">This parameter determines what will happen if there is an existing index file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildIndexFile(System.String,System.String,ThinkGeo.MapSuite.Core.Projection,System.String,System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>
            This method build a spatial index for the shape file which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression,besides this, this overloads will pass in a target index projection.
            You can also specify if you want to rebuild an existing index file.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="shapePathFilename">This parameter is the shape file name and path that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="projection"> This parameter specifies the projection used to build index file.</param>
            <param name="columnName"> The columnName to be used to get the value to match the regex expression.</param>
            <param name="regularExpression">This parameter specifies the regex expression to filter out thoese records to build index with.</param>
            <param name="buildIndexMode">This parameter determines what will happen if there is an existing index file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildIndexFile(System.String,System.String,ThinkGeo.MapSuite.Core.Projection,System.String,System.String,ThinkGeo.MapSuite.Core.BuildIndexMode,System.Text.Encoding)">
            <summary>
            This method build a spatial index for the shape file which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression,besides this, this overloads will pass in a target index projection.
            You can also specify if you want to rebuild an existing index file.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="shapePathFilename">This parameter is the shape file name and path that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="projection"> This parameter specifies the projection used to build index file.</param>
            <param name="columnName"> The columnName to be used to get the value to match the regex expression.</param>
            <param name="regularExpression">This parameter specifies the regular expression pattern to filter out thoese records to build index with.</param>
            <param name="buildIndexMode">This parameter determines what will happen if there is an existing index file.</param>
            <param name="encoding"> This parameter determines the Enconding system used in the dbf, and this will be used if the dbf is encoded in a different encoding with default.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},System.String)">
            <summary>
            This method build a spatial index for a passed group of featurs which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="features">This parameter specifies the target group of features that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},System.String,ThinkGeo.MapSuite.Core.Projection)">
            <summary>
            This method build a spatial index for a passed group of featurs using the specified projection which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="features">This parameter specifies the target group of features that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="projection"> This parameter specifies the projection used to build index file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>
            This method build a spatial index for a passed group of featurs which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="features">This parameter specifies the target group of features that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="buildIndexMode">This parameter determines what will happen if there is an existing index file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},System.String,ThinkGeo.MapSuite.Core.Projection,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>
            This method build a spatial index for a passed group of featurs which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="features">This parameter specifies the target group of features that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="buildIndexMode">This parameter determines what will happen if there is an existing index file.</param>
            <param name="projection"> This parameter specifies the projection used to build index file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.CreateShapeFile(ThinkGeo.MapSuite.Core.ShapeFileType,System.String,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.DbfColumn})">
            <summary>
            Static API to create a new shape file.
            </summary>
            <param name="shapeType">This parameter specifies the the shape file type for the target shape file.</param>
            <param name="pathFilename">This parameter specifies the shape file name for the target shape file.</param>
            <param name="databaseColumns">This parameter specifies the dbf column information for the target shape file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.CreateShapeFile(ThinkGeo.MapSuite.Core.ShapeFileType,System.String,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.DbfColumn},System.Text.Encoding)">
            <summary>
            Static API to create a new shape file.
            </summary>
            <param name="shapeType">This parameter specifies the the shape file type for the target shape file.</param>
            <param name="pathFilename">This parameter specifies the shape file name for the target shape file.</param>
            <param name="databaseColumns">This parameter specifies the dbf column information for the target shape file.</param>
            <param name="encoding">This parameter specifies the dbf encoding infromation for the target shape file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.CreateShapeFile(ThinkGeo.MapSuite.Core.ShapeFileType,System.String,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.DbfColumn},System.Text.Encoding,ThinkGeo.MapSuite.Core.OverwriteMode)">
            <summary>
            Static API to create a new shape file.
            </summary>
            <param name="shapeType">This parameter specifies the the shape file type for the target shape file.</param>
            <param name="pathFilename">This parameter specifies the shape file name for the target shape file.</param>
            <param name="databaseColumns">This parameter specifies the dbf column information for the target shape file.</param>
            <param name="encoding">This parameter specifies the dbf encoding infromation for the target shape file.</param>
            <param name="overwriteMode">This parameter specifies the override mode when the target shape file exists.</param>
            <remarks>Exception will be thown when the target shape file exist while the override mode is set to DoNotOverwrite.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetDbfColumns">
            <summary>
            Get the dbf columns out from the shape file featureSource.
            </summary>
            <returns>The dbfColumns in the shape file FeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.CloneShapeFileStructure(System.String,System.String)">
            <summary>
            Clone out the structure from the source shape file to the target shape file. After cloning the structure, 
            the targetShapeFile has the same type and same dbf columns with the source shape file but without any records in it.
            </summary>
            <param name="sourceShapePathFilename">The source shape file to be cloned.</param>
            <param name="targetShapePathFilename">The target shape file with same structure with the source one after the structure cloned.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.CloneShapeFileStructure(System.String,System.String,ThinkGeo.MapSuite.Core.OverwriteMode)">
            <summary>
            Clone out the structure from the source shape file to the target shape file. After cloning the structure, 
            the targetShapeFile has the same type and same dbf columns with the source shape file but without any records in it.
            </summary>
            <param name="sourceShapePathFilename">The source shape file to be cloned.</param>
            <param name="targetShapePathFilename">The target shape file with same structure with the source one after the structure cloned.</param>
            <param name="overwriteMode">This parameter specifies the override mode when the target shape file exists.</param>
            <remarks>Exception will be thown when the target shape file not extis while the override mode is set to DoNotOverwrite.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.CloneShapeFileStructure(System.String,System.String,ThinkGeo.MapSuite.Core.OverwriteMode,System.Text.Encoding)">
            <summary>
            Clone out the structure from the source shape file to the target shape file. After cloning the structure, 
            the targetShapeFile has the same type and same dbf columns with the source shape file but without any records in it.
            </summary>
            <param name="sourceShapePathFilename">The source shape file to be cloned.</param>
            <param name="targetShapePathFilename">The target shape file with same structure with the source one after the structure cloned.</param>
            <param name="overwriteMode">This parameter specifies the override mode when the target shape file exists.</param>
            <param name="encoding"> This parameter specifies the encoding information in the source shape file.</param>
            <remarks>Exception will be thown when the target shape file not extis while the override mode is set to DoNotOverwrite.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.Validate">
            <summary>
            This method checks all features in a shapefile is supported by Mapsuite or not.
            </summary>
            <returns>A dictionary which contains all the unsupported features. The key is the Indexs which 
            failed to pass the check, the value contains the reason for its failure.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.AddColumnBoolean(System.String)">
            <summary>
            This method adds a new Boolean column to the DBF file associated with the shape
            file.
            </summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="columnName">This parameter is the column you want to add.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.AddColumnDate(System.String)">
            <summary>
            This method adds a new Date column to the DBF file associated with the shape
            file.
            </summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="columnName">This parameter is the column you want to add.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.AddColumnDouble(System.String,System.Int32,System.Int32)">
            <summary>
            This method adds a new Double column to the DBF file associated with the shape
            file.
            </summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="columnName">This parameter is the column you want to add.</param>
            <param name="totalLength">
            This is the total length of the field including both the digits to the left and
            right of the decimal point.
            </param>
            <param name="precisionLength">
            This parameter specifies how many digits after the decimal point you need to
            support.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.AddColumnInteger(System.String,System.Int32)">
            <summary>
            This method adds a new Integer column to the DBF file associated with the shape
            file.
            </summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="columnName">This parameter is the column you want to add.</param>
            <param name="length">This parameter specifies the length of the integer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.AddColumnMemo(System.String)">
            <summary>
            This method adds a new Memo column to the DBF file associated with the shape
            file.
            </summary>
            <remarks>
            This method adds a new Memo column to the DBF file associated with the shape
            file.<br/>
            	<br/>
            Internally the DBF holds an integer column that is a pointer to the data in the memo
            file. The pointer is measured in 512 byte chunks. Our default decimalDegreesValue for the size of the
            pointer column is 10 which means you can have 9,999,999,999 pointers to the 512 byte
            blocks. The ramification of this is that if you have more than this many records and
            each record uses more then 512 bytes as part of its memo then there will not be enough
            space for storage. If you have special needs for this please use the other overload
            that allows you to specify the number of digits you can use for the pointer.
            </remarks>
            <returns>None</returns>
            <overloads>
            This constructor allows you to specify the column name and uses 10 for the
            memoPointerLength.
            </overloads>
            <param name="columnName">This parameter is the column you want to add.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.AddColumnMemo(System.String,System.Int32)">
            <remarks>
            	<para>This method adds a new Memo column to the DBF file associated with the shape
                file.<br/>
            		<br/>
                Internally the DBF holds an integer column that is a pointer to the data in the
                memo file. The pointer is measured in 512 byte chunks. Our default decimalDegreesValue for the
                size of the pointer column is 10 which means you can have 9,999,999,999 pointers to
                the 512 byte blocks. The ramification of this is that if you have more than this
                many records and each record uses more than 512 bytes as part of its memo then
                there will not be enough space for storage. Conversely if you know you have few
                records then you can decrease this number. A good rule of thumb is to multiply the
                number of records by the number of 512 byte chunks you expect each record to use
                and then get the resulting number of digits resulting for the multiplication.<br/>
            		<br/>
                Example<br/>
            		<br/>
                You have 1,000,000 records and expect to have 4K, 8 chunks of 512 bytes, of memo
                data for each record. This means you will use multiple 1,000,000 * 8 which is
                8,000,000 and then total the number of digits which in this case is 7. Assuming the
                numbers above a length of 7 will support your needs.</para>
            </remarks>
            <summary>
            This method adds a new Memo column to the DBF file associated with the shape
            file.
            </summary>
            <overloads>
            This constructor allows you to specify the column name and the
            memoPointerLength.
            </overloads>
            <returns>None</returns>
            <param name="columnName">This parameter is the column you want to add.</param>
            <param name="memoValueLength">
            This parameter is the number of digits you need to hold the pointers to the data
            in the memo file.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.AddColumnString(System.String,System.Int32)">
            <summary>
            This method adds a new String column to the DBF file associated with the shape
            file.
            </summary>
            <returns>None</returns>
            <remarks>
            This method adds a new String column to the DBF file associated with the shape
            file.
            </remarks>
            <param name="columnName">This parameter is the column you want to add.</param>
            <param name="length">This parameter is the number of characters that the string can hold.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetDataFromDbf(System.String,System.String)">
            <summary>
            This method gets data directly from the DBF file associated with the shape
            file.
            </summary>
            <overloads>This overload allows you to passing an Id and a column name.</overloads>
            <returns>
            This method gets data directly from the DBF file associated with the shape
            file.
            </returns>
            <remarks>
            This method gets data directly from the DBF file associated with the shape file.
            When you specify the Id and column name it will get the decimalDegreesValue from the DBF.
            </remarks>
            <param name="id">This parameter is the Id for the Feature you want to find.</param>
            <param name="columnName">This parameter is the column name you want to return.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetDataFromDbf(System.String)">
            <summary>
            This method gets data directly from the DBF file associated with the shape
            file.
            </summary>
            <overloads>
            This overload allows you to pass in an Id and return all of the DBF column for
            that Feature.
            </overloads>
            <returns>
            This method returns a dictionary holding all of the values from the DBF for the
            Id you specified.
            </returns>
            <remarks>
            This method returns a dictionary holding all of the values from the DBF for the
            Id you specified. In the dictionary the key is the column name and values are the
            values from the DBF.
            </remarks>
            <param name="id">This parameter is the Id of the Feature you want.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetDataFromDbf(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method gets data directly from the DBF file associated with the shape file.
            </summary>
            <overloads>
            This overload allows you to pass in an Id and specified returning columns for that Feature.
            </overloads>
            <returns>
            This method returns a dictionary holding all of the values from the DBF for the
            Id you specified.
            </returns>
            <remarks>
            This method returns a dictionary holding all of the values from the DBF for the
            Id you specified. In the dictionary the key is the column name and values are the
            values from the DBF.
            </remarks>
            <param name="id">This parameter is the Id of the Feature you want.</param>
            <param name="returningColumnNames"> This parameter is the returning columns specified for the returning data.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetDataFromDbf(System.String,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <summary>
            This method gets data directly from the DBF file associated with the shape file.
            </summary>
            <overloads>
            This overload allows you to pass in an Id and specified returning columns for that Feature.
            </overloads>
            <returns>
            This method returns a dictionary holding all of the values from the DBF for the
            Id you specified.
            </returns>
            <remarks>
            This method returns a dictionary holding all of the values from the DBF for the
            Id you specified. In the dictionary the key is the column name and values are the
            values from the DBF.
            </remarks>
            <param name="id">This parameter is the Id of the Feature you want.</param>
            <param name="returningColumnNamesType"> This parameter is the returningColumnType specified for the returning data.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetDataFromDbf(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method gets data directly from the DBF file associated with the shape
            file.
            </summary>
            <overloads>
            This overload allows you to pass in a group of Ids and return all of the DBF column for
            those Features.
            </overloads>
            <returns>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified.
            </returns>
            <remarks>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified. In the dictionary the key is the column name and values are the
            values from the DBF.
            </remarks>
            <param name="ids">This parameter is the Ids of the Features you want.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetDataFromDbf(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            This method gets data directly from the DBF file associated with the shape file.
            </summary>
            <overloads>
            This overload allows you to pass in a group of Ids and a returning columnName.
            </overloads>
            <returns>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified.
            </returns>
            <remarks>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified. In the dictionary the key is the column name and values are the
            values from the DBF.
            </remarks>
            <param name="ids">This parameter is the Ids of the Features you want.</param>
            <param name="columnName"> This parameter is the returning columnName of the Features you want.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetDataFromDbf(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method gets data directly from the DBF file associated with the shape file.
            </summary>
            <overloads>
            This overload allows you to pass in a group of Ids and a returning columnNames.
            </overloads>
            <returns>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified.
            </returns>
            <remarks>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified. In the dictionary the key is the column name and values are the
            values from the DBF.
            </remarks>
            <param name="ids">This parameter is the Ids of the Features you want.</param>
            <param name="columnNames"> This parameter is the returning columnNames of the Features you want.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetDataFromDbf(System.Collections.Generic.IEnumerable{System.String},ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <summary>
            This method gets data directly from the DBF file associated with the shape file.
            </summary>
            <overloads>
            This overload allows you to pass in a group of Ids and a returning columnNames.
            </overloads>
            <returns>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified.
            </returns>
            <remarks>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified. In the dictionary the key is the column name and values are the
            values from the DBF.
            </remarks>
            <param name="ids">This parameter is the Ids of the Features you want.</param>
            <param name="returningColumnNamesType"> This parameter is the returning column type of the Features you want.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.UpdateDbfData(System.String,System.String,System.String)">
            <summary>This method updates data in the DBF file associated with the shape file.</summary>
            <overloads>This overload allows you to pass in the Id, column name and the decimalDegreesValue.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="id">This parameter is the Id of the feature you want to update.</param>
            <param name="columnName">This parameter is the column name you want to update.</param>
            <param name="value">This parameter is the decimalDegreesValue you want to set.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.UpdateDbfData(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method updates data in the DBF file associated with the shape file.</summary>
            <overloads>This overload allows you to pass in the Id, columnNames and the values.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="id">This parameter is the Id of the feature you want to update.</param>
            <param name="columnNames">This parameter is the columnNames you want to update.</param>
            <param name="values">This parameter is the target values you want to set.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.ExecuteNonQueryCore(System.String)">
            <summary>
            This method executes a SQL query that does returns only a result of the number of
            record affected.
            </summary>
            <returns>This method returns the number of record affected by the SQL query.</returns>
            <remarks>
            This method executes a SQL query that does returns only a result of the number of
            record affected. Note that for the table name in the SQL query you need to use the
            shape file name without the SHP extension.
            </remarks>
            <param name="sqlStatement">This parameter is the SQL statement to execute.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.ExecuteScalarCore(System.String)">
            <summary>
            Executes the query and returns the first column of the first row in the result
            set returned by the query. All other columns and rows are ignored.
            </summary>
            <returns>The first column of the first row in the result set.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            reaquires less code than use the ExcuteQuery method and performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.ExecuteQueryCore(System.String)">
            <summary>This method returns a DataTable based on the SQL statement you provided.</summary>
            <returns>
            This method returns a DataTable based on the SQL statement you provided. Note
            that for the table name in the SQL query you need to use the shape file name without
            the SHP extension.
            </returns>
            <remarks>This method returns a DataTable based on the SQL statement you provided.</remarks>
            <param name="sqlStatement">This parameter is the SQL state you want to execute.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetShapeFileType">
            <summary>
            Get shape file type for the shape file featureSource.
            </summary>
            <returns>The shapeFileType for the ShapeFileFeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildRecordIdColumn(System.String,System.String,ThinkGeo.MapSuite.Core.BuildRecordIdMode)">
            <summary>
            Static API used to build RecordId, the id should start from 0 by default.
            </summary>
            <param name="shapeFilename">The target shape file name to build record id based on.</param>
            <param name="fieldname">The fild name for the record id.</param>
            <param name="rebuildNeeded">The build record id mode.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildRecordIdColumn(System.String,System.String,ThinkGeo.MapSuite.Core.BuildRecordIdMode,System.Int32)">
            <summary>
            Static API used to build RecordId from the specified starting id number.
            </summary>
            <param name="shapeFilename">The target shape file name to build record id based on.</param>
            <param name="fieldname">The fild name for the record id.</param>
            <param name="rebuildNeeded">The build record id mode.</param>
            <param name="startNumber">The starting id number of the record id.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildRecordIdColumn(System.String,System.String,ThinkGeo.MapSuite.Core.BuildRecordIdMode,System.Int32,System.Text.Encoding)">
            <summary>
            Static API used to build RecordId from the specified starting id number.
            </summary>
            <param name="shapeFilename">The target shape file name to build record id based on.</param>
            <param name="fieldname">The fild name for the record id.</param>
            <param name="rebuildNeeded">The build record id mode.</param>
            <param name="startNumber">The starting id number of the record id.</param>
            <param name="encoding"> This parameter specified the encoding information in dbf.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.SaveToProjection(System.String,System.String,ThinkGeo.MapSuite.Core.Projection,ThinkGeo.MapSuite.Core.OverwriteMode)">
            <summary>
            This API provide a easy way to project features in a shape file into another projection and save it to shape file.
            </summary>
            <param name="sourceShapeFile">This parameter specifies the source shape file to be projected.</param>
            <param name="targetShapeFile">This parameter specifies the target shape file to be saved for the projected features. </param>
            <param name="projection">This parameter is the projection to project the source shape file to target shape file. The source 
            Shape file should be in the FromProjection of the Projection prameter, and the targetShapeFile will be in the ToProjection 
            of the Projection.</param>
            <param name="overwriteMode">This parameter specifies the override mode when the target shape file exists.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has already been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concreate public method Open.
            The open method play an important role as it is responsible for initializing the
            FeatureSource. Most methods on the FeatureSource will throw an exception if the state
            of the FeatureSource is not opened. When the map draws each layer it will open the
            FeatureSource as one of its first steps, then after it is finished drawing with that
            layer it will close it. In this way we are sure to release all resources used by the
            FeatureSource.<br/>
            	<br/>
            When implementing this abstract method consider opening files for file based source,
            connecting to databases in the database based sources and so on. You will get a chance
            to close these in the Close method of the FeatureSource.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.CloseCore">
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concreate public method Close.
            The close method plays an important role in the life cycle of the FeatureSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            It is recommended that if you override this method that you take the following things
            into account. This method may be called multiple times so we suggest you write the so
            that that a call to a closed FeatureSource is ignored and does not generate an error.
            We also suggest that in the close you free all resources that have been opened.
            Remember that the object will not be destroyed but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.CommitTransactionCore(ThinkGeo.MapSuite.Core.TransactionBuffer)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction it will throw an InvalidOperationException.</exception>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
            <remarks>
            	<para>This method will commit the existing transaction to its underlying source of
                data. It will pass back the results of how the commit went to include any error
                received. If you are implementing your own FeatureSource then this is one of the
                crucial methods you must create. It should be fairly straight forward that you will
                loop through the transaction buffer and add, edit or delete the InternalFeatures in your
                underlying data source. Remember to build and pass back the TransactionResult class
                so that users of your FeatureSource can respond to failures you may encounter
                committing the InternalFeatures. We will handle the end of the transaction and also the
                cleanup of the transaction buffer. Your task will be to commit the records and
                produce a TransactionResult return.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited
                implementation of any specific source such as Oracle Spatial or Shape files. In
                this way it functions the same way for every FeatureSource. You start by calling
                the BeginTransaction. This allocates a collection of in memory change buffers that
                are used to store changes until you commit the transaction. So for example when you
                call the Add, Delete or Update method the changes to the feature are stored in
                memory only. If for any reason you choose to abandon the transaction you can call
                RollbackTransaction at any time and the in memory buffer will be deleted and the
                changes will be lost. When you are ready to commit the transaction you call the
                CommitTransaction and the collections of changes are then passed to the
                CommitTransactionCore method and the implementer of the specific FeatureSource is
                responsible for integrating your changes into the underlying FeatureSource. By
                default the IsLiveTransaction property is set to false which means that until you
                commit the changes the FeatureSource API will not reflect any changes that are in
                the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true then things function
                slightly differently. The live transaction concept means that all of the
                modification you perform during a transaction are live from the standpoint of the
                querying methods on the object.</para>
            	<para>To setup an example imagine that you have a FeatureSource that has 10 records
                in it. Next you begin a transaction and then call GetAllFeatures, the result would
                be 10 records. After that you call a delete on one of the records and call the
                GetAllFeatures again, this time you only get nine records. You receive nine records
                even though the transaction has not yet been committed. In the same sense you could
                have added a new record or modified an existing one and those changes are
                considered live though not committed.</para>
            	<para>In the case where you modify records such as expanding the size of a polygon
                those changes as well are reflected. So for example you expand a polygon by
                doubling its size and then do a spatial query that would not normally return the
                smaller record but would return the larger records, in this case the larger record
                is returned. You can set this property to be false as well in which case all of the
                spatial related methods would ignore anything that is currently in the transaction
                buffer waiting to be committed. In this case only after committing the transaction
                would the FeatureSource reflect the changes.</para>
            </remarks>
            <returns>
            The return decimalDegreesValue of this method is a TransactionResult class which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful and any error that were encountered during the
            committing of the transaction.
            </returns>
            <param name="transactions">
            This parameter encapsulates all of the adds, edits and deleted that make up the
            transaction. You will use this data to write the changes to your underlying data
            source.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetAllFeaturesCore(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. You will not need
            to consider anything about pending transactions as this will be handled in the non Core
            version of the method.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We wanted as the framework developers to provide you
            the user with as much default virtual implementation as possible. To do this we needed
            a way to get access to all of the features. For example, we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all the records then we can brute force
            the answer. In this way if you inherited form this class and only implemented this one
            method we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource
            it comes with a price. The price is that it is very inefficient. In the case we just
            discussed about finding all of the InternalFeatures in a bounding box we would not want to look
            at every record to fulfil this method. Instead we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be fast. For
            example in Oracle Spatial there is a specific SQL statement to do this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. It will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.
            </remarks>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetColumnsCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the columns available for the FeatureSource.</summary>
            <remarks>
            As this is the abstract core version of the Columns method it is intended to
            be overridden in inherited version of the class. When overriding you will be
            responsible for getting a list of all of the columns supported by the FeatureSource. In
            this way the FeatureSource will know what columns are available and will remove any
            extra columns when making calls to other core methods. For example if you have a
            FeatureSource that has three columns of information and the user calls a method and
            requests four columns of information, something they can do with custom fields, we will
            first compare what they are asking for to the results of the GetColumnsCore. In this
            way we can strip out custom columns before calling other Core methods which are only
            responsible for returning data in the FeatureSource. For more information on custom
            fields you can see the documentation on the OnCustomFieldsFetch.
            </remarks>
            <returns>This method returns the columns available for the FeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetBoundingBox. It does not take into account any transaction activity as this is
                the responsibility of the concreate public method GetBoundingBox. In this way as a
                developer if you choose to override this method you do not have to consider
                transaction at all.<br/>
            		<br/>
                The default implementation of GetBoundingBoxCore uses the GetAllRecordsCore method
                to calculate the bounding box of the FeatureSource. We strongly recommend that you
                provide your own implementation for this method that will be more efficient<br/>
            		<br/>
                If you do not override this method the means it gets the BoundingBox is by calling
                the GetAllFeatureCore method and deriving it from each feature. This is a very
                inefficient way to get the BoundingBox in most data sources. It is highly
                recommended that you override this method and replace it with a highly optimized
                version. For example in a ShapeFile the BoundingBox is in the main header of the
                file. Similarly if you are using Oracle Spatial you can execute a simple query to
                get the BoundingBox of all of the record without returning them. In these ways you
                can greatly improve the performance of this method.</para>
            </remarks>
            <summary>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </summary>
            <returns>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetFeaturesOutsideBoundingBoxCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </returns>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </summary>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box. If you are in a transaction and that transaction is live then
            it will also take that into consideration.<br/>
            	<br/>
            	<br/>
            The default implementation of GetFeaturesOutsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are outside of the bounding box.
            We strongly recommend that you provide your own implementation for this method that
            will be more efficient
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetFeaturesInsideBoundingBoxCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box.
            </summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions as this is handled by the concreate version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesInsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding box. We
            strongly recommend that you provide your own implementation for this method that will
            be more efficient. It is especially important for this method as many other default
            virtual methods use this for their calculations. We highly recommend when you override
            this method that you use any spatial indexes you have at your disposal to make this
            method as fast as possible.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetFeaturesForDrawingCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions as this is handled by the concreate version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesForDrawingCore uses the
            GetFeaturesInsodeBoundingBoxCore with some optimizations based on the screen width and
            height. For example we can determine is a feature is going to draw in only one to four
            pixels and in that case we may not draw the entire feature but just a subset.
            </remarks>
            <summary>This method returns the InternalFeatures that will be used for drawing.</summary>
            <returns>This method returns the InternalFeatures that will be used for drawing.</returns>
            <param name="boundingBox">This parameter is the bounding box of the InternalFeatures you want to draw.</param>
            <param name="screenWidth">
            This parameter is the width in screen pixels of the canvas you will draw
            on.
            </param>
            <param name="screenHeight">
            This parameter is the height in screen pixels of the canvas you will draw
            on.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetFeaturesByIdsCore(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns a collection of InternalFeatures by providing a group of Ids.</summary>
            <returns>This method returns a collection of InternalFeatures by providing a group of Ids.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetAllFeaturesCore. Because of this if you want an
            efficient version of this method then we high suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids which uniquely identified the InternalFeatures
            in the FeatureSource.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.GetCountCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <summary>
            This method returns the count of the number of records in this
            FeatureSource.
            </summary>
            <returns>
            This method returns the count of the number of records in this
            FeatureSource.
            </returns>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetCount. It does not take into account any transaction activity as this is the
                responsibility of the concreate public method GetCount. In this way as a developer
                if you choose to override this method you do not have to consider transaction at
                all.<br/>
            		<br/>
                The default implementation of GetCountCore uses the GetAllRecordsCore method to
                calculate how many records there are in the FeatureSource. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient<br/>
            		<br/>
                If you do not override this method the means it gets the count is by calling the
                GetAllFeatureCore method and counting each feature. This is a very inefficient way
                to get the count in most data sources. It is highly recommended that you override
                this method and replace it with a highly optimized version. For example in a
                ShapeFile the record count is in the main header of the file. Similarly if you are
                using Oracle Spatial you can execute a simple query to get the count of all of the
                record without returning them. In these ways you can greatly improve the
                performance of this method.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.ShapePathFileName">
            <summary>This property returns the path and file of the shape file you want to use.</summary>
            <decimalDegreesValue>This property returns the path and file of the shape file you want to use.</decimalDegreesValue>
            <remarks>
            When you specify the path and file name it should be in the correct format as
            such however the file does not need to exists on the file system. This is to allow us
            to accept streams supplied by the developer at runtime. If you choose to provide a file
            that exists then we will attempt to use it. If we cannot find it then we will raise the
            SteamLoading event and allow you to supply the stream. For example you can pass in
            "C:\NotARealPath\File1.shp" which does not exists on the file system. When we raise the
            event for you to supply a stream we will pass to you the path and file name for you to
            differentiate the files.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Setting an invalid FilePathName structure will thrown an ArgumentException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.IndexPathFileName">
            <summary>
            This property gets and sets the path and file of the index you want to
            use.
            </summary>
            <remarks>
            When you specify the path and file name it should be in the correct format as
            such however the file does not need to exists on the file system. This is to allow us
            to accept streams supplied by the developer at runtime. If you choose to provide a file
            that exists then we will attempt to use it. If we cannot find it then we will raise the
            SteamLoading event and allow you to supply the stream. For example you can pass in
            "C:\NotARealPath\File1.idx" which does not exists on the file system. When we raise the
            event for you to supply a stream we will pass to you the path and file name for you to
            differentiate the files.
            </remarks>
            <decimalDegreesValue>This property returns the path and file of the index you want to use.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.IsEditable">
            <summary>This property returns if the FeatureSource allows edits or is read only.</summary>
            <decimalDegreesValue>
            This property returns if the FeatureSource allows edits or is read only. The
            property returns true if the FeatureSource allows edits and false if the FeatureSource
            is read only.
            </decimalDegreesValue>
            <remarks>
            	<para>This property is useful to check if a specific FeatureSource accepts editing.
                If you call the BeginTransaction and this property is false then an exception will
                be raised.<br/>
            		<br/>
                For developers who are creating or extending a FeatureSource it is expected that
                you override this virtual method if the new FeatureSource you are creating allows
                edits. By default the decimalDegreesValue if false meaning that if you want to allow edits you
                must override this method and return true.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.CanExecuteSqlQueryCore">
            <summary>
            This property specifies the FeatureSource can excute sql query or not.
            If it is false, then it will throw exception when called the APIs:ExecuteScalar,ExecuteNonQuery,ExecuteQuery
            This orverides will make it true.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.UsingSpatialIndex">
            <summary>
            This property gets the shape file feature source with index or not.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.RequireIndex">
            <summary>
            This property gets and sets the requirement of index when reading data. The default value is true.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.Encoding">
            <summary>
            This property get and set the encoding information for the dbf.
            </summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.StreamLoading">
            <summary>
            This event allows you to pass in your own stream to represent the
            files.
            </summary>
            <remarks>
            If you choose you can pass in your own stream to represent the file. The
            stream can come from a variety of places such as isolated storage, a compressed file,
            and encrypted stream. When the Image is finished with the stream it will dispose
            of it so be sure to keep this in mind when passing the stream in. If you do not pass in
            a alternate stream the class will attempt to load the file from the file system
            using the PathFileName property.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.ShapeFileFeatureSource.BuildingIndex">
            <summary>
            This event will be fired each time a record was built the rtree index.
            
            You can choose to use this event to build the build index progess bar.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.OpeningRasterSourceEventArgs">
            <summary>
            This class represents the parameters passed in the OpeningRasterSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.OpeningRasterSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RECORD_HEADER">
            <summary>
            Record header; must be 8 bytes.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECORD_HEADER.Init">
            <summary>
            Init RECORD_HEADER
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECORD_HEADER.GetSize">
            <summary>
            Return the size of this struct.
            </summary>
            <returns> Size of RECORD_HEADER</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECORD_HEADER.Read(System.IO.BinaryReader)">
            <summary>
            Read contents from BinaryReader object.
            </summary>
            <param name="r"> BinaryReader object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECORD_HEADER.Write(System.IO.BinaryWriter)">
            <summary>
            Write contents into BinaryWriter object.
            </summary>
            <param name="w"> BinaryWriter object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECORD_HEADER.ToString">
            <summary>
            For debugging.
            </summary>
            <returns> dumped string</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Entry">
            <summary>
            Entry contains rectangle information and manipulation used by ChildPage.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RectangleRecord">
            <summary>
            RectangleRecrod contains rectangle information and manipulation.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Record">
            <summary>
            Record is an abstract class.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Record.CreateByType(ThinkGeo.MapSuite.Core.Gist_Ext_Id)">
            <summary>
            Create a record object according to file type.
            </summary>
            <param name="extId">	file ext Id		</param>
            <returns>				record object	</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Record.GetChild">
            <summary>
            Get child page number.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Record.GetRectangle">
            <summary>
            Return the rectangle of this record.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Record.GetPoint">
            <summary>
            Get point object for override.
            </summary>
            <returns>null</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Record.RecordHeader">
            <summary>
            Property of RecordHeader
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Record.Data">
            <summary>
            Property of Data
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleRecord.#ctor">
            <summary>
            DefauLb constructor
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleRecord.#ctor(ThinkGeo.MapSuite.Core.RECORD_HEADER,ThinkGeo.MapSuite.Core.RECTANGLE_D,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="rh">RECORD_HEADER object</param>
            <param name="rt">	RECTANGLE_D object</param>
            <param name="idx">	Index of record</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleRecord.Read(System.IO.BinaryReader,System.Boolean)">
            <summary>
            Read one RectangleRecord.
            </summary>
            <param name="r">BinaryReader object</param>
            <param name="isFloat">Indicitates that it is float.</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleRecord.Write(System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write one RectangleRecord.
            </summary>
            <param name="w">BinaryWriter object</param>
            <param name="isFloat"> Marks the point value as float.</param>
            <returns>
            	true for success 
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleRecord.IsContained(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Test if the record is contained by the specified rectangle.
            </summary>
            <param name="rect">RECTANGLE_D object</param>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleRecord.IsContains(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Test if the record contains the specified rectangle.
            </summary>
            <param name="rect">RECTANGLE_D object</param>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleRecord.IsOverlaps(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Test if the record overlaps with the specified rectangle.
            </summary>
            <param name="rect">RECTANGLE_D object</param>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleRecord.GetSize(System.Boolean)">
            <summary>
            Get size of RectangleRecord.
            </summary>
            <returns>Size of RectangleRecord</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleRecord.GetArea">
            <summary>
            Get area of the rectangle.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleRecord.ToString">
            <summary>
            For debugging.
            </summary>
            <returns>contents of record</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Entry.#ctor">
            <summary>
            DefauLb constructor.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Entry.ToString">
            <summary>
            For debug.
            </summary>
            <returns>Entry's content</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Entry.GetSize(System.Boolean)">
            <summary>
            Get Entry's size.
            </summary>
            <returns> Entry's size</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Entry.#ctor(ThinkGeo.MapSuite.Core.RECORD_HEADER,ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Constructor
            </summary>
            <param name="rh"> RECORD_HEADER object	</param>
            <param name="rt"> RECTANGLE_D object	</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Entry.Read(System.IO.BinaryReader,System.Boolean)">
            <summary>
            Read one Entry.
            </summary>
            <param name="r">BinaryReader object</param>
            <param name="isFloat"></param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Entry.Write(System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write one Entry.
            </summary>
            <param name="w">BinaryWriter object</param>
            <param name="isFloat"></param>
            <returns>
            	true for success 
            	false for failure
            </returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoCollection`1">
            <summary>
            This class is a collection with some methods specialized for dealing with Layers
            and other spatial classes.
            </summary>
            <remarks>
            We have added some helpful methods like MoveUp, MoveDown, etc. These help when you
            are manipulating Layers.
            </remarks>
            <typeparam name="T">This parameter is the item you want a collection of.</typeparam>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.GetKeys">
            <summary>This method returns a collection of the keys in the collection.</summary>
            <returns>This method returns a collection of the keys in the collection.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.Add(System.String,`0)">
            <summary>
            This method adds an item to the collection by specifying the item and a
            key.
            </summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="key">This parameter is the key to find the item.</param>
            <param name="item">This parameter is the item you want added to the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.Add(`0)">
            <summary>
            This method adds an item to the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method adds an item to the collection, and the item's key will be a random GUID.</remarks>
            <param name="item">This parameter is the item you want added to the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an element into the System.Collections.ObjectModel.Collection&lt;T&gt; at
            the specified index.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="System.ArgumentOutOfRangeException">index is less than zero.  -or- index is greater than System.Collections.ObjectModel.Collection&lt;T&gt;.Count.</exception>
            <param name="index">The zero-based index at which item should be inserted.</param>
            <param name="item">The object to insert. The value can be null for reference types.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.Insert(System.Int32,System.String,`0)">
            <summary>
            Inserts an element into the System.Collections.ObjectModel.Collection&lt;T&gt; at
            the specified index and key.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="System.ArgumentOutOfRangeException">index is less than zero.  -or- index is greater than System.Collections.ObjectModel.Collection&lt;T&gt;.Count.</exception>
            <param name="index">The zero-based index at which item should be inserted.</param>
            <param name="key">The key to find the item.</param>
            <param name="item">The object to insert. The value can be null for reference types.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.Remove(System.String)">
            <summary>This method removes an item from the collection based on the specified key.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="key">This parameter is the key of the item you want to remove.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.RemoveItem(System.Int32)">
            <summary>This method removes an item from the collection based on the specified index.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="index">This parameter is the index of the item you want to remove.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveUp(System.Int32)">
            <summary>This method moves an item up in the collection.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="index">This parameter is the index of the item in the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveUp(System.String)">
            <summary>This method moves an item up in the collection.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="key">This parameter is the key of the item in the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveUp(`0)">
            <summary>This method moves an item up in the collection.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="item">This parameter is the item you want to move up in the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveDown(System.Int32)">
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This method moves an item down in the collection.</summary>
            <param name="index">This parameter is the index of the item in the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveDown(System.String)">
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This method moves an item down in the collection.</summary>
            <param name="key">This parameter is the key of the item in the dictionary.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveDown(`0)">
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This method moves an item down in the collection.</summary>
            <param name="item">This parameter is the item you want to move down in the dictionary.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveToTop(System.Int32)">
            <summary>
            This method moves the item at the specified index to the top of the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item at the specified index to the top of the collection.</remarks>
            <param name="index">This parameter is the index of the item you want move to the top of the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveToTop(System.String)">
            <summary>
            This method moves the item with the specified key to the top of the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item with the specified key to the top of the collection.</remarks>
            <param name="key">This parameter is the key of the item you want move to the top of the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveToTop(`0)">
            <summary>
            This method moves the item specified to the top of the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item specified to the top of the collection.</remarks>
            <param name="item">This parameter is the item you want move to the top of the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveToBottom(System.Int32)">
            <summary>
            This method moves the item at the specified index to the bottom of the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item at the specified index to the bottom of the collection.</remarks>
            <param name="index">This parameter is the index of the item you want move to the bottom of the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveToBottom(System.String)">
            <summary>
            This method moves the item with the specified key to the bottom of the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item with the specified key to the bottom of the collection.</remarks>
            <param name="key">This parameter is the key of the item you want move to the bottom of the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveToBottom(`0)">
            <summary>
            This method moves the item specified key to the bottom of the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item specified key to the bottom of the collection.</remarks>
            <param name="item">This parameter is the item you want move to the bottom of the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveTo(System.Int32,System.Int32)">
            <summary>
            This method moves the item at fromIndex to the location of toIndex in the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item at fromIndex to the location of toIndex in the collection.</remarks>
            <param name="fromIndex">This parameter is the index of the item you want move from in the collection.</param>
            <param name="toIndex">This parameter is the target index that you want to move the item to in the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveTo(System.String,System.Int32)">
            <summary>
            This method moves the item with the key you specified to the location of toIndex in the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item with the key you specified to the location of toIndex in the collection.</remarks>
            <param name="key">This parameter is the key of item you want to move in the collection.</param>
            <param name="toIndex">This parameter is the target index that you want to move the item to in the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.MoveTo(`0,System.Int32)">
            <summary>
            This method moves the item you specified to the location of toIndex in the collection.
            </summary>
            <returns>None</returns>
            <remarks>This method moves the item you specified to the location of toIndex in the collection.</remarks>
            <param name="item">This parameter is the item you want to move in the collection.</param>
            <param name="toIndex">This parameter is the target index that you want to move the item to in the collection.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.Contains(System.String)">
            <summary>This method returns whether an item is in the collection based on the specified key.</summary>
            <returns>This method returns whether an item is in the collection based on the specified key.</returns>
            <remarks>None</remarks>
            <param name="key">This parameter is the key of the item you are searching for.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.ClearItems">
            <summary>This method clears the items from the collection.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCollection`1.SetItem(System.Int32,`0)">
            <summary>This method allows you to set an item based on the index.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="index">This parameter is the index of the item you want to set.</param>
            <param name="item">This parameter is the item you want to set.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoCollection`1.Item(System.String)">
            <summary>This property gets and sets the object.</summary>
            <decimalDegreesValue>This property gets the object.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.AdornmentLayersDrawingEventArgs">
            <summary>
            This is the event arguments class for the AdornmentLayersDrawing event. It is raised
            before any of the AdornmentLayers are drawn.
            </summary>
            <remarks>
            This is the event arguments class for the AdornmentLayersDrawing event. It is raised
            before any of the AdornmentLayers are drawn. This event allows you to manipulate the
            AdornmentLayers, or draw something with the canvas before any of the AdornmentLayers
            are drawn.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AdornmentLayersDrawingEventArgs.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AdornmentLayersDrawingEventArgs.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.AdornmentLayer})">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="adornmentLayers">This parameter is the AdornmentLayers that will be drawn.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AdornmentLayersDrawingEventArgs.AdornmentLayers">
            <summary>This property gets and sets the AdornmentLayers that will be drawn.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.TileImageFormat">
            <summary>Specifies the format of the map image.</summary>
            <remarks>
            If the image is overlaid atop other images, use the PNG image format (which can use
            a transparent background). If you have a low bandwidth network, use the JPEG image format.
            You can reduce the quality of the JPEG image and make its size smaller.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.TileImageFormat.Png">
            <summary>
            Specifies the image is in the W3C Portable Network Graphics (PNG) image
            format.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.TileImageFormat.Jpeg">
            <summary>
            Specifies the image is in the Joint Photographic Experts Group (JPEG) image
            format.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ProjType">
            <summary>
            definition of class ProjType
            the class is the base class of the projection,when the projection object has been create
            then it will realize the abstract function
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseInfoExtra.#ctor(System.String,System.String)">
            <summary>
            Extract the information that it will be used in the system from Resource file
            </summary>
            <param name="baseInfoFile">one of the units in Resource file</param>
            <param name="xmlPath">Xml Path in baseInfoFile unit</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseInfoExtra.FileExists">
            <summary>
            Check base info file is exist or not
            </summary>
            <returns>file exist</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseInfoExtra._InitXmlDoc">
            <summary>
            Initialize XmlDocument,and initialize Xml document node
            </summary>
            <returns>flag for initialize success or not </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ThinkGeo.MapSuite.Core.BaseInfoExtra.ExtraXmlNode(System.String,System.String)" -->
        <member name="P:ThinkGeo.MapSuite.Core.BaseInfoExtra.NodeList">
            <summary>
            return XmlNodeList
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.EditTools">
            <summary>
            This class is a wrapper class for the FeatureLayer that isolates only the editing
            methods to make them easily accessible to the programmer.
            </summary>
            <remarks>
            This class is a wrapper class for the FeatureLayer that isolates only the editing
            methods to make them easily accessible to the programmer.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>This is the default constructor. It is protected and not meant to be used.</overloads>
            <returns>None</returns>
            <remarks>This is the default constructor. It is protected and not meant to be used.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.#ctor(ThinkGeo.MapSuite.Core.FeatureSource)">
            <summary>This is a constructor for the class.</summary>
            <overloads>This constructor allows you to pass in the FeatureSource.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="featureSource">
            This parameter is the FeatureSource that the edit operations will pass through
            to.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.BeginTransaction">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is in a transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which has not been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not editable, it will throw an InvalidOperationException.</exception>
            <summary>This method starts a new transaction if the FeatureLayer allows editing.</summary>
            <returns>None</returns>
            <remarks>
            This method is used to start a transaction, assuming that the FeatureLayer allows
            editing. There are some additional prerequisites to beginning a transaction, such as ensuring
            that a transaction is not already in progress. You must also be sure that the FeatureSource has
            been opened.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureLayer sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureLayer. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureLayer is responsible for integrating your changes into the underlying
            FeatureLayer. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureLayer API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureLayer that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureLayer reflect the
            changes.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.Add(ThinkGeo.MapSuite.Core.BaseShape)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <summary>This method adds a new Feature to an existing transaction.</summary>
            <remarks>
            This method adds a new Feature to an existing transaction. You will need to
            ensure that you have started a transaction by calling BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureLayer sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureLayer. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureLayer is responsible for integrating your changes into the underlying
            FeatureLayer. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureLayer API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureLayer that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureLayer reflect the
            changes.
            </remarks>
            <returns>
            This string is the ID that will uniquely identify this Feature while it is in a
            transaction.
            </returns>
            <overloads>This overload allows you to pass in a shape.</overloads>
            <param name="shape">
            This parameter represents the new shape that will be added to the
            transaction.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.Add(ThinkGeo.MapSuite.Core.Feature)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <summary>This method adds a new Feature to an existing transaction.</summary>
            <remarks>
            This method adds a new Feature to an existing transaction. You will need to
            ensure that you have started a transaction by calling BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureLayer sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureLayer. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureLayer is responsible for integrating your changes into the underlying
            FeatureLayer. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureLayer API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureLayer that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureLayer reflect the
            changes.
            </remarks>
            <returns>
            This string is the ID that will uniquely identify this Feature while it is in a
            transaction.
            </returns>
            <overloads>This overload allows you pass in a Feature.</overloads>
            <param name="feature">
            This parameter represents the new Feature that will be added to the
            transaction.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.Add(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.Dictionary{System.String,System.String})">
            <overloads>This overload allows you pass in a Feature.</overloads>
            <summary>This overload allows you pass in a Feature.</summary>
            <remarks>
            This method adds a new Feature to an existing transaction. You will need to
            ensure that you have started a transaction by calling BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureLayer sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureLayer. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureLayer is responsible for integrating your changes into the underlying
            FeatureLayer. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureLayer API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureLayer that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureLayer reflect the
            changes.
            </remarks>
            <param name="shape">
            This parameter represents the new BaseShape that will be added to the
            transaction.
            </param>
            <param name="columnValues">
            This parameter represents DBF information of the new BaseShape.
            </param>
            <returns>
            This string is the ID that will uniquely identify this BaseShape while it is in a
            transaction.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the shape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the columnValues, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.ScaleUp(System.String,System.Double)">
            <summary>
            This method increases the size of the feature by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is a helpful function that allows you to easily edit InternalFeatures directly
            in the FeatureSource without having to retrieve them, convert them to a shape,
            manipulate them and put them back into the FeatureSource.<br/>
            	<br/>
            This method is useful when you would like to increase the size of the Feature. Note
            that a larger percentage will scale the shape up faster as you apply the operation
            multiple times. There is also a ScaleDown method that will shrink the shape as
            well.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <param name="featureId">This parameter is the Id of the Feature you want to scale.</param>
            <param name="percentage">This is the percentage by which to increase the Feature's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.ScaleDown(System.String,System.Double)">
            <summary>
            This method decreases the size of the feature by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is a helpful function that allows you to easily edit InternalFeatures directly
            in the FeatureSource without having to retrieve them, convert them to a shape,
            manipulate them and put them back into the FeatureSource.<br/>
            	<br/>
            This method is useful when you would like to decrease the size of the Feature. Note
            that a larger percentage will scale the shape down faster as you apply the operation
            multiple times. There is also a ScaleUp method that will expand the shape as
            well.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <param name="featureId">This parameter is the Id of the Feature you want to scale.</param>
            <param name="percentage">This is the percentage by which to decrease the Feature's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.TranslateByDegree(System.String,System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the Feature from one location to another based on a distance
            and a direction in degrees.
            </summary>
            <overloads>
            In this overload, the distance unit is based on a DistanceUnit you specify in the
            distanceUnit parameter, regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method is a helpful function that allows you to easily edit InternalFeatures
                directly in the FeatureSource without having to retrieve them, convert them to a
                shape, manipulate them and put them back into the FeatureSource.<br/>
            		<br/>
                This method moves the Feature from one location to another based on angleInDegrees
                and the distance parameter. With this overload, it is important to note that the
                distance units are based on the specified distanceUnit parameter. For example, if your
                Feature is in decimal degrees and you call this method with a specified distanceUnit of
                miles, you're going to move this shape a number of miles based on the distance and
                angleInDegrees. In this way, you could easily move a shape in decimal degrees five
                miles to the north.</para>
            	<para>If you pass a distance of 0, the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees that is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance that is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <returns>None</returns>
            <param name="featureId">This parameter is the Feature you want to move.</param>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the DistanceUnit specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with zero being up.</para>
            </param>
            <param name="shapeUnit">
            This is the GeographicUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use as the measure of the translate.
            For example, if you select miles as your distanceUnit, then the distance will be
            calculated in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.TranslateByOffset(System.String,System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the Feature from one location to another based on a X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on a DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method is a helpful function that allows you to easily edit InternalFeatures
                directly in the FeatureSource without having to retrieve them, convert them to a
                shape, manipulate them and put them back into the FeatureSource.<br/>
            		<br/>
                This method moves the Feature from one location to another based on an X and Y
                offset distance. With this overload, it is important to note that the
                distance units are based on the specified distanceUnit parameter. For example, if your
                Feature is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this Feature one unit of the distanceUnit in the
                horizontal direction and one unit of the distanceUnit in the vertical direction.
                In this way, you could easily move a Feature in decimal degrees five miles on the X
                axis and 3 miles on the Y axis.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape that has no points, it will throw an InvalidOperationException.</exception>
            <returns>None</returns>
            <param name="featureId">This parameter is the Feature you want to move.</param>
            <param name="xOffset">
            This is the number of horizontal units of movement in the DistanceUnit specified in
            the distanceUnit parameter.
            </param>
            <param name="yOffset">
            This is the number of horizontal units of movement in the DistanceUnit specified in
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="offsetUnit">
            	<para>This is the DistanceUnit you would like to use as the measure of the
                translate. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.Rotate(System.String,ThinkGeo.MapSuite.Core.PointShape,System.Single)">
            <summary>
            This method rotates the Feature any number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method is a helpful function that allows you to easily edit InternalFeatures
                directly in the FeatureSource without having to retrieve them, convert them to a
                shape, manipulate them and put them back into the FeatureSource.<br/>
            		<br/>
                This method rotates the Feature based on a pivot point by a number of degrees. By
                placing the pivot point in the center of the Feature, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the Feature, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape that is not valid, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.NotImplementedException" caption="NotImplementedException">In the event you attempt to call this method and the CanRotate property returns false, it will throw a NotImplementedException.</exception>
            <returns>None</returns>
            <param name="featureId">This parameter is the Feature you want to rotate.</param>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation, from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.Union(System.String,ThinkGeo.MapSuite.Core.AreaBaseShape)">
            <summary>
            This method returns the union of the Feature and the target shapes, which are defined as the
            set of all points in the Feature or the target shape.
            </summary>
            <returns>None</returns>
            <remarks>
            This method is a helpful function that allows you to easily edit InternalFeatures directly
            in the FeatureSource without having to retrieve them, convert them to a shape,
            manipulate them and put them back into the FeatureSource.<br/>
            	<br/>
            	<br/>
            This is useful for adding area shapes together to form a larger area shape.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape that has no points, it will throw an InvalidOperationException.</exception>
            <overloads>This overload allows you pass in an AreaBaseShape.</overloads>
            <param name="featureId">This parameter is the Feature you want to add the new area to.</param>
            <param name="targetShape">The shape you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.Union(System.String,ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns the union of the Feature and the target features, which are defined as the
            set of all points in the Feature or the target shape.
            </summary>
            <returns>None</returns>
            <remarks>
            This method is a helpful function that allows you to easily edit InternalFeatures directly
            in the FeatureSource without having to retrieve them, convert them to a shape,
            manipulate them and put them back into the FeatureSource.<br/>
            	<br/>
            	<br/>
            This is useful for adding area shapes together to form a larger area shape.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null featureId, we will throw an ArgumentNullException.</exception>
            <overloads>This overload allows you pass in a Feature.</overloads>
            <param name="featureId">This parameter is the Feature you want to add the new area to.</param>
            <param name="targetAreaFeature">The feature you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.GetDifference(System.String,ThinkGeo.MapSuite.Core.AreaBaseShape)">
            <summary>
            This method returns the difference between two shapes, which are defined as the set of all
            points that lie in the Feature but not in the targetShape.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape that has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method is a helpful function that allows you to easily edit InternalFeatures directly
            in the FeatureSource without having to retrieve them, convert them to a shape,
            manipulate them and put them back into the FeatureSource.
            </remarks>
            <returns>None</returns>
            <param name="featureId">This is the Feature you want to remove area from.</param>
            <param name="targetShape">The shape you are trying to find the difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.GetDifference(System.String,ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns the difference between two features, which are defined as the set of all
            points which lie in the Feature but not in the targetFeature.
            </summary>
            <returns>None</returns>
            <param name="featureId">This is the Feature you want to remove area from.</param>
            <param name="targetAreaFeature">The feature you are trying to find the difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.Delete(System.String)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method deletes a Feature from an existing transaction. You will need to
            ensure that you have started a transaction by calling BeginTransaction.<br/>
            	<br/>
            The Transaction System<br/>
            	<br/>
            The transaction system of a FeatureLayer sits on top of the inherited implementation
            of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
            the same way for every FeatureLayer. You start by calling BeginTransaction. This
            allocates a collection of in-memory change buffers that are used to store changes until
            you commit the transaction. So, for example, when you call the Add, Delete or Update
            method, the changes to the feature are stored in memory only. If for any reason you
            choose to abandon the transaction, you can call RollbackTransaction at any time and the
            in-memory buffer will be deleted and the changes will be lost. When you are ready to
            commit the transaction, you call CommitTransaction and the collections of changes
            are then passed to the CommitTransactionCore method and the implementer of the specific
            FeatureLayer is responsible for integrating your changes into the underlying
            FeatureLayer. By default the IsLiveTransaction property is set to false, which means
            that until you commit the changes, the FeatureLayer API will not reflect any changes
            that are in the temporary editing buffer.<br/>
            	<br/>
            In the case where the IsLiveTransaction is set to true, then things function slightly
            differently. The live transaction concept means that all of the modifications you
            perform during a transaction are live from the standpoint of the querying methods on
            the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureLayer that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureLayer reflect the
            changes.
            </remarks>
            <summary>This method deletes a Feature from an existing transaction.</summary>
            <returns>None</returns>
            <param name="id">
            This string is the Id of the feature in the FeatureLayer that you wish to
            delete.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.Update(ThinkGeo.MapSuite.Core.BaseShape)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method updates a Feature in an existing transaction. You will need to
                ensure that you have started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureLayer sits on top of the inherited implementation
                of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
                the same way for every FeatureLayer. You start by calling BeginTransaction. This
                allocates a collection of in-memory change buffers that are used to store changes until
                you commit the transaction. So, for example, when you call the Add, Delete or Update
                method, the changes to the feature are stored in memory only. If for any reason you
                choose to abandon the transaction, you can call RollbackTransaction at any time and the
                in-memory buffer will be deleted and the changes will be lost. When you are ready to
                commit the transaction, you call CommitTransaction and the collections of changes
                are then passed to the CommitTransactionCore method and the implementer of the specific
                FeatureLayer is responsible for integrating your changes into the underlying
                FeatureLayer. By default the IsLiveTransaction property is set to false, which means
                that until you commit the changes, the FeatureLayer API will not reflect any changes
                that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
                differently. The live transaction concept means that all of the modifications you
                perform during a transaction are live from the standpoint of the querying methods on
                the object.</para>
            	<para>As an example, imagine that you have a FeatureLayer that has 10 records in it.
                Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
                records. After that, you call a delete on one of the records and call the GetAllFeatures
                again.  This time you only get nine records, even though the
                transaction has not yet been committed. In the same sense, you could have added a new
                record or modified an existing one and those changes would be considered live, though not
                committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
                changes are reflected as well. For example, you expand a polygon by doubling its size
                and then do a spatial query that would not normally return the smaller record, but instead
                would return the larger records.  In this case, the larger records are returned. You can set this
                property to be false, as well; in which case, all of the spatially related methods would
                ignore anything that is currently in the transaction buffer waiting to be committed. In
                such a case, only after committing the transaction would the FeatureLayer reflect the
                changes.</para>
            </remarks>
            <summary>This method updates a Feature in an existing transaction.</summary>
            <overloads>
            This overload allows you to pass in a shape and the Id to the Feature it will
            update.
            </overloads>
            <param name="shape">The shape you wish to update in the transaction. The Id of the Shape should be the feature Id which you wish to update.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.Update(ThinkGeo.MapSuite.Core.Feature)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method updates a Feature in an existing transaction. You will need to
                ensure that you have started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureLayer sits on top of the inherited implementation
                of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
                the same way for every FeatureLayer. You start by calling BeginTransaction. This
                allocates a collection of in-memory change buffers that are used to store changes until
                you commit the transaction. So, for example, when you call the Add, Delete or Update
                method, the changes to the feature are stored in memory only. If for any reason you
                choose to abandon the transaction, you can call RollbackTransaction at any time and the
                in-memory buffer will be deleted and the changes will be lost. When you are ready to
                commit the transaction, you call CommitTransaction and the collections of changes
                are then passed to the CommitTransactionCore method and the implementer of the specific
                FeatureLayer is responsible for integrating your changes into the underlying
                FeatureLayer. By default the IsLiveTransaction property is set to false, which means
                that until you commit the changes, the FeatureLayer API will not reflect any changes
                that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
                differently. The live transaction concept means that all of the modifications you
                perform during a transaction are live from the standpoint of the querying methods on
                the object.</para>
            	<para>As an example, imagine that you have a FeatureLayer that has 10 records in it.
                Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
                records. After that, you call a delete on one of the records and call the GetAllFeatures
                again.  This time you only get nine records, even though the
                transaction has not yet been committed. In the same sense, you could have added a new
                record or modified an existing one and those changes would be considered live, though not
                committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
                changes are reflected as well. For example, you expand a polygon by doubling its size
                and then do a spatial query that would not normally return the smaller record, but instead
                would return the larger records.  In this case, the larger records are returned. You can set this
                property to be false, as well; in which case, all of the spatially related methods would
                ignore anything that is currently in the transaction buffer waiting to be committed. In
                such a case, only after committing the transaction would the FeatureLayer reflect the
                changes.</para>
            </remarks>
            <summary>This method updates a Feature in an existing transaction.</summary>
            <overloads>This overload allows you pass in a Feature.</overloads>
            <param name="feature">The Feature you wish to update in the transaction.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.Update(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.Dictionary{System.String,System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method updates a Feature in an existing transaction. You will need to
                ensure that you have started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureLayer sits on top of the inherited implementation
                of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
                the same way for every FeatureLayer. You start by calling BeginTransaction. This
                allocates a collection of in-memory change buffers that are used to store changes until
                you commit the transaction. So, for example, when you call the Add, Delete or Update
                method, the changes to the feature are stored in memory only. If for any reason you
                choose to abandon the transaction, you can call RollbackTransaction at any time and the
                in-memory buffer will be deleted and the changes will be lost. When you are ready to
                commit the transaction, you call CommitTransaction and the collections of changes
                are then passed to the CommitTransactionCore method and the implementer of the specific
                FeatureLayer is responsible for integrating your changes into the underlying
                FeatureLayer. By default the IsLiveTransaction property is set to false, which means
                that until you commit the changes, the FeatureLayer API will not reflect any changes
                that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
                differently. The live transaction concept means that all of the modifications you
                perform during a transaction are live from the standpoint of the querying methods on
                the object.</para>
            	<para>As an example, imagine that you have a FeatureLayer that has 10 records in it.
                Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
                records. After that, you call a delete on one of the records and call the GetAllFeatures
                again.  This time you only get nine records, even though the
                transaction has not yet been committed. In the same sense, you could have added a new
                record or modified an existing one and those changes would be considered live, though not
                committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
                changes are reflected as well. For example, you expand a polygon by doubling its size
                and then do a spatial query that would not normally return the smaller record, but instead
                would return the larger records.  In this case, the larger records are returned. You can set this
                property to be false, as well; in which case, all of the spatially related methods would
                ignore anything that is currently in the transaction buffer waiting to be committed. In
                such a case, only after committing the transaction would the FeatureLayer reflect the
                changes.</para>
            </remarks>
            <summary>This method updates a Feature in an existing transaction.</summary>
            <overloads>
            This overload allows you to pass in a shape and the columnValues to the Feature it will
            update.
            </overloads>
            <param name="shape">The shape you wish to update in the transaction. The Id of the Shape should be the feature id which you wish to update.</param>
            <param name="columnValues">The column values you wish to update in the transaction.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.RollbackTransaction">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <returns>None</returns>
            <remarks>
            	<para>This method will cancel an existing transaction. It will free up the internal
                memory cache of any InternalFeatures added, updated or deleted. You will need to ensure
                that you have started a transaction by calling BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureLayer sits on top of the inherited implementation
                of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
                the same way for every FeatureLayer. You start by calling BeginTransaction. This
                allocates a collection of in-memory change buffers that are used to store changes until
                you commit the transaction. So, for example, when you call the Add, Delete or Update
                method, the changes to the feature are stored in memory only. If for any reason you
                choose to abandon the transaction, you can call RollbackTransaction at any time and the
                in-memory buffer will be deleted and the changes will be lost. When you are ready to
                commit the transaction, you call CommitTransaction and the collections of changes
                are then passed to the CommitTransactionCore method and the implementer of the specific
                FeatureLayer is responsible for integrating your changes into the underlying
                FeatureLayer. By default the IsLiveTransaction property is set to false, which means
                that until you commit the changes, the FeatureLayer API will not reflect any changes
                that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
                differently. The live transaction concept means that all of the modifications you
                perform during a transaction are live from the standpoint of the querying methods on
                the object.</para>
            	<para>As an example, imagine that you have a FeatureLayer that has 10 records in it.
                Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
                records. After that, you call a delete on one of the records and call the GetAllFeatures
                again.  This time you only get nine records, even though the
                transaction has not yet been committed. In the same sense, you could have added a new
                record or modified an existing one and those changes would be considered live, though not
                committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
                changes are reflected as well. For example, you expand a polygon by doubling its size
                and then do a spatial query that would not normally return the smaller record, but instead
                would return the larger records.  In this case, the larger records are returned. You can set this
                property to be false, as well; in which case, all of the spatially related methods would
                ignore anything that is currently in the transaction buffer waiting to be committed. In
                such a case, only after committing the transaction would the FeatureLayer reflect the
                changes.</para>
            </remarks>
            <summary>
            This method will cancel an existing transaction. It will free up the internal
            memory cache of any InternalFeatures added, updated or deleted.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EditTools.CommitTransaction">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which is not in a transaction, it will throw an InvalidOperationException.</exception>
            <returns>
            The returned decimalDegreesValue of this method is a TransactionResult class, which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful and any errors that were encountered during the
            committing of the transaction.
            </returns>
            <remarks>
            	<para>This method will commit the existing transaction to its underlying source of data. It
                will then pass back the results of the commit, including any error(s) received. Finally,
                it will free up the internal memory cache of any InternalFeatures added, updated
                or deleted. You will need to ensure that you have started a transaction by calling
                BeginTransaction.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureLayer sits on top of the inherited implementation
                of any specific source, such as Oracle Spatial or Shape files. In this way, it functions
                the same way for every FeatureLayer. You start by calling BeginTransaction. This
                allocates a collection of in-memory change buffers that are used to store changes until
                you commit the transaction. So, for example, when you call the Add, Delete or Update
                method, the changes to the feature are stored in memory only. If for any reason you
                choose to abandon the transaction, you can call RollbackTransaction at any time and the
                in-memory buffer will be deleted and the changes will be lost. When you are ready to
                commit the transaction, you call CommitTransaction and the collections of changes
                are then passed to the CommitTransactionCore method and the implementer of the specific
                FeatureLayer is responsible for integrating your changes into the underlying
                FeatureLayer. By default the IsLiveTransaction property is set to false, which means
                that until you commit the changes, the FeatureLayer API will not reflect any changes
                that are in the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true, then things function slightly
                differently. The live transaction concept means that all of the modifications you
                perform during a transaction are live from the standpoint of the querying methods on
                the object.</para>
            	<para>As an example, imagine that you have a FeatureLayer that has 10 records in it.
                Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
                records. After that, you call a delete on one of the records and call the GetAllFeatures
                again.  This time you only get nine records, even though the
                transaction has not yet been committed. In the same sense, you could have added a new
                record or modified an existing one and those changes would be considered live, though not
                committed.</para>
            	<para>In the case where you modify records -- such as expanding the size of a polygon -- those
                changes are reflected as well. For example, you expand a polygon by doubling its size
                and then do a spatial query that would not normally return the smaller record, but instead
                would return the larger records.  In this case, the larger records are returned. You can set this
                property to be false, as well; in which case, all of the spatially related methods would
                ignore anything that is currently in the transaction buffer waiting to be committed. In
                such a case, only after committing the transaction would the FeatureLayer reflect the
                changes.</para>
            </remarks>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.EditTools.IsInTransaction">
            <summary>
            This property returns true if the FeatureLayer is in a transaction and false if it
            is not.
            </summary>
            <decimalDegreesValue>
            This property returns true if the FeatureLayer is in a transaction and false if it
            is not.
            </decimalDegreesValue>
            <remarks>
            To enter a transaction, you must first call the BeginTransaction method of the
            FeatureLayer. It is possible that some FeatureLayers are read only and do not allow
            edits. To end a transaction, you must either call CommitTransaction or
            RollbackTransaction.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.EditTools.IsTransactionLive">
            <summary>
            This property returns true if the features currently modified in a transaction
            are expected to reflect their state when calling other methods on the FeatureLayer,
            such as spatial queries.
            </summary>
            <decimalDegreesValue>
            This property returns true if the features currently modified in a transaction
            are expected to reflect their state when calling other methods on the
            FeatureLayer.
            </decimalDegreesValue>
            <remarks>
            The live transaction concept means that all of the modifications you perform during
            a transaction are live from the standpoint of the querying methods on the object.<br/>
            	<br/>
            As an example, imagine that you have a FeatureLayer that has 10 records in it.
            Next, you begin a transaction and then call GetAllFeatures.  The result would be 10
            records. After that, you call a delete on one of the records and call the GetAllFeatures
            again.  This time you only get nine records, even though the
            transaction has not yet been committed. In the same sense, you could have added a new
            record or modified an existing one and those changes would be considered live, though not
            committed.<br/>
            	<br/>
            In the case where you modify records -- such as expanding the size of a polygon -- those
            changes are reflected as well. For example, you expand a polygon by doubling its size
            and then do a spatial query that would not normally return the smaller record, but instead
            would return the larger records.  In this case, the larger records are returned. You can set this
            property to be false, as well; in which case, all of the spatially related methods would
            ignore anything that is currently in the transaction buffer waiting to be committed. In
            such a case, only after committing the transaction would the FeatureLayer reflect the
            changes.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.EditTools.IsEditable">
            <summary>This property returns whether the FeatureLayer allows edits or is read only.</summary>
            <decimalDegreesValue>
            This property returns whether the FeatureLayer allows edits or is read only. The
            property returns true if the FeatureLayer allows edits and false if the FeatureLayer is
            read only.
            </decimalDegreesValue>
            <remarks>
            	<para>This property is useful to check if a specific FeatureLayer accepts editing.
                If you call BeginTransaction and this property is false, then an exception will
                be raised.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.EditTools.TransactionBuffer">
            <summary>This property allows you get and set the transaction buffer.</summary>
            <value>None</value>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RingShape">
            <summary>This class represents a closed ring of points.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.AreaBaseShape">
            <summary>
            This abstract class is the root of all area-based shapes, such as RectangleShape
            and PolygonShape.
            </summary>
            <remarks>
            	<para>This class is used as the base class for area shapes such as:<br/>
            		<br/>
                PolygonShape<br/>
                RectangleShape<br/>
                MultiPolygonShape<br/>
                EllipseShape<br/>
                RingShape<br/>
            		<br/>
                It can be inherited from to create your own specialized area geometry. If you
                choose to do this, your new class must conform to one of the well-known text standard
                shapes in order for the base implementations to work properly.</para>
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.BaseShape">
            <summary>
            The abstract class from which area shapes, line shapes, and point shapes inherit
            from.
            </summary>
            <remarks>
            The BaseShape is the lowest level shape in the shapes hierarchy. Directly
            inherited from BaseShape are AreaShape, LineShape and PointShape. The methods and
            properties on BaseShape are the lowest common denominator for all the various kinds of
            shapes. It marked abstract and is designed only to be inherited from.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.#ctor">
            <summary>This is the default constructor for BaseShape.</summary>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.CreateShapeFromWellKnownData(System.String)">
            <summary>This method creates a BaseShape from a string of well-known text.</summary>
            <remarks>
            	<para>This method creates a BaseShape from a string of well-known text. Well-known
                text allows you to describe geometries as a string of text. Well-known text is
                useful when you want to save a geometry in a format such as a text file, or when you simply
                want to cut and paste the text between other applications. An alternative to
                well-known text is well-known binary, which is a binary representation of a geometry
                object. We have methods that work with well-known binary as well. Below are
                some samples of what well-known text might look like for various kinds of
                geometries.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <returns>
            The return type is a higher level shape constructed from the well-known text you
            passed into the method. Though the object is a higher level shape, such as a
            PolygonShape or MultiPointShape, you will need to cast it to that shape in order to use
            its unique properties.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <param name="wellKnownText"><para>A string representing the geometry in well-known text format.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.LoadFromWellKnownData(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetWellKnownText">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe geometries as a string of text. Well-known text is
                useful when you want to save a geometry in a format such as a text file, or when you simply
                want to cut and paste the text between other applications. An alternative to
                well-known text is well-known binary, which is a binary representation of a geometry
                object. We have methods that work with well-known binary as well. Below are
                some samples of what well-known text might look like for various kinds of
                geometries.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetWellKnownTextCore">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a stringthat represents the shape in well-known text.
                Well-known text allows you to describe geometries as a string of text. Well-known text is
                useful when you want to save a geometry in a format such as a text file, or when you simply
                want to cut and paste the text between other applications. An alternative to
                well-known text is well-known binary, which is a binary representation of a geometry
                object. We have methods that work with well-known binary as well. Below are
                some samples of what well-known text might look like for various kinds of
                geometries.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.CreateShapeFromWellKnownData(System.Byte[])">
            <summary>This method creates a BaseShape from a string of well-known binary.</summary>
            <remarks>
            This method creates a BaseShape from a string of well-known binary. Well-known
            binary allows you to describe geometries as a binary array. Well-known binary is useful
            when you want to save a geometry in an efficient format using as little space as
            possible. An alternative to well-known binary is well-known text, which is a textual
            representation of a geometry object. We have methods that work with well-known
            text as well.
            </remarks>
            <returns>
            The return type is a higher level shape constructed from the well-known binary
            you passed into the method. Though the object is a higher level shape, such as a
            PolygonShape or MultiPointShape, you will need to cast it to that shape in order to use
            its unique properties.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null in the bytes parameter will throw an ArgumentNullException.</exception>
            <param name="wellKnownBinary">
            	<para>An array of bytes representing the geometry in well-known binary
                format.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.LoadFromWellKnownData(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null in the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null in the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetWellKnownBinary">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe geometries as a binary array. Well-known binary 
            is useful when you want to save a geometry in an efficient format using as little space as
            possible. An alternative to well-known binary is well-known text, which is a textual
            representation of a geometry object. We have methods that work with well known
            text as well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetWellKnownBinary(ThinkGeo.MapSuite.Core.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe geometries as a binary array. Well-known binary 
            is useful when you want to save a geometry in an efficient format using as little space as
            possible. An alternative to well-known binary is well-known text, which is a textual
            representation of a geometry object. We have methods that work with well known
            text as well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <overloads>This overload allows you to specify the byte order.</overloads>
            <param name="byteOrder">This parameter is the byte order used to encode the well-known binary.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Core.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe geometries as a binary array. Well-known binary 
            is useful when you want to save a geometry in an efficient format using as little space as
            possible. An alternative to well-known binary is well-known text, which is a textual
            representation of a geometry object. We have methods that work with well known
            text as well.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies if the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetBoundingBox">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetWellKnownType">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.CloneDeep">
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.TranslateByOffset(ThinkGeo.MapSuite.Core.BaseShape,System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns a shape repositioned from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on a distance unit you specify,
            regardless of the shape's geographic unit.
            </overloads>
            <remarks>
            	<para>This method returns a shape repositioned from one location to another based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles
                on the X axis and 3 miles on the Y axis.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns a shape repositioned from one location to another based on an X and Y
            offset distance.
            </returns>
            <param name="targetShape">This parameter is the basis of the moved shape.</param>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of vertical units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the geographic unit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the distance unit you would like to use as the measure for the
                move. For example, if you select miles as your distance unit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.TranslateByOffset(ThinkGeo.MapSuite.Core.Feature,System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns a feature repositioned from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on a distance unit you specify,
            regardless of the feature's geographic unit.
            </overloads>
            <remarks>
            	<para>This method returns a feature repositioned from one location to another based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles
                on the X axis and 3 miles on the Y axis.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns a feature repositioned from one location to another based on an X and Y
            offset distance.
            </returns>
            <param name="targetFeature">This parameter is the basis of the moved feature.</param>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the geographic unit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the distance unit you would like to use as the measure for the
                move. For example, if you select miles as your distance unit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.TranslateByOffset(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves a base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on a distance unit you specify,
            regardless of the shape's geographic unit.
            </overloads>
            <remarks>
            	<para>This method moves a base shape from one location to another based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles
                on the X axis and 3 miles on the Y axis.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the geographic unit of the base shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the distance unit you would like to use as the measure for the
                move. For example, if you select miles as your distance unit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.TranslateByOffset(System.Double,System.Double)">
            <summary>
            This method moves a base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset, the offset unit is same with the shape unit(both
            of them can be considered as Meter.
            </overloads>
            <remarks>
            	<para>This method moves a base shape from one location to another based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles
                on the X axis and 3 miles on the Y axis.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves a base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on a distance unit you specify,
            regardless of the shape's geographic unit.
            </overloads>
            <remarks>
            	<para>This method moves a base shape from one location to another based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles
                on the X axis and 3 miles on the Y axis.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the geographic unit of the base shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the distance unit you would like to use as the measure for the
                move. For example, if you select miles as your distance unit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.TranslateByDegree(ThinkGeo.MapSuite.Core.BaseShape,System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns a shape repositioned from one location to another based on a
            distance and a direction in degrees.
            </summary>
            <overloads>
            In this overload, the distance is based on the distance unit you specify in the
            distanceUnit parameter, regardless of the shape's geographic unit.
            </overloads>
            <remarks>
            	<para>This method returns a shape repositioned from one location to another based on
                angleInDegrees and distance parameter. With this overload, it is important to note that
                the distance is based on the supplied distanceUnit parameter. For example,
                if your shape is in decimal degrees and you call this method with a
                distanceUnit of miles, you're going to move this shape a number of miles based on
                the distance value and the angleInDegrees. In this way, you can easily move a shape in decimal
                degrees five miles to the north.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <returns>
            This method returns a shape repositioned from one location to another based on a
            distance and a direction in degrees.
            </returns>
            <param name="targetShape">This parameter is the basis of the move.</param>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the one specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the measure for the
            move. For example, if you select miles as your distance unit, then the distance
            will be calculated in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.TranslateByDegree(ThinkGeo.MapSuite.Core.Feature,System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns a feature repositioned from one location to another, based on a
            distance and a direction in degrees.
            </summary>
            <overloads>
            In this overload, the distance is based on the distance unit you specify in the
            distanceUnit parameter, regardless of the feature's geographic unit.
            </overloads>
            <remarks>
            	<para>This method returns a feature repositioned from one location to another based on
                angleInDegrees and distance parameter. With this overload, it is important to note that
                the distance is based on the supplied distanceUnit parameter. For example,
                if your shape is in decimal degrees and you call this method with a
                distanceUnit of miles, you're going to move this feature a number of miles based on
                the distance value and the angleInDegrees. In this way, you can easily move a shape in decimal
                degrees five miles to the north.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <returns>
            This method returns a feature repositioned from one location to another, based on a
            distance and a direction in degrees.
            </returns>
            <param name="targetFeature">This parameter is the basis of the move.</param>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the DistanceUnit specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the feature, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the measure for the
            move. For example, if you select miles as your distance unit, then the distance
            will be calculated in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.TranslateByDegree(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves a base shape from one location to another based on a
            distance and a direction in degrees.
            </summary>
            <overloads>
            In this overload, the distance is based on the distance unit you specify in the
            distanceUnit parameter, regardless of the shape's geographic unit.
            </overloads>
            <remarks>
            	<para>This method moves a base shape from one location to another based on 
                angleInDegrees and distance parameter. With this overload, it is important to note that
                the distance is based on the supplied distanceUnit parameter. For example,
                if your shape is in decimal degrees and you call this method with a
                distanceUnit of miles, you're going to move this shape a number of miles based on
                the distance value and the angleInDegrees. In this way, you can easily move a shape in decimal
                degrees five miles to the north.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the DistanceUnit specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use as the measure of the translate.
            For example if you select miles as your distanceUnit then the distance will be
            calculated in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.TranslateByDegree(System.Double,System.Double)">
            <summary>
            This method moves a base shape from one location to another based on a
            distance and a direction in degrees.
            </summary>
            <overloads>
            In this overload, the distance and the shape has the same unit(both of them can be considered as Meter).
            </overloads>
            <remarks>
            	<para>This method moves a base shape from one location to another based on 
                angleInDegrees and distance parameter. With this overload, it is important to note that
                the distance is based on the supplied distanceUnit parameter. For example,
                if your shape is in decimal degrees and you call this method with a
                distanceUnit of miles, you're going to move this shape a number of miles based on
                the distance value and the angleInDegrees. In this way, you can easily move a shape in decimal
                degrees five miles to the north.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the DistanceUnit specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves a base shape from one location to another based on a
            distance and a direction in degrees.
            </summary>
            <overloads>
            In this overload, the distance is based on the distance unit you specify in the
            distanceUnit parameter, regardless of the shape's geographic unit.
            </overloads>
            <remarks>
            	<para>This method moves a base shape from one location to another based on
                angleInDegrees and distance parameter. With this overload, it is important to note that
                the distance is based on the supplied distanceUnit parameter. For example,
                if your shape is in decimal degrees and you call this method with a
                distanceUnit of miles, you're going to move this shape a number of miles based on
                the distance value and the angleInDegrees. In this way, you can easily move a shape in decimal
                degrees five miles to the north.</para>
            	<para>If you pass a distance of 0 then the operation is ignored.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the DistanceUnit specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use as the measure of the translate.
            For example if you select miles as your distanceUnit then the distance will be
            calculated in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Rotate(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.PointShape,System.Single)">
            <summary>
            This method returns a shape rotated by a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method returns a shape rotated by a number of degrees based on a pivot
                point. By placing the pivot point in the center of the shape you can achieve
                in-place rotation. By moving the pivot point outside of the center of the shape you
                can translate the shape in a circular motion. Moving the pivot point further
                outside of the center will make the circular area larger.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.NotImplementedException" caption="NotImplementedException">In the event you attempt to call this method and the CanRotate property returns false, it will throw a NotImplementedException.</exception>
            <returns>
            This method returns a shape rotated by a number of degrees based on a pivot
            point.
            </returns>
            <param name="sourceBaseShape">This parameter is the basis for the rotation.</param>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required, from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Rotate(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.PointShape,System.Single)">
            <summary>
            This method returns a feature rotated by a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method returns a feature rotated by a number of degrees based on a pivot
                point. By placing the pivot point in the center of the feature you can achieve
                in-place rotation. By moving the pivot point outside of the center of the feature you
                can translate the feature in a circular motion. Moving the pivot point further
                outside of the center will make the circular area larger.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.NotImplementedException" caption="NotImplementedException">In the event you attempt to call this method and the CanRotate property returns false, it will throw a NotImplementedException.</exception>
            <returns>
            This method returns a shape rotated by a number of degrees based on a pivot
            point.
            </returns>
            <param name="targetFeature">This parameter is the basis for the rotation.</param>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required, from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Rotate(ThinkGeo.MapSuite.Core.PointShape,System.Single)">
            <summary>
            This method rotates a shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method returns a shape rotated by a number of degrees based on a pivot
                point. By placing the pivot point in the center of the shape you can achieve
                in-place rotation. By moving the pivot point outside of the center of the shape you
                can translate the shape in a circular motion. Moving the pivot point further
                outside of the center will make the circular area larger.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.NotImplementedException" caption="NotImplementedException">In the event you attempt to call this method and the CanRotate property returns false, it will throw a NotImplementedException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required, from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.RotateCore(ThinkGeo.MapSuite.Core.PointShape,System.Single)">
            <summary>
            This method rotates a shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates a shape by a number of degrees based on a pivot
                point. By placing the pivot point in the center of the shape you can achieve
                in-place rotation. By moving the pivot point outside of the center of the shape you
                can translate the shape in a circular motion. Moving the pivot point further
                outside of the center will make the circular area larger.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.NotImplementedException" caption="NotImplementedException">In the event you attempt to call this method and the CanRotate property returns false, it will throw a NotImplementedException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required, from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetShortestLineTo(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the shortest LineShape between this shape and the targetShape
            parameter.
            </summary>
            <returns>
            A LineShape representing the shortest distance between the shape you're calling the
            method on and the targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns a LineShape representing the shortest distance between the
            shape you're calling the method on and the targetShape. In some instances, based on the
            GeographicType or Projection, the line may not be straight. This effect is similar to
            what you might see on an international flight when the displayed flight path is
            curved.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">The geographic unit of the Shape you are trying to find the distance to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetShortestLineTo(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the shortest LineShape between this shape and the targetFeature.
            parameter.
            </summary>
            <returns>
            A MultiLineShape representing the shortest distance between the shape you're calling the
            method on and the targetFeature.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns a MultiLineShape representing the shortest distance between the
            shape you're calling the method on and the targetShape. In some instances, based on the
            GeographicType or Projection, the line may not be straight. This is effect is similar to
            what you might see on an international flight when the displayed flight path is
            curved.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="targetFeature"><para>The feature you are trying to find the distance to.</para></param>
            <param name="shapeUnit">The geographic unit of the feature you are trying to find the distance to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetShortestLineToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the shortest LineShape between this shape and the targetShape
            parameter.
            </summary>
            <returns>
            A LineShape representing the shortest distance between the shape you're calling the
            method on and the targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns a LineShape representing the shortest distance between the
            shape you're calling the method on and the targetShape. In some instances, based on the
            GeographicType or Projection, the line may not be straight. This is effect is similar to
            what you might see on an international flight when the displayed flight path is
            curved.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">The geographic unit of the shape you are trying to find the distance to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetClosestPointTo(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">The geographic unit of the shape you are trying to find the closet point to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetClosestPointTo(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            feature.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetFeature.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetFeature which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetFeature, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target feature.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetFeature to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="targetFeature"><para>The feature you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">The geographic unit of the feature you are trying to find the closet point to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetClosestPointToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">The geographic unit of the shape you are trying to find the closet point to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetCenterPoint">
            <summary>This method returns the center point of the current shape's bounding box.</summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            A PointShape representing the center point of the current shape's bounding
            box.
            </returns>
            <remarks>
            This method returns the center point of the current shape's bounding box. It is
            important to note that this is the center point of the bounding box. There are numerous
            ways to calculate the "center" of a geometry, such as its weighted center, etc. You can
            find other centers by examining the various methods of the shape itself.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetCenterPointCore">
            <summary>This method returns the center point of the current shape's bounding box.</summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            A PointShape representing the center point of the current shape's bounding
            box.
            </returns>
            <remarks>
            This method returns the center point of the current shape's bounding box. It is
            important to note that this is the center point of the bounding box. There are numerous
            ways to calculate the "center" of a geometry, such as its weighted center, etc. You can
            find other centers by examining the various methods of the shape itself.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Buffer(System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method computes the area containing all of the points within a given
            distance from this shape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that represents all of the points within a
            given distance from the shape.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method computes the area containing all of the points within a given
            distance from this shape. In this case, you will be using the rounded
            RoundedBufferCapStyle and the default 8 quadrant segments. The distance unit
            is determined by the distanceUnit argument.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <overloads>
            This overload allows you to specify the distance in your choice of unit and
            uses defaults for everything else.
            </overloads>
            <param name="distance">
            The distance is the number of units to buffer the current shape. The distance
            unit will be the one specified in the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the distance. For example, if you
            select miles as your distanceUnit, then the distance will be calculated in miles for
            the operation.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Buffer(System.Double,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method computes the area containing all of the points within a given
            distance from this shape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that represents all of the points within a
            given distance from the shape.
            </returns>
            <overloads>
            This overload allows you to specify the distance in your choice of unit,
            specify the number of quadrant segments and uses defaults for everything else.
            </overloads>
            <remarks>
            This method computes the area containing all of the points within a given
            distance from this shape. In this case, you will be using the rounded
            RoundedBufferCapStyle. The distance unit is determined by the distanceUnit
            argument.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number of quadrant segments which is not between 3 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="distance">
            The distance is the number of units to buffer the current shape. The distance
            unit will be the one specified in the distanceUnit parameter.
            </param>
            <param name="quadrantSegments">
            The quadrant segments are the number of points in each quarter circle. A good
            default is 8, but if you want smoother edges you can increase this number. The valid
            range for this number is from 3 to 100.
            </param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the distance. For example, if you
            select miles as your distanceUnit, then the distance will be calculated in miles for
            the operation.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Buffer(System.Double,System.Int32,ThinkGeo.MapSuite.Core.BufferCapType,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method computes the area containing all of the points within a given
            distance from this shape.
            </summary>
            <overloads>This overload allows you to specify every parameter.</overloads>
            <returns>
            The return type is a MultiPolygonShape that represents all of the points within a
            given distance from the shape.
            </returns>
            <remarks>
            This method computes the area containing all of the points within a given
            distance from this shape.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number of quadrant segments which is not between 3 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a bufferCapType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="distance">
            The distance is the number of units to buffer the current shape. The distance
            unit will be the one specified in the distanceUnit parameter.
            </param>
            <param name="quadrantSegments">
            The quadrant segments are the number of points in each quarter circle. A good
            default is 8, but if you want smoother edges you can increase this number. The valid
            range for this number is from 3 to 100.
            </param>
            <param name="bufferCapType">
            The bufferCapType determines how the caps of the buffered object look. They
            range from rounded to squared off.
            </param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the distance. For example, if you
            select miles as your distanceUnit, then the distance will be calculated in miles for
            the operation.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.BufferCore(System.Double,System.Int32,ThinkGeo.MapSuite.Core.BufferCapType,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method computes the area containing all of the points within a given
            distance from this shape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that represents all of the points within a
            given distance from the shape.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a bufferCapType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid quadrantSegments which is not between 3 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method computes the area containing all of the points within a given
            distance from this shape. In this case, you will be using the rounded
            RoundedBufferCapStyle and the default 8 quadrant segments. The distance unit
            is determined by the distanceUnit argument.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <overloads>
            This overload allows you to specify the distance in your choice of unit and
            uses defaults for everything else.
            </overloads>
            <param name="distance">
            The distance is the number of units to buffer the current shape. The distance
            unit will be the one specified in the distanceUnit parameter.
            </param>
            <param name="quadrantSegments">The number of quadrantSegments used in the buffer logic.</param>
            <param name="bufferCapType">The bufferCapType used in the buffer logic.</param>
            <param name="shapeUnit">
            This is the geographic unit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the distance unit you would like to use as the distance. For example, if you
            select miles as your distanceUnit, then the distance will be calculated in miles for
            the operation.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetDistanceTo(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>The distance returned will be in the unit of the shape.</overloads>
            <returns>
            The return type is the distance between this shape and the targetShape in the
            GeographyUnit of the shape.
            </returns>
            <remarks>
            In this method we compute the closest distance between the two shapes. The
            returned unit will be in the unit of distance specified.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">This parameter is the unit of the shape you are getting the distance to.</param>
            <param name="distanceUnit">
            This parameter is the unit of the distance you want the return value to be
            in.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetDistanceTo(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method computes the distance between the current shape and the
            targetFeature.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>The distance returned will be in the unit of the shape.</overloads>
            <returns>
            The return type is the distance between this shape and the targetFeature in the
            GeographyUnit of the shape.
            </returns>
            <remarks>
            In this method we compute the closest distance between a shape and a feature. The
            returned unit will be in the unit of distance specified.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="targetFeature"><para>The feature you are trying to find the distance to.</para></param>
            <param name="shapeUnit">This parameter is the unit of the shape which is contained in the targetFeature you are getting the distance to.</param>
            <param name="distanceUnit">
            This parameter is the unit of the distance you want the return value to be
            in.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetDistanceToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>The distance returned will be in the unit of the shape.</overloads>
            <returns>
            The return type is the distance between this shape and the targetShape in the
            GeographyUnit of the shape.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </returns>
            <remarks>
            In this method we compute the closest distance between the two shapes. The
            returned unit will be in the unit of distance specified.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit"> the geographic unit of the targetShape.</param>
            <param name="distanceUnit">The returning distance unit.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Register(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Register(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointFeature in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointFeature in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.RegisterCore(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Validate(ThinkGeo.MapSuite.Core.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.ValidateCore(ThinkGeo.MapSuite.Core.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.IsDisjointed(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape have no points in
            common.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape have no points in
            common.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.IsDisjointed(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns if the current shape and the targetFeature have no points in
            common.
            </summary>
            <returns>
            This method returns if the current shape and the targetFeature have no points in
            common.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The feature you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.IsDisjointedCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape have no points in
            common.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape have no points in
            common.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Intersects(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape have at least one
            point in common.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape have at least one
            point in common.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Intersects(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns if the current shape and the targetFeature have at least one
            point in common.
            </summary>
            <returns>
            This method returns if the current shape and the targetFeature have at least one
            point in common.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.IntersectsCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape have at least one
            point in common.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape have at least one
            point in common.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Touches(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape have at least one
            boundary point in common, but no interior points.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape have at least one
            boundary point in common, but no interior points.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Touches(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns of the current shape and the targetFeature have at least one
            boundary point in common, but no interior points.
            </summary>
            <returns>
            This method returns of the current shape and the targetFeature have at least one
            boundary point in common, but no interior points.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature which contains a shape that you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.TouchesCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape have at least one
            boundary point in common, but no interior points.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape have at least one
            boundary point in common, but no interior points.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Crosses(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape share some but not
            all interior points.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape share some but not
            all interior points.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Crosses(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns if the current shape and the targetFeature share some but not
            all interior points.
            </summary>
            <returns>
            This method returns if the current shape and the targetFeature share some but not
            all interior points.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.CrossesCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape share some but not
            all interior points.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape share some but not
            all interior points.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.IsWithin(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the current shape lies within the interior of the
            targetShape.
            </summary>
            <returns>
            This method returns if the current shape lies within the interior of the
            targetShape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.IsWithin(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns if the current shape lies within the interior of the
            targetFeature.
            </summary>
            <returns>
            This method returns if the current shape lies within the interior of the
            targetFeature.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.IsWithinCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the current shape lies within the interior of the
            targetShape.
            </summary>
            <returns>
            This method returns if the current shape lies within the interior of the
            targetShape.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Contains(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the targetShape lies within the interior of the current
            shape.
            </summary>
            <returns>
            This method returns if the targetShape lies within the interior of the current
            shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Contains(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns if the targetFeature lies within the interior of the current
            shape.
            </summary>
            <returns>
            This method returns if the targetFeature lies within the interior of the current
            shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.ContainsCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the targetShape lies within the interior of the current
            shape.
            </summary>
            <returns>
            This method returns if the targetShape lies within the interior of the current
            shape.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Overlaps(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape share some but not
            all points in common.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape share some but not
            all points in common.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.Overlaps(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns if the current shape and the targetFeature share some but not
            all points in common.
            </summary>
            <returns>
            This method returns if the current shape and the targetFeature share some but not
            all points in common.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.OverlapsCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape share some but not
            all points in common.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape share some but not
            all points in common.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.IsTopologicallyEqual(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape are topologically
            equal.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape are topologically
            equal.
            </returns>
            <remarks>
            Topologically equal means that the shapes are essentially the same. For example,
            let's say you have a line with two points, point A and point B. You also have another line that
            is made up of point A, point B and point C. Point A of line one shares the same vertex
            as point A of line two, and point B of line one shares the same vertex as point C of
            line two. They are both straight lines, so point B of line two would lie on the first
            line. Essentially the two lines are the same, with line 2 having just one extra point.
            Topologically they are the same line, so this method would return true.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.IsTopologicallyEqual(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns if the current shape and the targetFeature are topologically
            equal.
            </summary>
            <returns>
            This method returns if the current shape and the targetFeature are topologically
            equal.
            </returns>
            <remarks>
            Topologically equal means that the shapes are essentially the same. For example,
            let's say you have a line with two points, point A and point B. You also have another line that
            is made up of point A, point B and point C. Point A of line one shares the same vertex
            as point A of line two, and point B of line one shares the same vertex as point C of
            line two. They are both straight lines, so point B of line two would lie on the first
            line. Essentially the two lines are the same, with line 2 having just one extra point.
            Topologically they are the same line, so this method would return true.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">The targetFeature that contains a shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.IsTopologicallyEqualCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns if the current shape and the targetShape are topologically
            equal.
            </summary>
            <returns>
            This method returns if the current shape and the targetShape are topologically
            equal.
            </returns>
            <remarks>
            Topologically equal means that the shapes are essentially the same. For example,
            let's say you have a line with two points, point A and point B. You also have another line that
            is made up of point A, point B and point C. Point A of line one shares the same vertex
            as point A of line two, and point B of line one shares the same vertex as point C of
            line two. They are both straight lines, so point B of line two would lie on the first
            line. Essentially the two lines are the same, with line 2 having just one extra point.
            Topologically they are the same line, so this method would return true.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetFeature">
            <summary>
            Get a corresponding feature which has the same Id and BaseShape as the current
            shape.
            </summary>
            <returns>
            The feature with the same Id and BaseShape as the current BaseShape, and with empty
            columnValues in it.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetFeature(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Get a corresponding feature which has the same Id and BaseShape as the current
            shape. Additionally, pass the specified columnValues into the returned feature.
            </summary>
            <returns>
            The feature with the same Id and BaseShape as the current BaseShape and with empty
            columnValues in it, substituted with the passed-in columnValues.
            </returns>
            <param name="columnValues">The columnValues will be passed into returning feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetCrossing(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing points with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.GetCrossingCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.ScaleTo(ThinkGeo.MapSuite.Core.BaseShape,System.Double)">
            <summary>
            This method increases or decreases the size of the shape by the specified scale
            factor given in the parameter.
            </summary>
            <returns>
            This method is useful when you would like to increase or decrease the size of the shape. 
            </returns>
            <returns>The new shape under new scale</returns>
            <remarks>It will call the instanced method ScaleTo internally.</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Is you pass in the scale is not bigger than zero, it will throw ArgumentOutOfRangeException.</exception>
            <example>
            	<code lang="CS" title="C# sample" description="This code snippet shows how to use the ScaleTo method.">
            RectangleShape rectangleShape = new RectangleShape(-10, 10, 10, -10);
                        RectangleShape smallerShape = BaseShape.ScaleTo(rectangleShape, 0.5) as RectangleShape;
                        RectangleShape biggerShape = BaseShape.ScaleTo(rectangleShape, 2) as RectangleShape;
            </code>
            	<code lang="VB" title="VB sample" description="This code snippet shows how to use the ScaleTo method.">
            Dim rectangleShape As New RectangleShape(-10, 10, 10, -10)
                        Dim smallerShape As RectangleShape = TryCast(BaseShape.ScaleTo(rectangleShape, 0.5), RectangleShape)
                        Dim biggerShape As RectangleShape = TryCast(BaseShape.ScaleTo(rectangleShape, 2), RectangleShape)
            </code>
            </example>
            <param name="baseShape">Represents a shape which you want to resize</param>
            <param name="scale">Pepresents a value which scaleFactor to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.ScaleTo(System.Double)">
            <summary>
            This method increases or decreases the size of the shape by the specified scale
            factor given in the parameter.
            </summary>
            <returns>
            This method is useful when you would like to increase or decrease the size of the shape. 
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <example>
            	<code lang="CS" title="C# sample" description="This code snippet shows how to use the ScaleTo method.">
            RectangleShape rectangleShape = new RectangleShape(-10, 10, 10, -10);
            rectangleShape.ScaleTo(rectangleShape, 0.5);
            rectangleShape.ScaleTo(rectangleShape, 2);
            </code>
            	<code lang="VB" title="VB sample" description="This code snippet shows how to use the ScaleTo method.">
            Dim rectangleShape As New RectangleShape(-10, 10, 10, -10)
            rectangleShape.ScaleTo(rectangleShape, 0.5)
            rectangleShape.ScaleTo(rectangleShape, 2)
            </code>
            </example>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Is you pass in the scale is not bigger than zero, it will throw ArgumentOutOfRangeException.</exception>
            <param name="scale">Pepresents a value which scaleFactor to</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BaseShape.ScaleToCore(System.Double)">
            <summary>
            This method increases or decreases the size of the shape by the specified scale factor given in the
            parameter.
            </summary>
            <returns>
            This method is useful when you would like to increase or decrease the size of the shape. 
            </returns>
            <remarks>
                This protected virtual method is called from the concrete public method
                ScaleTo. It does not take into account any transaction activity, as this is the
                responsibility of the concrete public method ScaleTo. This way, as a developer,
                if you choose to override this method you do not have to consider transactions at
                all.
            </remarks>
            <param name="scale">Pepresents a value which scaleFactor to</param>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Is you pass in the scale is not bigger than zero, it will throw ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.BaseShape.Id">
            <summary>
            The id of the shape.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.BaseShape.Tag">
            <summary>
            The tag of the shape.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.BaseShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <value>This property specifies if the shape can be rotated.</value>
            <remarks>
            If this property returns false and you attempt to call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.#ctor">
            <summary>This is the default constructor for AreaBaseShape.</summary>
            <remarks>This constructor simply calls the base constructor.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetPerimeter(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns the perimeter of the shape, defined as the sum of the lengths
            of all its sides.
            </summary>
            <overloads>
            In this overload, the return unit is based on a LengthUnit you specify in the
            returningLengthUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on a LengthUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            You would use this method to find the distance around the area shape.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">&gt;In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetPerimeterCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns the perimeter of the shape, defined as the sum of the lengths
            of all its sides.
            </summary>
            <overloads>
            In this overload, the return unit is based on a LengthUnit you specify in the
            returningLengthUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on a LengthUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            You would use this method to find the distance around the area shape.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">&gt;In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use as the return value.  For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetArea(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.AreaUnit)">
            <summary>
            This method returns the area of the shape, defined as the size of the region
            enclosed by the figure.
            </summary>
            <overloads>
            In this overload, the return unit is based on a AreaUnit you specify in the
            returningUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on a AreaUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>You would use this method to find the area inside the shape.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">&gt;In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the AreaUnit you would like to use as the return value. For example, if
            you select square miles as your returningUnit, then the distance will be returned in
            square miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetAreaCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.AreaUnit)">
            <summary>
            This method returns the area of the shape, defined as the size of the region
            enclosed by the figure.
            </summary>
            <overloads>
            In this overload, the return unit is based on a AreaUnit you specify in the
            returningUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on a AreaUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            You would use this method to find the area inside the shape.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">&gt;In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the AreaUnit you would like to use as the return value. For example, if
            you select square miles as your returningUnit, then the distance will be returned in
            square miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.ScaleUp(ThinkGeo.MapSuite.Core.AreaBaseShape,System.Double)">
            <summary>
            This method returns a new area shape that has been scaled up by the percentage
            given in the percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, since you apply the operation
            multiple times. There is a ScaleDown method that will shrink the shape as
            well.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <param name="targetShape">This parameter is the shape to use as the base for the scaling.</param>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.ScaleUp(ThinkGeo.MapSuite.Core.Feature,System.Double)">
            <summary>
            This method returns a new area shape that has been scaled up by the percentage
            given in the percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, since you apply the operation
            multiple times. There is a ScaleDown method that will shrink the shape as
            well.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <param name="targetFeature">This parameter is the feature to use as the base for the scaling.</param>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.ScaleUp(System.Double)">
            <summary>
            This method increases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">&gt;In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, since you apply the operation
            multiple times. There is a ScaleDown method that will shrink the shape. as
            well.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.ScaleUpCore(System.Double)">
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">&gt;In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <summary>
            This method increases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, since you apply the operation
            multiple times. There is a ScaleDown method that will shrink the shape as
            well.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.ScaleDown(ThinkGeo.MapSuite.Core.AreaBaseShape,System.Double)">
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, since you apply the operation
            multiple times. There is a ScaleUp method that will enlarge the shape as
            well.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, since you apply the operation
            multiple times. There is a ScaleUp method that will enlarge the shape as
            well.
            </remarks>
            <summary>
            This method returns a new area shape that has been scaled down by the percentage
            given in the percentage parameter.
            </summary>
            <param name="targetShape">This parameter is the shape to use as the base for the scaling.</param>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.ScaleDown(ThinkGeo.MapSuite.Core.Feature,System.Double)">
            <returns>
            This method is useful when you would like to decrease the size of the feature. Note
            that a larger percentage will scale the shape down faster, since you apply the operation
            multiple times. There is a ScaleUp method that will enlarge the shape as
            well.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to decrease the size of the feature. Note
            that a larger percentage will scale the shape down faster, since you apply the operation
            multiple times. There is a ScaleUp method that will enlarge the shape as
            well.
            </remarks>
            <summary>
            This method returns a new area feature that has been scaled down by the percentage
            given in the percentage parameter.
            </summary>
            <param name="targetFeature">This parameter is the shape to use as the base for the scaling.</param>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.ScaleDown(System.Double)">
            <summary>
            This method decreases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, since you apply the operation
            multiple times. There is a ScaleUp method that will enlarge the shape as
            well.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage that is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, since you apply the operation
            multiple times. There is a ScaleUp method that will enlarge the shape as
            well.
            </remarks>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.ScaleDownCore(System.Double)">
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <summary>
            This method decreases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, since you apply the operation
            multiple times. There is a ScaleUp method that will enlarge the shape as
            well.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetConvexHull">
            <summary>
            This method returns the convex hull of the shape, defined as the smallest convex
            ring that contains all of the points in the shape.
            </summary>
            <returns>
            This method returns the convex hull of the shape, defined as the smallest convex
            ring that contains all of the points in the shape.
            </returns>
            <remarks>
            This method is useful when you want to create a perimeter around the shape. For
            example, if you had a MultiPolygon that represented buildings on a campus, you could
            easily get the convex hull of the buildings and determine the perimeter of all of the
            buildings together. This also works with MultiPoint shapes, where each point may
            represent a certain type of person you are doing statistics on. With convex hull, you
            can get an idea of the regions those points are located in.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetConvexHullCore">
            <summary>
            This method returns the convex hull of the shape, defined as the smallest convex
            ring that contains all of the points in the shape.
            </summary>
            <returns>
            This method returns the convex hull of the shape, defined as the smallest convex
            ring that contains all of the points in the shape.
            </returns>
            <remarks>
            This method is useful when you want to create a perimeter around the shape. For
            example, if you had a MultiPolygon that represented buildings on a campus, you could
            easily get the convex hull of the buildings and determine the perimeter of all of the
            buildings together. This also works with MultiPoint shapes, where each point may
            represent a certain type of person you are doing statistics on. With convex hull, you
            can get an idea of the regions those points are located in.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetIntersection(ThinkGeo.MapSuite.Core.AreaBaseShape)">
            <summary>
            This method returns the intersection of the current shape and the target shape,
            defined as the set of all points which lie in both the current shape and the target
            shape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points which
            lie in both the current shape and the target shape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetShape">The shape you are trying to find the intersection with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetIntersection(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns the intersection of the current shape and the target feature,
            defined as the set of all points which lie in both the current shape and the target
            feature.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points which
            lie in both the current shape and the target feature.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetFeature">The feature you are trying to find the intersection with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetIntersectionCore(ThinkGeo.MapSuite.Core.AreaBaseShape)">
            <summary>
            This method returns the intersection of the current shape and the target shape,
            defined as the set of all points which lie in both the current shape and the target
            shape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points which
            lie in both the current shape and the target shape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="targetShape">The shape you are trying to find the intersection with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.Union(ThinkGeo.MapSuite.Core.AreaBaseShape)">
            <summary>
            This method returns the union of the current shape and the target shape, defined
            as the set of all points in the current shape or the target shape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points which
            lie in the current shape or the target shape.
            </returns>
            <remarks>
            This is useful for adding area shapes together to form a larger area
            shape.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="targetShape">The shape you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.Union(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns the union of the current shape and the target feature, defined
            as the set of all points in the current shape or the target feature.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points which
            lie in the current shape or the target feature.
            </returns>
            <remarks>
            This is useful for adding area shapes together to form a larger area
            shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="targetFeature">The feature you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.UnionCore(ThinkGeo.MapSuite.Core.AreaBaseShape)">
            <summary>
            This method returns the union of the current shape and the target shapes, defined
            as the set of all points in the current shape or the target shape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points which
            lie in the current shape or the target shape.<br/>
            	<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </returns>
            <remarks>
            This is useful for adding area shapes together to form a larger area
            shape.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="targetShape">The shape you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.Union(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature})">
            <summary>
            This method returns the union of the current shape and the target features, defined
            as the set of all points in the current shape or the target features.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points which
            lie in the current shape or the target features.<br/>
            	<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </returns>
            <remarks>
            This is useful for adding area shapes together to form a larger area
            shape.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetFeatures, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="targetFeatures">The target features you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.Union(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.AreaBaseShape})">
            <summary>
            This method returns the union of the specified area shapes.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that contains the set of all points that
            lie within the shapes you specified.<br/>
            	<br/>
            	<br/>
            	<br/>
            </returns>
            <remarks>
            This is useful for adding area shapes together to form a larger area
            shape.<br/>
            	<br/>
            	<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapes, we will throw an ArgumentNullException.</exception>
            <param name="areaShapes">The shapes you are trying to find the union with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetDifference(ThinkGeo.MapSuite.Core.AreaBaseShape)">
            <summary>
            This method returns the difference between two shapes, defined as the set of all
            points which lie in the current shape but not in the targetShape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that is the set of all points which lie in
            the current shape but not in the targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetShape">The shape you are trying to find the difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetDifference(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns the difference between current shape and the specified feature, defined as the set of all
            points which lie in the current shape but not in the targetShape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that is the set of all points which lie in
            the current shape but not in the target feature.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetFeature">The feture you are trying to find the difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetDifferenceCore(ThinkGeo.MapSuite.Core.AreaBaseShape)">
            <summary>
            This method returns the difference between two shapes, defined as the set of all
            points which lie in the current shape but not in the targetShape.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that is the set of all points which lie in
            the current shape but not in the targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="targetShape">The shape you are trying to find the difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetSymmetricalDifference(ThinkGeo.MapSuite.Core.AreaBaseShape)">
            <summary>
            This method returns the symmetrical difference between two shapes, defined as the
            set of all points which lie in the current shape or the targetShape but not
            both.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that is the set of all points which lie in
            the current shape or the targetShape but not both.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetShape">The shape you are trying to find the symmetrical difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetSymmetricalDifference(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns the symmetrical difference between current shape and the specified feature, defined as the
            set of all points which lie in the current shape or the targetFeature but not
            both.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that is the set of all points which lie in
            the current shape or the targetFeature but not both.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetFeature">The feature you are trying to find the symmetrical difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.GetSymmetricalDifferenceCore(ThinkGeo.MapSuite.Core.AreaBaseShape)">
            <summary>
            This method returns the symmetrical difference between two shapes, defined as the
            set of all points which lie in the current shape or the targetShape but not
            both.
            </summary>
            <returns>
            The return type is a MultiPolygonShape that is the set of all points which lie in
            the current shape or the targetShape but not both.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">&gt;In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <param name="targetShape">The shape you are trying to find the symmetrical difference with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.Split(ThinkGeo.MapSuite.Core.AreaBaseShape,ThinkGeo.MapSuite.Core.AreaBaseShape)">
            <summary>
            This method returns a collection of MultiPolygonShapes split by the specified
            parameters.
            </summary>
            <overloads>This overload allows you split two area type shapes.</overloads>
            <returns>
            This method returns a collection of MultiPolygonShape split by the specified
            parameters.
            </returns>
            <remarks>None.</remarks>
            <param name="areaToSplit">This parameter represents the shape to be split.</param>
            <param name="areaToSplitBy">This parameter represents the shape that will be used to perform the split.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.Split(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns a collection of Features split by the specified
            parameters.
            </summary>
            <overloads>This overload allows you split two area type features.</overloads>
            <returns>
            This method returns a collection of Features split by the specified
            parameters.
            </returns>
            <remarks>None.</remarks>
            <param name="areaToSplit">This parameter represents the feature to be split.</param>
            <param name="areaToSplitBy">This parameter represents the feature that will be used to perform the split.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.Simplify(ThinkGeo.MapSuite.Core.AreaBaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Double,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.SimplificationType)">
            <summary>
            This method performed a simplification operation based on the parameters passed in.
            Simplify permanently alters the input geometry so that the geometry becomes topologically consistent.
            </summary>
            <param name="targetShape">This parameter specifies the area shape to be simplfied.</param>
            <param name="targetShapeUnit">This parameter specifies the geographic unit of the shape you are performing the operation</param>
            <param name="tolerance">This parameter specifes the tolerance to be used when simplification.</param>
            <param name="toleranceUnit">This parameter specifes the distance unit of the tolerance.</param>
            <param name="simplificationType">This prameter specifies the type of simplification operation.</param>
            <returns>This method returns a simplification multipolgyon by the specified parameters. </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.Simplify(ThinkGeo.MapSuite.Core.AreaBaseShape,System.Double,ThinkGeo.MapSuite.Core.SimplificationType)">
            <summary>
            This method performed a simplification operation based on the parameters passed in.
            Simplify permanently alters the input geometry so that the geometry becomes topologically consistent.
            </summary>
            <param name="targetShape">This parameter specifies the area shape to be simplfied.</param>
            <param name="tolerance">This parameter specifes the tolerance to be used when simplification.</param>
            <param name="simplificationType">This prameter specifies the type of simplification operation.</param>
            <returns>This method returns a simplification multipolgyon by the specified parameters. </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.Simplify(ThinkGeo.MapSuite.Core.GeographyUnit,System.Double,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.SimplificationType)">
            <summary>
            This method performed a simplification operation based on the parameters passed in.
            Simplify permanently alters the input geometry so that the geometry becomes topologically consistent.
            </summary>
            <param name="shapeUnit">This parameter specifies the geographic unit of this current shape you are performing the operation</param>
            <param name="tolerance">This parameter specifes the tolerance to be used when simplification.</param>
            <param name="toleranceUnit">This parameter specifes the distance unit of the tolerance.</param>
            <param name="simplificationType">This prameter specifies the type of simplification operation.</param>
            <returns>This method returns a simplification multipolgyon by the specified parameters. </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.Simplify(System.Double,ThinkGeo.MapSuite.Core.SimplificationType)">
            <summary>
            This method performed a simplification operation based on the parameters passed in.
            Simplify permanently alters the input geometry so that the geometry becomes topologically consistent.
            </summary>
            <param name="tolerance">This parameter specifes the tolerance to be used when simplification.</param>
            <param name="simplificationType">This prameter specifies the type of simplification operation.</param>
            <returns>This method returns a simplification multipolgyon by the specified parameters. </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaBaseShape.SimplifyCore(System.Double,ThinkGeo.MapSuite.Core.SimplificationType)">
            <summary>
            This method performed a simplification operation based on the parameters passed in.
            Simplify permanently alters the input geometry so that the geometry becomes topologically consistent.
            </summary>
            <param name="tolerance">This parameter specifes the tolerance to be used when simplification.</param>
            <param name="simplificationType">This prameter specifies the type of simplification operation.</param>
            <returns>This method returns a simplification multipolgyon by the specified parameters. </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.#ctor">
            <overloads>This overload creates a RingShape without any points.</overloads>
            <summary>This constructor creates a RingShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Vertex})">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the points, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates a RingShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates a RingShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and the copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.ToPolygon">
            <returns>This method returns the current shape as a PolygonShape.</returns>
            <remarks>
            This method is mainly used to convert this GIS non-standard shape to a GIS
            standard shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the current shape as a PolygonShape.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.GetPerimeterCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns the perimeter of the shape, defined as the sum of the lengths
            of all its sides.
            </summary>
            <overloads>
            In this overload the return unit is based on the LengthUnit you specify in the
            returningLengthUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the LengthUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            You would use this method to find the distance around the area shape.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.GetAreaCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.AreaUnit)">
            <summary>
            This method returns the area of the shape, defined as the size of the region
            enclosed by the figure.
            </summary>
            <overloads>
            In this overload, the return unit is based on the AreaUnit you specify in the
            returningUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the AreaUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>You would use this method to find the area inside the shape.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the AreaUnit you would like to use as the return value. For example, if
            you select square miles as your returningUnit, then the distance will be returned in
            square miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>None</remarks>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.RegisterCore(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another, based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload the X and Y offset are based on the DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape 1 unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles to
                on the X axis and 3 miles on the Y axis.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the
                move. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another, based on a
            distance and a direction in degrees.
            </summary>
            <overloads>In this overload, the distance is in the same GeographicUnit as the shape.</overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an
                angleInDegrees and distance parameter. With this overload, it is important to note
                that the distance units are the same GeographicUnit as the shape. For example,
                if your shape is in decimal degrees and you call this method with a distance of 1,
                you're going to move this shape 1 decimal degree in direction of the
                angleInDegrees. In many cases it is more useful to specify the DistanceUnit of movement,
                such as in miles or yards, so for these scenarios there is another overload you may
                want to use instead.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape in the angle specified. The
            distance unit will be the same as the GeographyUnit for the shape. The distance must be
            greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the
                move. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.RotateCore(ThinkGeo.MapSuite.Core.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.GetDistanceToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>The distance returned will be in the unit of the shape.</overloads>
            <returns>
            The return type is the distance between this shape and the targetShape in the
            GeographyUnit of the shape.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </returns>
            <remarks>
            In this method, we compute the closest distance between the two shapes. The
            returned unit will be in the unit of distance specified.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">The GeographUnit of the targetShape.</param>
            <param name="distanceUnit">The DistanceUnit of the returned value.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.GetClosestPointToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.GetWellKnownTextCore">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric shapes.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Core.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe a geometry as a binary array. Well-known
            binary is useful when you want to save a geometry in an efficient format using as little
            space as possible. An alternative to well-known binary is well-known text, which is a
            textual representation of a geometry object. We have methods that work with well-known
            text as well.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies whether the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.RemoveVertex(ThinkGeo.MapSuite.Core.Vertex,ThinkGeo.MapSuite.Core.RingShape)">
            <summary>
            This method removes the selected vertex from ring shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of ring shape, otherwise it will return false and ring shape will keep the same.</param>
            <param name="ringShape">The line shape will be removed one vertex.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.RemoveVertex(ThinkGeo.MapSuite.Core.Vertex)">
            <summary>
            This method removes the selected vertex from ring shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of ring shape, otherwise it will return false and ring shape will keep the same.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.ValidateCore(ThinkGeo.MapSuite.Core.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.IsCounterClockwise">
            <summary>
            Tests whether a ring is oriented counter-clockwise.
            </summary>
            <returns>Returns true if ring is oriented counter-clockwise.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.ReversePoints">
            <summary>This method reverses the order of the points in the ring.</summary>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RingShape.ReversePointsCore">
            <summary>This method reverses the order of the points in the ring.</summary>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RingShape.Vertices">
            <summary>This property is the collection of points that make up the RingShape.</summary>
            <decimalDegreesValue>This property is the collection of points that make up the RingShape.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoDashCap">
            <summary>
            	<para>This enumeration represents the type of graphic shape to use on both ends of
                each dash in a dashed line.</para>
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoDashCap.Flat">
            <summary>Specifies a square cap that squares off both ends of each dash.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoDashCap.Round">
            <summary>Specifies a circular cap that rounds off both ends of each dash.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoDashCap.Triangle">
            <summary>Specifies a triangular cap that points both ends of each dash.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoCanvas">
            <summary>
            This class represents a canvas that is used to draw geographic shapes. It is
            intended to be inherited for the implementation of different drawing systems, such as GDI+ or
            WPF.
            </summary>
            <remarks>
            	<para>This class allows you to implement different drawing systems, such as GDI+,
                GDI, or WPF. It can also be used for other systems, such as PDF.<br/>
            		<br/>
                The basic flow of the use of the class is to first call BeginDrawing and pass
                in an image along with its world extent.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.#ctor">
            <summary>This method is the default constructor for the GeoCanvas.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.CloneDeep">
            <summary>Create a copy of GeoCanvas using the deep clone process.</summary>
            <returns>A cloned GeoCanvas.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.CloneDeepCore">
            <summary>Create a copy of GeoCanvas using the deep clone process. The default implementation uses serialization.</summary>
            <returns>A cloned GeoCanvas.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.Clear(ThinkGeo.MapSuite.Core.GeoBrush)">
            <summary>This method clears the current GeoCanvas using the color specified.</summary>
            <remarks>Use this method to clear the GeoCanvas.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.ClearCore(ThinkGeo.MapSuite.Core.GeoBrush)">
            <summary>This method clears the current GeoCanvas using the color specified.</summary>
            <remarks>
            	<para>Use this method to clear the GeoCanvas.</para>
            	<para>This method is designed to be overridden by the deriving class.</para>
            </remarks>
            <param name="fillBrush">This parameter specifies the the brush that will be used to clear the GeoCanvas.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoPen and the DrawingLevel you want to
            draw on.
            </overloads>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="feature">This parameter is the area feature.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            area.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Core.AreaBaseShape,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoPen and the DrawingLevel you want to
            draw on.
            </overloads>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="shape">This parameter is the area shape.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            area.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoBrush and the DrawingLevel you want to
            draw on.
            </overloads>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="feature">This parameter is the AreaShape in well-known binary format.</param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Core.AreaBaseShape,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoBrush, GeoPen, and the DrawingLevel
            you want to draw on.
            </overloads>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="shape">This parameter is the area shape to be drawn.</param>
            <param name="fillBrush">
            This parameter describes the fill Brush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoBrush, GeoPen, and the DrawingLevel
            you want to draw on.
            </overloads>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="feature">This parameter is the AreaFeature to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            AreaShape.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Core.AreaBaseShape,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoBrush, GeoPen, and the DrawingLevel
            you want to draw on.
            </overloads>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="shape">This parameter is the area shape to be drawn.</param>
            <param name="outlinePen">This parameter describes the outline pen that will be used to draw the AreaShape.</param>
            <param name="fillBrush">
            This parameter describes the fill Brush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Core.PenBrushDrawingOrder)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoBrush, GeoPen, and the DrawingLevel
            you want to draw on.
            </overloads>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="feature">This parameter is the AreaFeature to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            AreaShape.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the feature that will be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature that will be drawn.</param>
            <param name="penBrushDrawingOrder">This parameter determines the PenBrushingDrawingOrder used when drawing the area type feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawArea(ThinkGeo.MapSuite.Core.AreaBaseShape,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Core.PenBrushDrawingOrder)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoBrush, GeoPen, and the DrawingLevel
            you want to draw on.
            </overloads>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="shape">This parameter is the area shape to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            AreaShape.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the feature to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature to be drawn.</param>
            <param name="penBrushDrawingOrder">This parameter determines the PenBrushDrawingOrder used when drawing the area type feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawArea(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.ScreenPointF[]},ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Core.PenBrushDrawingOrder)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="screenPoints">This parameter is the AreaShape in well-known binary format.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            AreaShape.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>        
            <param name="xOffset"> This parameter determines the X offset for the feature to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature to be drawn.</param>
            <param name="penBrushDrawingOrder">This parameter determines the PenBrushDrawingOrder used when drawing the area type feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawAreaCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.ScreenPointF[]},ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Core.PenBrushDrawingOrder)">
            <summary>This method draws an area on the GeoCanvas.</summary>
            <returns>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <param name="screenPoints">This parameter is the AreaShape in well-known binary format.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            AreaShape.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            AreaShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>        
            <param name="xOffset"> This parameter determines the X offset for the feature to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature to be drawn.</param>
            <param name="penBrushDrawingOrder">This parameter determines the PenBrushDrawingOrder used when drawing the area type feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawLine(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>Draws a line on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a line on the GeoCanvas using the specified GeoPen.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple lines. This is very useful when you want to draw a road, for example. You can
                draw the black background on the lowest level, then draw a slightly thinner white line on a higher
                level. This will result in a great effect for a road.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the lineShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the linePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="feature">This parameter is the line feature.</param>
            <param name="linePen">This parameter describes the GeoPen that will be used to draw the line.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawLine(ThinkGeo.MapSuite.Core.LineBaseShape,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>Draws a line on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a line on the GeoCanvas using the specified GeoPen.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple lines. This is very useful when you want to draw a road, for example. You can
                draw the black background on the lowest level, then draw a slightly thinner white line on a higher
                level. This will result in a great effect for a road.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the lineShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the linePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="shape">This parameter is the line shape to be drawn by GeoCannvas.</param>
            <param name="linePen">This parameter describes the GeoPen that will be used to draw the line.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawLine(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single)">
            <summary>Draws a line on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a line on the GeoCanvas using the specified GeoPen.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple lines. This is very useful when you want to draw a road, for example. You can
                draw the black background on the lowest level, then draw a slightly thinner white line on a higher
                level. This will result in a great effect for a road.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the lineShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the linePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="feature">This parameter is the line feature to be drawn by GeoCannvas.</param>
            <param name="linePen">This parameter describes the GeoPen that will be used to draw the line.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the feature to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawLine(ThinkGeo.MapSuite.Core.LineBaseShape,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single)">
            <summary>Draws a line on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a line on the GeoCanvas using the specified GeoPen.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple lines. This is very useful when you want to draw a road, for example. You can
                draw the black background on the lowest level, then draw a slightly thinner white line on a higher
                level. This will result in a great effect for a road.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the lineShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the linePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="shape">This parameter is the line shape to be drawn by GeoCannvas.</param>
            <param name="linePen">This parameter describes the GeoPen that will be used to draw the line.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the feature to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawLine(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.ScreenPointF},ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single)">
            <remarks>
            	<para>This method is used to draw a line on the GeoCanvas using the specified GeoPen.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple lines. This is very useful when you want to draw a road, for example. You can
                draw the black background on the lowest level, then draw a slightly thinner white line on a higher
                level. This will result in a great effect for a road.</para>
            </remarks>
            <summary>Draws the LineShape on the GeoCanvas.</summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the lineShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the linePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="screenPoints">This parameter is the LineShape in well-known binary format.</param>
            <param name="linePen">
            This parameter describes the GeoPen that will be used to draw the
            LineShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the feature to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawLineCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.ScreenPointF},ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single)">
            <remarks>
            	<para>This method is used to draw a line on the GeoCanvas using the specified GeoPen.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple lines. This is very useful when you want to draw a road, for example. You can
                draw the black background on the lowest level, then draw a slightly thinner white line on a higher
                level. This will result in a great effect for a road.</para>
            </remarks>
            <summary>Draws the LineShape on the GeoCanvas.</summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the lineShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the linePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="screenPoints">This parameter is the LineShape in well-known binary format.</param>
            <param name="linePen">
            This parameter describes the GeoPen that will be used to draw the
            LineShape.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the feature to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the feature to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>Draws a point on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoPen and the DrawingLevel you want to
            draw on.
            </overloads>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="feature">This parameter is the center point feature.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Core.PointBaseShape,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>Draws a point on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoPen and the DrawingLevel you want to
            draw on.
            </overloads>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="shape">This parameter is the center point shape.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <overloads>
            This overload allows you to pass in the GeoBrush and the DrawingLevel you want to
            draw on.
            </overloads>
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="centerPointFeature">This parameter is the center point feature.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the the GeoBrush will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Core.PointBaseShape,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <overloads>
            This overload allows you to pass in the GeoBrush and the DrawingLevel you want to
            draw on.
            </overloads>
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="shape">This parameter is the center point shape.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the the GeoBrush will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <overloads>
            This overload allows you to pass in the GeoBrush, GeoPen, and the DrawingLevel
            you want to draw on.
            </overloads>
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen and a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="feature">This parameter is the center point feature.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">
            This parameter determines the DrawingLevel that the GeoPen or GeoBrush will draw
            on.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Core.PointBaseShape,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <overloads>
            This overload allows you to pass in the GeoBrush and the DrawingLevel you want to
            draw on.
            </overloads>
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="shape">This parameter is the center point shape.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">
            This parameter determines the DrawingLevel that the GeoPen or GeoBrush will draw
            on.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Core.PenBrushDrawingOrder)">
            <overloads>
            This overload allows you to pass in the GeoBrush and the DrawingLevel you want to
            draw on.
            </overloads>
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="feature">This parameter is the center point feature.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">
            This parameter determines the DrawingLevel that the GeoPen or GeoBrush will draw
            on.
            </param>
            <param name="xOffset"> This parameter determines the X offset for the ellipse to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the ellipse to be drawn.</param>
            <param name="penBrushDrawingOrder"> This parameter determines the PenBrushDrawingOrder used when drawing the ellipse.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Core.PointBaseShape,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Core.PenBrushDrawingOrder)">
            <overloads>
            This overload allows you to pass in the GeoBrush and the DrawingLevel you want to
            draw on.
            </overloads>
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="shape">This parameter is the center point shape.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">
            This parameter determines the DrawingLevel that the GeoPen or GeoBrush will draw
            on.
            </param>
            <param name="xOffset"> This parameter determines the X offset for the ellipse to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the ellipse to be drawn.</param>
            <param name="penBrushDrawingOrder"> This parameter determines the PenBrushDrawingOrder used when drawing the ellipse.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawEllipse(ThinkGeo.MapSuite.Core.ScreenPointF,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Core.PenBrushDrawingOrder)">
            <overloads>
            This overload allows you to pass in the GeoBrush and the DrawingLevel you want to
            draw on.
            </overloads>
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="screenPoint">This parameter is the center point in screen coordinate.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">
            This parameter determines the DrawingLevel that the GeoPen or GeoBrush will draw
            on.
            </param>
            <param name="xOffset"> This parameter determines the X offset for the ellipse to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the ellipse to be drawn.</param>
            <param name="penBrushDrawingOrder"> </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawEllipseCore(ThinkGeo.MapSuite.Core.ScreenPointF,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Core.PenBrushDrawingOrder)">
            <summary>Draws a point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen and a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="screenPoint">This parameter is the center point in well-known binary format.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">
            This parameter determines the DrawingLevel that the GeoPen or GeoBrush will draw
            on.
            </param>
            <param name="xOffset"> This parameter determines the X offset for the screenPoint to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the screenPoint to be drawn.</param>
            <param name="penBrushDrawingOrder">This parameter determines the PenBrushDrawingOrder used when drawing the ellipse.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawWorldImageWithoutScaling(ThinkGeo.MapSuite.Core.GeoImage,System.Double,System.Double,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>Draws an unscaled image on the GeoCanvas.</summary>
            <remarks>
            	<para>Drawing an image unscaled is faster than using the API that scales it.</para>
            	<para>The X &amp; Y in work coordinates is where the center of the image will be
                drawn.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing an invalid image parameter will throw an ArgumentException.</exception>
            <param name="image">The image you want to draw unscaled.</param>
            <param name="centerXInWorld">The X coordinate of the center point of where you want to draw the image.</param>
            <param name="centerYInWorld">The Y coordinate of the center point of where you want to draw the image.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawWorldImageWithoutScaling(ThinkGeo.MapSuite.Core.GeoImage,System.Double,System.Double,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws an unscaled image on the GeoCanvas.</summary>
            <remarks>
            	<para>Drawing an image unscaled is faster than using the API that scales it.</para>
            	<para>The X &amp; Y in work coordinates is where the center of the image will be
                drawn.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing an invalid image parameter will throw an ArgumentException.</exception>
            <param name="image">The image you want to draw unscaled.</param>
            <param name="centerXInWorld">The X coordinate of the center point (in world coordinates) of where you want to draw the image.</param>
            <param name="centerYInWorld">The Y coordinate of the center point (in world coordinates) of where you want to draw the image.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawScreenImageWithoutScaling(ThinkGeo.MapSuite.Core.GeoImage,System.Single,System.Single,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws an unscaled image on the GeoCanvas.</summary>
            <remarks>
            	<para>Drawing an image unscaled is faster than using the API that scales it.</para>
            	<para>The X &amp; Y in work coordinates is where the center of the image will be
                drawn.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing an invalid image parameter will throw an ArgumentException.</exception>
            <param name="image">The image you want to draw unscaled.</param>
            <param name="centerXInScreen">The X coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="centerYInScreen">The Y coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawScreenImageWithoutScalingCore(ThinkGeo.MapSuite.Core.GeoImage,System.Single,System.Single,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws an unscaled image on the GeoCanvas.</summary>
            <remarks>Drawing an image unscaled is faster than using the API that scales it.</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing an invalid image parameter will throw an ArgumentException.</exception>
            <param name="image">The image you want to draw unscaled.</param>
            <param name="centerXInScreen">The X coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="centerYInScreen">The Y coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawWorldImage(ThinkGeo.MapSuite.Core.GeoImage,System.Double,System.Double,System.Single,System.Single,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>Draws a scaled image on the GeoCanvas.</summary>
            <remarks>
            Drawing an image scaled is slower than using the API that draws it
            unscaled.
            </remarks>
            <param name="image">The image you want to draw.</param>
            <param name="centerXInWorld">The X coordinate of the center point of where you want to draw the image.</param>
            <param name="centerYInWorld">The Y coordinate of the center point of where you want to draw the image.</param>
            <param name="widthInScreen">
            The width you want to scale the image to. This is the width of the image that will be
            drawn.
            </param>
            <param name="heightInScreen">
            The height you want to scale the image to. This is the height of the image that will be
            drawn.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a widthInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a heightInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawWorldImage(ThinkGeo.MapSuite.Core.GeoImage,System.Double,System.Double,System.Double,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws a world image on the GeoCanvas.</summary>
            <remarks>
            Drawing an image scaled is slower than using the API that draws it
            unscaled.
            </remarks>
            <param name="image">The image you want to draw.</param>
            <param name="centerXInWorld">The X coordinate of the center point of where you want to draw the image.</param>
            <param name="centerYInWorld">The Y coordinate of the center point of where you want to draw the image.</param>
            <param name="imageScale">
            The scale at which you want to draw the image. The final width and height will be caculated based on the scale.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a widthInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a heightInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawWorldImage(ThinkGeo.MapSuite.Core.GeoImage,System.Double,System.Double,System.Single,System.Single,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws a world image on the GeoCanvas.</summary>
            <remarks>
            Drawing an image scaled is slower than using the API that draws it
            unscaled.
            </remarks>
            <param name="image">The image you want to draw.</param>
            <param name="centerXInWorld">The X coordinate of the center point of where you want to draw the image.</param>
            <param name="centerYInWorld">The Y coordinate of the center point of where you want to draw the image.</param>
            <param name="widthInScreen">
            The width you want to scale the image to. This is the width of the image that will be drawn.
            </param>
            <param name="heightInScreen">
            The height you want to scale the image to. This is the height of the image that will be drawn.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a widthInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a heightInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawScreenImage(ThinkGeo.MapSuite.Core.GeoImage,System.Single,System.Single,System.Single,System.Single,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws a screen image on the GeoCanvas.</summary>
            <remarks>
            Drawing an image scaled is slower than using the API that draws it
            unscaled.
            </remarks>
            <param name="image">The image you want to draw.</param>
            <param name="centerXInScreen">The X coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="centerYInScreen">The Y coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="widthInScreen">
            The width you want to scale the image to. This is the width of the image that will be
            drawn.
            </param>
            <param name="heightInScreen">
            The height you want to scale the image to. This is the height of the image that will be
            drawn.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a widthInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a heightInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawScreenImageCore(ThinkGeo.MapSuite.Core.GeoImage,System.Single,System.Single,System.Single,System.Single,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws a scaled image on the GeoCanvas.</summary>
            <remarks>
            Drawing an image scaled is slower than using the API that draws it
            unscaled.
            </remarks>
            <param name="image">The image you want to draw.</param>
            <param name="centerXInScreen">The X coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="centerYInScreen">The Y coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="widthInScreen">
            The width you want to scale the image to. This is the width of the image that will be
            drawn.
            </param>
            <param name="heightInScreen">
            The height you want to scale the image to. This is the height of the image that will be
            drawn.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a widthInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a heightInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawTextWithScreenCoordinate(System.String,ThinkGeo.MapSuite.Core.GeoFont,ThinkGeo.MapSuite.Core.GeoBrush,System.Single,System.Single,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>
            	<para>This method allows you to draw text at the specified location, using the
                specified brush and font parameters.</para>
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string in the text parameter, we will throw an ArgumentException.</exception>        
            <overloads>This overload allows you to specify the location in screen coordinates.</overloads>
            <remarks>
            	<para>This method is used to draw text on the GeoCanvas at specific screen coordinates. It
                provides you with a number of overloads that allow you to control how the text is drawn. This is
                useful especially when adding things such as legends, titles, etc.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple text items. This is very useful when you want to draw a drop shadow,
                for example. You can draw the black backdrop on the lowest level with an offset, then
                draw the normal text on a higher level without an offset.</para>
            </remarks>
            <param name="text">This parameter specifies the text you wish to draw.</param>
            <param name="font">This parameter represents the font you wish to use to draw the text.</param>
            <param name="fillBrush">
            This parameter specifies the kind of fill you want to use to draw the
            text.
            </param>
            <param name="upperLeftXInScreen">
            This parameter is the upper left horizontal point in screen coordinates of where
            you want to start drawing the text from.
            </param>
            <param name="upperLeftYInScreen">
            This parameter is the upper left vertical point in screen coordinates of where
            you want to start drawing the text from.
            </param>
            <param name="drawingLevel">
            This parameter specifies the drawing level you wish to draw the text on. Higher
            levels overwrite lower levels.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawTextWithWorldCoordinate(System.String,ThinkGeo.MapSuite.Core.GeoFont,ThinkGeo.MapSuite.Core.GeoBrush,System.Double,System.Double,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>
            	<para>This method allows you to draw text at the specified location, using the
                specified brush and font parameters.</para>
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string in the text parameter, we will throw an ArgumentException.</exception>        
            <overloads>This overload allows you to specify the location in world coordinates.</overloads>
            <remarks>
            	<para>This method is used to draw text on the GeoCanvas at specific screen coordinates. It
                provides you with a number of overloads that allow you to control how the text is drawn. This is
                useful especially when adding things such as legends, titles, etc.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple text items. This is very useful when you want to draw a drop shadow,
                for example. You can draw the black backdrop on the lowest level with an offset, then
                draw the normal text on a higher level without an offset.</para>
            </remarks>
            <param name="text">This parameter specifies the text you wish to draw.</param>
            <param name="font">This parameter represents the font you wish to use to draw the text.</param>
            <param name="fillBrush">
            This parameter specifies the kind of fill you want to use to draw the
            text.
            </param>
            <param name="upperLeftXInWorld">
            This parameter is the upper left horizontal point in world coordinates of where
            you want to start drawing the text from.
            </param>
            <param name="upperLeftYInWorld">
            This parameter is the upper left horizontal point in world coordinates of where
            you want to start drawing the text from.
            </param>
            <param name="drawingLevel">
            This parameter specifies the drawing level you wish to draw the text on. Higher
            levels overwrite lower levels.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawText(System.String,ThinkGeo.MapSuite.Core.GeoFont,ThinkGeo.MapSuite.Core.GeoBrush,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.ScreenPointF},ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>
            	<para>This method allows you to draw text at the specified location, using the
                specified brush and font parameters.</para>
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string in the text parameter, we will throw an ArgumentException.</exception>        
            <param name="text">This parameter specifies the text you wish to draw.</param>
            <param name="font">This parameter represents the font you wish to use to draw the text.</param>
            <param name="fillBrush">
            This parameter specifies the kind of fill you want to use to draw the
            text.
            </param>
            <param name="textPathInScreen">This parameter specifies the path on which to draw the text.</param>
            <param name="drawingLevel">
            This parameter specifies the drawing level you wish to draw the text on. Higher
            levels overwrite lower levels.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawText(System.String,ThinkGeo.MapSuite.Core.GeoFont,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.GeoPen,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.ScreenPointF},ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>
            	<para>This method allows you to draw text at the specified location, using the
                specified brush and font parameters.</para>
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string in the text parameter, we will throw an ArgumentException.</exception>        
            <param name="text">This parameter specifies the text you wish to draw.</param>
            <param name="font">This parameter represents the font you wish to use to draw the text.</param>
            <param name="fillBrush">
            This parameter specifies the kind of fill you want to use to draw the
            text.
            </param>
            <param name="haloPen"> This parameter specifies the HaloPen that will be used to draw the text, when the HaloPen effect is needed.</param>
            <param name="textPathInScreen">This parameter specifies the path on which to draw the text.</param>
            <param name="drawingLevel">
            This parameter specifies the drawing level you wish to draw the text on. Higher
            levels overwrite lower levels.
            </param>
            <param name="xOffset"> This parameter determines the X offset for the text to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the text to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the text to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.DrawTextCore(System.String,ThinkGeo.MapSuite.Core.GeoFont,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.GeoPen,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.ScreenPointF},ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>
            	<para>This method allows you to draw text at the specified location, using the
                specified brush and font parameters.</para>
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string in the text parameter, we will throw an ArgumentException.</exception>        
            <remarks>
            	<para>This method is used to draw text on the GeoCanvas.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple text items. This is very useful when you want to draw a drop shadow,
                for example. You can draw the black backdrop on the lowest level with an offset, then
                draw the normal text on a higher level without an offset.</para>
            </remarks>
            <param name="text">This parameter specifies the text you wish to draw.</param>
            <param name="font">This parameter represents the font you wish to use to draw the text.</param>
            <param name="fillBrush"> This parameter specifies the kind of fill you want to use to draw the text.</param>
            <param name="haloPen"> This parameter specifies the HaloPen that will be used to draw the text, when the HaloPen effect is needed.</param>
            <param name="textPathInScreen">This parameter specifies the path on which to draw the text.</param>
            <param name="drawingLevel">
            This parameter specifies the drawing level you wish to draw the text on. Higher
            levels overwrite lower levels.
            </param>
            <param name="xOffset"> This parameter determines the X offset for the text to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the text to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the text to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.MeasureText(System.String,ThinkGeo.MapSuite.Core.GeoFont)">
            <summary>
            This method returns the rectangle that contains the specified text, when that text is drawn
            with the specified font.
            </summary>
            <returns>
            This method returns the rectangle that contains the specified text, when that text is drawn
            with the specified font.
            </returns>
            <remarks>This method is typically used for labeling, to determine whether labels overlap.</remarks>
            <param name="text">This parameter represents the text you want to measure.</param>
            <param name="font">This parameter represents the font of the text you want to measure.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string in the text parameter, we will throw an ArgumentException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.MeasureTextCore(System.String,ThinkGeo.MapSuite.Core.GeoFont)">
            <summary>
            This method returns the rectangle that contains the specified text, when that text is drawn
            with the specified font.
            </summary>
            <remarks>This method is typically used for labeling, to determine whether labels overlap.</remarks>
            <returns>
            This method returns the rectangle that contains the specified text, when that text is drawn
            with the specified font.
            </returns>
            <param name="text">This parameter represents the text you want to measure.</param>
            <param name="font">This parameter represents the font of the text you want to measure.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string in the text parameter, we will throw an ArgumentException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.BeginDrawing(System.Object,ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>This method begins the act of drawing on the GeoCanvas.</summary>
            <remarks>
            This is the first method that needs to be called before any drawing takes place.
            Calling this method will set the IsDrawing property to true. When you finish drawing,
            you must call EndDrawing to commit the changes to the image.
            </remarks>
            <param name="nativeImage">This parameter represents the image you want the GeoCanvas to draw on.</param>
            <param name="worldExtent">This parameter is the world extent of the canvasImage.</param>
            <param name="drawingMapUnit">This parameter is the map unit of the canvasImage.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.BeginDrawingCore(System.Object,ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <remarks>
            This is the first method that needs to be called before any drawing takes place.
            Calling this method will set the IsDrawing property to true. When you finish drawing,
            you must call EndDrawing to commit the changes to the image.
            </remarks>
            <summary>This method begins the act of drawing on the GeoCanvas.</summary>
            <param name="nativeImage">This parameter represents the image you want the GeoCanvas to draw on.</param>
            <param name="worldExtent">This parameter is the world extent of the canvasImage.</param>
            <param name="drawingMapUnit">This parameter is the map unit of the canvasImage.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.ToNativeImage(ThinkGeo.MapSuite.Core.GeoImage)">
            <summary>
            This method converts a GeoImage to a commonly-used object. In GdiPlus, this object is often a Bitmap.
            </summary>
            <remarks>
            This method is a BaseClass API and will be implemented and used in its sub-concrete classes.
            </remarks>
            <param name="image">The target geoImage to convert.</param>
            <returns>The returning object containing the same information as the passed-in geoImage.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.ToNativeImageCore(ThinkGeo.MapSuite.Core.GeoImage)">
            <summary>
            This method converts a GeoImage to a commonly-used object. In GdiPlus, this object is often a Bitmap.
            </summary>
            <remarks>
            This method is a BaseClass API and will be used in its sub-concrete classes.
            </remarks>
            <param name="image">The target geoImage to convert.</param>
            <returns>The returning object containing the same information as the passed-in geoImage.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.ToGeoImage(System.Object)">
            <summary>
            This method converts an oboject to a GeoImage. In GdiPlus, this object is often a Bitmap.
            </summary>
            <remarks>
            This method is a BaseClass API and will be implemented and used in its sub-concrete classes.
            </remarks>
            <param name="nativeImage">The target object to be converted.</param>
            <returns>The returning GeoImage containing the same information as the passed-in nativeImage.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.ToGeoImageCore(System.Object)">
            <summary>
            This method converts an oboject to a GeoImage. In GdiPlus, this object is often a Bitmap.
            </summary>
            <remarks>
            This method is a BaseClass API and will be implemented and used in its sub-concrete classes.
            </remarks>
            <param name="nativeImage">The target object to be converted.</param>
            <returns>The returning GeoImage containing the same information as the passed-in nativeImage.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.EndDrawing">
            <summary>This method ends drawing and commits the drawing on the GeoCanvas.</summary>
            <remarks>
            This method should be called when you are finished drawing. It will commit the
            image changes to the image you passed in on BeginDrawing. It will also set
            IsDrawing to false. After you call this method it will put the GeoCanvas into an
            invalid state, so if you then call any drawing methods it will raise an
            exception.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.GetCanvasWidth(System.Object)">
            <summary>
            This method gets the canvas width of the passed-in native image object.
            </summary>
            <remarks>
            This method is a BaseClass API and will be implemented and used in its sub-concrete classes.
            </remarks>
            <param name="nativeImage">The native image that will be used to get the image width.</param>
            <returns>The returning canvas width.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.GetCanvasWidthCore(System.Object)">
            <summary>
            This method gets the canvas width of the passed-in native image object.
            </summary>
            <remarks>
            This method is a BaseClass API and will be implemented and used in its sub-concrete classes.
            </remarks>
            <param name="nativeImage">The native image that will be used to get the image width.</param>
            <returns>The returning canvas width.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.GetCanvasHeight(System.Object)">
            <summary>
            This method gets the canvas height of the passed-in native image object.
            </summary>
            <remarks>
            This method is a BaseClass API and will be implemented and used in its sub-concrete classes.
            </remarks>
            <param name="nativeImage">The native image that will be used to get the image height.</param>
            <returns>The returning canvas height.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.GetCanvasHeightCore(System.Object)">
            <summary>
            This method gets the canvas height of the passed-in native image object.
            </summary>
            <remarks>
            This method is a BaseClass API and will be implemented and used in its sub-concrete classes.
            </remarks>
            <param name="nativeImage">The native image will be used to get the image height.</param>
            <returns>The returning canvas height.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.EndDrawingCore">
            <summary>This method ends drawing and commits the drawing on the GeoCanvas.</summary>
            <remarks>
            This methods should be called when you are finished drawing. It will commit the
            image changes to the image you passed in on BeginDrawing. It will also set
            IsDrawing to false. After you call this method it will put the GeoCanvas into an
            invalid state, so if you then call any drawing methods it will raise an
            exception.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.GetStreamFromGeoImage(ThinkGeo.MapSuite.Core.GeoImage)">
            <summary>
            Get the stream from the passed-in GeoImage.  This API is an abstract API and will be implemented in each concrete sub-class.
            </summary>
            <param name="image">The parameter specifies the image to get the stream from.</param>
            <returns>The returning stream retrieved from the passed-in image.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.Flush">
            <summary>This method flush drawing and commits the drawing on the GeoCanvas.</summary>
            <remarks>
            This method should be called when you are finished drawing. It will commit the
            image changes to the image you passed in on BeginDrawing. It will also set
            IsDrawing to false. After you call this method it will put the GeoCanvas into an
            invalid state, so if you then call any drawing methods it will raise an
            exception.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoCanvas.FlushCore">
            <summary>This method flush drawing and commits the drawing on the GeoCanvas.</summary>
            <remarks>
            This method should be called when you are finished drawing. It will commit the
            image changes to the image you passed in on BeginDrawing. It will also set
            IsDrawing to false. After you call this method it will put the GeoCanvas into an
            invalid state, so if you then call any drawing methods it will raise an
            exception.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoCanvas.CurrentScale">
            <summary>
            This property gets the current scale of the canvas.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this property when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoCanvas.DrawingQuality">
            <summary>This property returns the drawing quality when rendering on the GeoCanvas.</summary>
            <remarks>
            The DrawingQuality specifies whether BaseLineShapes, BasePointShapes, and
            BaseAreaShapes use anti-aliasing methods or other techniques that control the quality. In
            some cases you may want a higher quality rendering, and in other cases higher speed is
            more desirable. It is up to the implementer of the derived GeoCanvas class to control
            exactly what this setting means.
            </remarks>
            <decimalDegreesValue>This property returns the drawing quality that will be used when rendering on the GeoCanvas.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoCanvas.MapUnit">
            <summary>This property returns the MapUnit passed in on the BeginDrawingAPI in the GeoCanvas.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoCanvas.Width">
            <summary>This property gets the width of the canvas.</summary>
            <decimalDegreesValue>This property gets the width of the canvas.</decimalDegreesValue>
            <remarks>
            This property reflects the width of the canvas image that was passed in on
            BeginDrawing.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoCanvas.Height">
            <summary>This property gets the height of the canvas.</summary>
            <decimalDegreesValue>This property gets the height of the canvas.</decimalDegreesValue>
            <remarks>
            This property reflects the height of the canvas image that was passed in on 
            BeginDrawing.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoCanvas.CurrentWorldExtent">
            <summary>
            This property gets the adjusted current extent based on what was set when
            BeginDrawing was called.
            </summary>
            <remarks>
            The extent that gets passed in on BeginDrawing is adjusted for the height and
            width of the physical media being drawn on. For example if the current extent is wider
            than taller but the bitmap being drawn on is square then the current extent needs to be
            adjusted. The extent will be adjusted larger so that we ensure that the entire original
            extent will still be represented.
            </remarks>
            <decimalDegreesValue>
            This property gets the adjusted current extent based on what was set when
            BeginDrawing was called.
            </decimalDegreesValue>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoCanvas.HasKeyColor">
            <summary>
            This property indicates whether a GeoCanvas has the KeyColor or not. If it has no
            KeyColor, it will throw an exception when you get or set the value of KeyColors property.
            </summary>
            <remarks>The default value is false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoCanvas.KeyColor">
            <summary>
            Gets or sets a value represents a key color. If HasKeyColor property is false, it will throw exception when you use KeyColors.
            </summary>
            <remarks>It will make this color transparent when draw image.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoCanvas.KeyColors">
            <summary>
            Gets a value represents a collection of key colors. If HasKeyColor property is false, it will throw exception when you use KeyColors.
            </summary>
            <remarks>It will make these colors transparent when draw image.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoCanvas.NativeImage">
            <summary>
            The same reference to the parameter 'nativeImage' in BeginDrawing function.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoCanvas.IsDrawing">
            <summary>This property gets the drawing status of the GeoCanvas.</summary>
            <decimalDegreesValue>This property gets the drawing status of the GeoCanvas.</decimalDegreesValue>
            <remarks>
            This property is set to true when the BeginDrawing method is called, and
            false after the EndDrawing method is called.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoCanvas.Dpi">
            <summary>
            The DPI value for the final drawing result, only valid when HasDpi set to true.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DrawingQuality">
            <summary>This enumeration specifies the drawing quality of the GeoCanvas.</summary>
            <remarks>
            This enumeration does not specifically utilize high speed or high quality
            drawing. Those factors are determined by the implementor of the GeoCanvas. Each GeoCanvas can
            accomplish these various items in different ways.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingQuality.Default">
            <summary>The default drawing quality, balanced between speed and quality.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingQuality.HighQuality">
            <summary>The high quality (but low speed) drawing quality.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingQuality.HighSpeed">
            <summary>The low quality (but high speed) drawing quality.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingQuality.CanvasSettings">
            <summary>
            This option indicates that you will change the settings directly on the
            canvas.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DrawingGraphicsUnit">
            <summary>This enumeration represents the graphics unit.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingGraphicsUnit.Display">
            <summary>This represents pixels.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingGraphicsUnit.Inch">
            <summary>This represents inches.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.BuildIndexMode">
            <summary>This enumeration represents whether an index should be rebuilt or not.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.BuildIndexMode.DoNotRebuild">
            <summary>Do not rebuild the index if it exists.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.BuildIndexMode.Rebuild">
            <summary>Rebuild the index if it exists.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ClosedFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the ClosedFeatureSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClosedFeatureSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoWrapMode">
            <summary>
            This enumeration determines how a texture is filled in with a GeoTextureBrush when the
            area to be filled is larger than the texture.
            </summary>
            <remarks>
            This will allow you to achieve a number of different effects. We suggest you try
            them out with your own textures and see which one looks best for your image.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoWrapMode.Tile">
            <summary>The texture is tiled to fill the entire area.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoWrapMode.Clamp">
            <summary>The texture will not be tiled.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoWrapMode.TileFlipX">
            <summary>Reverse the texture horizontally and then tile the texture.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoWrapMode.TileFlipY">
            <summary>Reverse the texture vertically and then tile the texture.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoWrapMode.TileFlipXY">
            <summary>Reverse the texture horizontally and vertically and then tile the texture.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PositionStyle">
            <summary>
            This abstract class encapsulates the labeling position logic. It is inherited
            by other styles, such as the TextSytle.
            </summary>
            <remarks>
            This abstract class is meant to be inherited by other classes and specialized to
            meet the needs of various labelers.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PositionStyle.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PositionStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PositionStyle.GetRequiredColumnNamesCore">
            <remarks>
             This abstract method is called from the concrete public method
             GetRequiredFieldNames. In this method, we return the column names that are required for
             the style to draw the feature properly. For example, if you have a style that colors
             areas blue when a certain column value is over 100, then you need to be sure you include
             that column name. This will ensure that the column data is returned to you in the
             feature when it is ready to draw.<br/>
             	<br/>
             In many of the styles, we add properties to allow the user to specify which field they
             need; then, in the GetRequiredColumnNamesCore, we read that property and add it to the
             collection.
             </remarks>
             <summary>
             This method returns the column data for each feature that is required for the
             style to properly draw.
             </summary>
             <returns>This method returns a collection of the column names that it needs.</returns>
             <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If columnName is null, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PositionStyle.FilterFeatures(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas)">
            <summary>
            This method filters the features based on the grid size to facilitate
            deterministic labeling.
            </summary>
            <returns>This method returns the features that will be considered for labeling.</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method
                FilterFeaturesCore. In this method, we filter the features based on the grid size to
                facilitate deterministic labeling.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="features">This parameter represents the features that will be filtered.</param>
            <param name="canvas">This parameter is the canvas that will be used for calculating font sizes.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PositionStyle.FilterFeaturesCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas)">
            <summary>
            This method filters the features based on the grid size to facilitate
            deterministic labeling.
            </summary>
            <returns>This method returns the features that will be considered for labeling.</returns>
            <remarks>
            This overridden method is called from the concrete public method FilterFeatures.
            In this method, we filter the features based on the grid size to facilitate
            deterministic labeling.
            </remarks>
            <param name="features">This parameter represents the features that will be filtered.</param>
            <param name="canvas">This parameter is the canvas that will be used for calculating font sizes.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PositionStyle.GetLabelingCandidates(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeoCanvas)">
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method
                GetLabelingCanidatesCore. This method determines if the feature passed in is a good
                candidate to be labeled based on the labeling properties set.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <returns>A collection of labeling candidates.</returns>
            <summary>
            This method determines whether the specified feature is a good candidate to be labeled,
            based on the labeling properties set.
            </summary>
            <param name="feature">
            This parameter is the feature that will be considered as a labeling
            candidate.
            </param>
            <param name="canvas">
            This parameter is the canvas that will be used to draw the feature. This method will not
            draw on this canvas, but rather will use it to determine font size, etc.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PositionStyle.GetLabelingCandidateCore(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeoCanvas)">
            <remarks>
            This overridden method is called from the concrete public method
            GetLabelingCanidate. In this method, we take the feature you passed in and determine if
            it is a candidate for labeling. If it is, then we will add it to the return collection.
            The algorithm to determine whether the label will draw is complex and determined by a number
            of properties and factors.
            </remarks>
            <summary>
            This method determines whether the specified feature is a good candidate to be labeled,
            based on the labeling properties set.
            </summary>
            <returns>A collection of labeling candidates.</returns>
            <param name="feature">
            This parameter is the feature that will be considered as a labeling
            candidate.
            </param>
            <param name="canvas">
            This parameter is the canvas that will be used to draw the feature. This method will not
            draw on this canvas, but rather will use it to determine font size, etc.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PositionStyle.CheckDuplicate(ThinkGeo.MapSuite.Core.LabelingCandidate,ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>
            This method will determine whether the label will be suppressed because it is a
            duplicate.
            </summary>
            <returns>This method returns whether the label will be suppressed as a duplicate.</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method
                CheckDuplicateCore. This method will determine if the label will be suppressed
                because it is a duplicate. It also takes into consideration the duplicate rules
                for the class. So, for example, if we set to allow duplicates, then the method will
                always return false. If the class is set to not allow duplicates and this label is
                a duplicate, then it will return true and be suppressed.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="labelingCandidate">
            This parameter is the labeling candidate that will be checked to determine if it is a
            duplicate.
            </param>
            <param name="canvas">This parameter is the canvas used for calculations.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PositionStyle.CheckDuplicateCore(ThinkGeo.MapSuite.Core.LabelingCandidate,ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <remarks>
            This overridden method is called from the concrete public method CheckDuplicate.
            This method will determine if the label will be suppressed
            because it is a duplicate. It also takes into consideration the duplicate rules
            for the class. So, for example, if we set to allow duplicates, then the method will
            always return false. If the class is set to not allow duplicates and this label is
            a duplicate, then it will return true and be suppressed.
            </remarks>
            <returns>This method returns whether the label will be suppressed as a duplicate.</returns>
            <summary>
            This method will determine if the label will be suppressed because it is a
            duplicate.
            </summary>
            <param name="labelingCandidate">
            This parameter is the labeling candidate that will be checked to determine if it is a
            duplicate.
            </param>
            <param name="canvas">This parameter is the canvas that will be used for calculations.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PositionStyle.CheckOverlapping(ThinkGeo.MapSuite.Core.LabelingCandidate,ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>
            This method will determine if the label will be suppressed because of
            overlapping.
            </summary>
            <returns>This method returns whether the label will be suppressed because of overlapping.</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method
                CheckOverlappingCore. This method will determine if the label will be suppressed
                because it is overlapping another label. It also takes into consideration the
                overlapping rules for the class. So, for example, if we set to allow overlap, then the
                method will always return false. If the class is set to not allow overlap and
                this label is overlapping, then it will return true and be suppressed.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <param name="labelingCandidate">
            This parameter is the labeling candidate that will be checked to determine if it is
            overlapping.
            </param>
            <param name="canvas">This parameter is the canvas that will be used for calculations.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PositionStyle.CheckOverlappingCore(ThinkGeo.MapSuite.Core.LabelingCandidate,ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>
            This method will determine whether the label will be suppressed because of
            overlapping.
            </summary>
            <returns>This method returns whether the label will be suppressed because of overlapping.</returns>
            <remarks>
            This overridden method is called from the concrete public method
            CheckOverlapping. This method will determine if the label will be suppressed
            because it is overlapping another label. It also takes into consideration the
            overlapping rules for the class. So, for example, if we set to allow overlap, then the
            method will always return false. If the class is set to not allow overlap and
            this label is overlapping, then it will return true and be suppressed.
            </remarks>
            <param name="labelingCandidate">This parameter is the labeling candidate that will be checked to determine if it is overlapping.</param>
            <param name="canvas">This parameter is the canvas that will be used for calculations.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PositionStyle.ConvertToScreenShape(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeoCanvas)">
            <remarks>
            This overridden method can be called by this class and its sub concrete classes.
            In this method, we take the canvas and the feature in world coordinates and convert it to 
            screen coordinates.
            </remarks>
            <summary>
            This method converts a feature in world coordinates to screen coordinates.
            </summary>
            <returns>A screen coordinate shape.</returns>
            <param name="feature">
            This parameter is the feature to be converted from world coordinates.
            </param>
            <param name="canvas">
            This parameter is the canvas that will be used to convert the world coordinate feature to a screen coorindate feature.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.LabelPositions">
            <summary>
            Gets a value represents a keyValuepair which is a feature id and label position of the feature
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.XOffsetInPixel">
            <summary>This property gets and sets the X pixel offset used for drawing each feature.</summary>
            <value>This property gets the X pixel offset used for drawing each feature.</value>
            <remarks>
            This property allows you to specify an X offset. When combined with a Y offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.YOffsetInPixel">
            <summary>This property gets and sets the Y pixel offset used for drawing each feature.</summary>
            <value>This property gets the Y pixel offset used for drawing each feature.</value>
            <remarks>
            This property allows you to specify a Y offset. When combined with an X offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.GridSize">
            <summary>
            This property gets and sets the grid size used for deterministic
            labeling.
            </summary>
            <value>This property gets the grid sized used for deterministic labeling.</value>
            <remarks>
            The grid size determines how many labels will be considered as candidates for drawing. The
            smaller the grid size, the higher the density of candidates. Making the grid size too small
            may have a performance impact.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.CustomTextStyles">
            <summary>
            This property returns a collection of area styles, allowing you to stack multiple
            area styles on top of each other.
            </summary>
            <value>This property returns a collection of area styles.</value>
            <remarks>
            Using this collection you can stack multiple area styles on top of each other.
            When we draw the feature we will draw them in order in the collection. You can use
            these stacks to create drop shadow effects along with multiple colored outlines
            etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.RotationAngle">
            <summary>
            This property gets and sets the rotation angle of the item being
            positioned.
            </summary>
            <value>This property gets the rotation angle of the item being positioned.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.Format">
            <summary>This property gets and sets the format that will be applied to the text.</summary>
            <value>This property gets the format that will be applied to the text.</value>
            <remarks>
            With this property, you can apply formats to the text that is retrieved from the
            feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.FittingLineInScreen">
            <summary>
            This property gets and sets whether the labeler will try to fit the label as best as it
            can on the visible part of a line on the screen.
            </summary>
            <value>
            This property gets whether the labeler will try to fit the label as best as it can on
            the visible part of a line on the screen.         
            </value>
            <remarks>
            A label will normally be displayed in the center of a line. If only a small piece
            of the line is visible on the screen, we cannot see it's label by default. If we set this
            property to ture though, the label will be displayed in the center of that piece in screen.
             </remarks> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.TextFormat">
            <summary>This property gets and sets the format that will be applied to the text.</summary>
            <value>This property gets the format that will be applied to the text.</value>
            <remarks>
            With this property, you can apply formats to the text that is retrieved from the
            feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.NumericFormat">
            <summary>This property gets and sets the format that will be applied to the text which can be parsed to double type.</summary>
            <value>This property gets the format that will be applied to the text which can be parsed to double type..</value>
            <remarks>
            With this property, you can apply formats to the text that is retrieved from the
            feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.DateFormat">
            <summary>This property gets and sets the format that will be applied to the text which can be parsed to DateTime type.</summary>
            <value>This property gets the format that will be applied to the text which can be parsed to DateTime type..</value>
            <remarks>
            With this property, you can apply formats to the text that is retrieved from the
            feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.TextSolidBrush">
            <summary>
            This property gets and sets the SolidBrush that will be used to draw the
            text.
            </summary>
            <value>This property gets the SolidBrush that will be used to draw the text.</value>
            <remarks>
            You can use this property to draw a solid color; however, if you need to use other
            brushes, you can access them through the Advanced property of this class.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.Font">
            <summary>This property gets and sets the font that will be used to draw the text.</summary>
            <value>This property gets the font that will be used to draw the text.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.HaloPen">
            <summary>
            This property gets and sets the halo pen you may use to draw a halo around the
            text.
            </summary>
            <value>
            This property gets the halo pen you may use to draw a halo around the
            text.
            </value>
            <remarks>
            The halo pen allows you to draw a halo effect around the text, making it stand out
            more on a busy background.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.TextColumnName">
            <summary>
            This property gets and sets the column name in the data that you want to get the text from.
            </summary>
            <value>
            This property gets the column name in the data that you want to get the text from.
            </value>
            <remarks>
            This property is used when retrieving text from a feature. You will want to
            specify the name of the column that contains the text you want to draw.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.Mask">
            <summary>
            This property gets and sets the AreaStyle used to draw a mask behind the
            text.
            </summary>
            <value>This property gets the AreaStyle used to draw a mask behind the text.</value>
            <remarks>
            A mask is a plate behind the text that is rectangular and slightly larger than
            the width and height of the text. It allows the label to stand out well on a busy
            background. You can also try the HaloPen property instead of the mask, if the mask effect is
            too pronounced.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.MaskMargin">
            <summary>This property gets and sets the margin around the text that will be used for the mask.</summary>
            <value>This property gets the margin around the text that will be used for the mask.</value>
            <remarks>This determines how much larger the mask is than the text, in pixels.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.Advanced">
            <summary>This property gets the advanced properties of the class.</summary>
            <value>This property gets the advanced properties of the class.</value>
            <remarks>
            The advanced properties have been consolidated in the Advanced property. This way,
            the standard options are more easily visible and the advanced options are hidden
            away.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.DuplicateRule">
            <summary>
            This property gets and sets the rule that determines how duplicate labels are
            handled.
            </summary>
            <value>
            This property gets the rule that determines how duplicate labels are
            handled.
            </value>
            <remarks>
            There are three ways to handle duplicate label names. The first is to suppress
            all duplicates, which means if there are two street segments with the same name then
            only one will be drawn. The second way is to suppress duplicate labels only if they are
            in one quarter of the screen. In this way, the screen will be divided into four
            quadrants, and if the two duplicate labels are in different quadrants, then they will both
            draw. The last way is to draw all duplicates.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.OverlappingRule">
            <summary>
            This property gets and sets the rule that determines how overlapping labels are
            handled.
            </summary>
            <value>This property gets the rule that determines overlapping labels are handled.</value>
            <remarks>
            This defines the rules for label overlapping. Currently, either we allow overlapping or we
            do not. In the future, we may extend this to allow some percentage of partial
            overlapping.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.AllowSpline">
            <summary>
            This property gets and sets whether line labels are allowed to spline around curved
            lines.
            </summary>
            <value>
            This property gets whether line labels are allowed to spline around curved
            lines.
            </value>
            <remarks>
            This property will allow the labeler to spline the label around curved lines.
            This is useful for curved streets that need to be labeled. This can have a considerable
            performance impact, so we suggest you experiment with it to ensure it can meet your
            needs.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.AllowLineCarriage">
            <summary>
            This property gets and sets whether the labeler will allow carriage returns to be
            inserted.
            </summary>
            <value>
            This property gets whether the labeler will allow carriage returns to be
            inserted.
            </value>
            <remarks>
            This property enables the labeler to split long labels into multiple lines if need be.
            For instance, if you have a lake whose name is "Southern Homestead Lake," then the labeler
            may try and break the name onto multiple lines in order to better label the feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.SuppressPartialLabels">
            <summary>
            This property gets and sets whether a partial label in the current extent will be drawn or not.
            </summary>
            <remarks>This property provides a solution to the "cut off" label issue in Map Suite Web Edition and Desktop Edition, which occurs when multiple
            tiles exist. When you set this property to true, any labels outside of the current extent will not be drawn.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.ForceLineCarriage">
            <remarks>
            This property forces the labeler to split long labels into multiple lines. For instance,
            if you have a lake whose name is "Southern Homestead Lake," then the labeler will break
            the name onto multiple lines in order to better label the feature.
            </remarks>
            <summary>
            This property gets and sets whether the labeler will force carriage returns to be
            inserted.
            </summary>
            <value>
            This property gets whether the labeler will force carriage returns to be
            inserted.
            </value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.FittingPolygon">
            <summary>
            This property gets and sets whether the labeler will try to fit the label as best as
            it can within the boundary of a polygon.
            </summary>
            <value>
            This property gets whether the labeler will try to fit the label as best as
            it can within the boundary of a polygon.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.LabelAllPolygonParts">
            <summary>
            This property gets and sets whether the labeler will label every part of a multi-part
            polygon.
            </summary>
            <value>
            This property gets whether the labeler will label every part of a multi-part
            polygon.
            </value>
            <remarks>
            In some cases, you may want to label all of the parts of a multi-part polygon, while in
            other cases you may not. For example, you may have a series of lakes where you do want to
            label each polygon. In another case, you may have a country with many small islands and
            in this case you only want to label the largest polygon.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.ForceHorizontalLabelForLine">
            <summary>This property gets and sets whether we should force horizontal labeling for lines.</summary>
            <value>This property gets whether we should force horizontal labeling for lines.</value>
            <remarks>
            Normally, lines are labeled in the direction of the line. There may be some cases,
            however, when you want to have the line labeled horizontally regardless of the line's direction.
            In such a case, you can set this property to force the lines to be labeled horizontally.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.FittingPolygonFactor">
            <summary>
            This property gets and sets the factor to which it will keep the label inside of
            the polygon.
            </summary>
            <value>
            This property gets the factor to which it will keep the label inside of the
            polygon.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.TextLineSegmentRatio">
            <summary>
            This property gets and sets the ratio required for the label length to match the
            line length.
            </summary>
            <value>
            This property gets the ratio required for the label length to match the line
            length.
            </value>
            <remarks>
            This allows you to suppress labels where the label length would greatly exceed
            the line length. For example, if you set the ratio to 1, then the label will be
            suppressed if it is longer than the line. If the ratio is lower, then the label would
            need to be shorter than the line. If higher, then the label is allowed to run past the
            length of the line. This allows you to control the look of things like road labeling.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.BestPlacement">
            <summary>
            This property gets and sets whether the labeler will attempt to change the label
            position to avoid overlapping for point-based features.
            </summary>
            <value>
            This property gets whether the labeler will attempt to change the label position to
            avoid overlapping for point-based features.
            </value>
            <remarks>
            The positioning of point labels is mainly determined by the PointPlacement
            property. This allows you place the text to the right, top, bottom, etc. of the point. In
            some cases, placing the text in a certain place will cause many labels to be suppressed
            when the points are dense. This property allows you to override the PointPlacement
            property and allow the labeler to try other locations, if the default location would
            cause the label to be suppressed.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.PointPlacement">
            <summary>
            This property gets and sets the location of the label for point features relative
            to the point.
            </summary>
            <value>
            This property gets the location of the label for point features relative to the
            point.
            </value>
            <remarks>
            This property allows you to choose where the labels are created relative to the
            point. For example, you can set the property to RightCenter, which would ensure that all
            labels are placed to the right of and vertically centered with the point. Different kinds of point layers
            can be positioned differently. If the point layer is dense and position is not a main
            concern, then you can try the BestPlacement property. That property overrides this
            property and tries to fit the label in the best location so that the minimum number of
            labels are suppressed due to overlapping issues.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.SplineType">
            <summary>
            Gets or sets the SplineType for labeling.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PositionStyle.DrawingLevel">
            <summary>
            Gets or sets the DrawingLavel for this style.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ScaleLineAdornmentLayer">
            <summary>
            The <strong>ScaleLineAdornmentLayer</strong> is a concrete class inherited from
            <strong>AdornmentLayer</strong>. The <strong>ScaleLineAdornmentLayer</strong> class
            allows you show a ScaleLine graphic on the map.
            </summary>
            <remarks>
            The <strong>ScaleLineAdornmentLayer</strong> of the map is a quick way to
            implement a ScaleLine. When doing this, we also have to add a
            <strong>ScaleLineAdornmentLayer</strong> to the map control.
            </remarks>
            <example>
            	<code lang="CS" title="C# sample" description="The example below shows how to add a ScaleLineAdornmentLayer to MapEngine.">
            		<![CDATA[
            ScaleLineAdornmentLayer scaleLineAdornmentLayer = new ScaleLineAdornmentLayer();
            mapEngine.AdornmentLayers.Add("ScaleLineAdornmentLayer", scaleLineAdornmentLayer);]]>
            	</code>
            	<code lang="VB" title="VB sample" description="The example below shows how to add a ScalelineAdornmentLayer to MapEngine.">
            		<![CDATA[
            Dim scaleLineAdornmentLayer As New ScaleLineAdornmentLayer() 
            mapEngine.AdornmentLayers.Add("ScaleLineAdornmentLayer", scaleLineAdornmentLayer)]]>
            	</code>
            </example>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.AdornmentLayer">
            <summary>
            This is the base class of AdornmentLayers. The <strong>AdornmentLayer</strong> is
            used to place adornments on the map. Two types of AdornmentLayers are provided:
            <strong>ScaleLineAdornmentLayer</strong> and
            <strong>ScaleBarAdornmentLayer</strong>.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Layer">
            <summary>This class is the base class for all types of Layers.</summary>
            <remarks>
            The Layer class is where all other types of layers are inherited from. It
            provides the base set of functionality. Though all Layers inherit from this class, we
            strongly suggest if you decide to create your own layer type that you consider
            inheriting from the higher level RasterLayer for image-based layers and FeatureLayer for
            feature-based layers. They provide a rich set of default operations for the various
            types of layers and are simple to inherit from.<br/>
            	<br/>
            As it is abstract, there are a number of methods you need to implement. The first is
            DrawCore. In this method, you are responsible for drawing the layer's representation.
            The other two required methods are OpenCore and CloseCore. These open and close the Layer. In
            the Open, you are responsible for getting the layer ready for drawing. You should open
            any file references, etc. In the Close, you need to clean up all file handles, close
            other objects etc. It is important that the Close puts the class in a state where it can
            be re-opened in the future. It is different than Dispose, as closed Layers will still
            exist and can be re-opened later in the mapping life cycle. Many methods (in the layer
            and in higher level objects) will require that the Layer be open before these methods
            are called, otherwise they will throw an exception.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Layer.#ctor">
            <summary>This is the default constructor for the Layer.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Layer.CloneDeep">
            <summary>Create a copy of Layer using the deep clone process.</summary>
            <returns>A cloned Layer.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Layer.CloneDeepCore">
            <summary>Create a copy of Layer using the deep clone process. The default implemenation uses serialization.</summary>
            <returns>A cloned Layer.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Layer.Open">
            <summary>This method opens the Layer so that it is initialized and ready to use.</summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method OpenCore. The
                open method plays an important role, as it is responsible for initializing the Layer.
                Most methods on the Layer will throw an exception if the state of the Layer is not
                opened. When the map draws each layer, the layer will be opened as one of its first steps;
                then, after it is finished drawing with that layer, it will close it. In this way, we
                are sure to release all resources used by the Layer.<br/>
            		<br/>
                When implementing the abstract method, consider opening the FeatureSource or
                RasterSource. You will get a chance to close these in the Close method of the
                Layer.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Layer.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a Layer which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method opens the Layer so that it is initialized and ready to use.</summary>
            <remarks>
            This abstract method is called from the concrete public method Open. The
            open method plays an important role, as it is responsible for initializing the Layer.
            Most methods on the Layer will throw an exception if the state of the Layer is not
            opened. When the map draws each layer, the layer will be opened as one of its first steps;
            then, after it is finished drawing with that layer, it will close it. In this way, we
            are sure to release all resources used by the Layer.<br/>
            <br/>
            When implementing the abstract method, consider opening the FeatureSource or
            RasterSource. You will get a chance to close these in the Close method of the
            Layer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Layer.Close">
            <remarks>
            This method is the concrete wrapper for the abstract method CloseCore. The close
            method plays an important role in the life cycle of the Layer. It may be called after
            drawing to release any memory and other resources that were allocated since the Open
            method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed Layer is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>This method closes the Layer and releases any resources it was using.</summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Layer.CloseCore">
            <summary>
            This method closes the Layer and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This abstract method is called from the concrete public method Close. The close
            method plays an important role in the life cycle of the Layer. It may be called after
            drawing to release any memory and other resources that were allocated since the Open
            method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed Layer is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Layer.GetBoundingBox">
            <summary>This method returns the bounding box of the Layer.</summary>
            <returns>This method returns the bounding box of the Layer.</returns>
            <remarks>
            This method is the concrete wrapper for the abstract method GetBoundingBoxCore.
            This method returns the bounding box of the RasterLayer.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Layer.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a layer which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the Layer.</summary>
            <returns>This method returns the bounding box of the Layer.</returns>
            <remarks>This method returns the bounding box of the Layer.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Layer.Draw(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the Layer.</summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method DrawCore. This
                method draws the representation of the layer based on the extent you provided.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the worldExtent, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the geoImageOrNativeImage, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the labeledInLayers, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a mapUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter represents the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Layer.DrawException(ThinkGeo.MapSuite.Core.GeoCanvas,System.Exception)">
            <summary>
            This method will draw on the canvas when the layer.Draw throw exception and 
            the DrawExceptionMode is set to DrawException instead of ThrowException.
            </summary>
            <param name="canvas">The target canvas to draw the layer.</param>
            <param name="e">The exception thrown when layer.Draw().</param>
            <remarks>This method can be overriden its logic by rewrite the DrawExceptionCore.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Layer.DrawExceptionCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Exception)">
            <summary>
            This method will draw on the canvas when the layer.Draw throw exception and 
            the DrawExceptionMode is set to DrawException instead of ThrowException.
            </summary>
            <param name="canvas">The target canvas to draw the layer.</param>
            <param name="e">The exception thrown when layer.Draw().</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Layer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the Layer.</summary>
            <remarks>
            This method is the concrete wrapper for the abstract method DrawCore. This
                method draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties that
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter represents the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Layer.IsOpen">
            <summary>This property returns true if the Layer is open and false if it is not.</summary>
            <decimalDegreesValue>This property returns true if the Layer is open and false if it is not.</decimalDegreesValue>
            <remarks>
            This method is the concrete wrapper for the abstract method IsOpenCore. Various
            methods on the Layer require that it be in an open state. If one of those methods is
            called when the state is not open, then the method will throw an exception. To enter the
            open state, you must call the Layer Open method. The method will raise an exception if
            the current Layer is already open.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Layer.HasBoundingBox">
            <summary>
            This property indicates whether a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs.
            </summary>
            <remarks>The default value is false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Layer.IsOpenCore">
            <summary>This property returns true if the Layer is open and false if it is not.</summary>
            <decimalDegreesValue>This property returns true if the Layer is open and false if it is not.</decimalDegreesValue>
            <remarks>
            Various methods on the Layer require that it be in an open state. If one of those
            methods is called when the state is not open, then the method will throw an exception.
            To enter the open state, you must call the Layer Open method. The method will raise an
            exception if the current Layer is already open.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Layer.DrawingTime">
            <summary>This property gets the last drawing time for the layer.</summary>
            <decimalDegreesValue>This property gets the last drawing time for the layer.</decimalDegreesValue>
            <remarks>
            We track the drawing time for the layer and report it back in this method. This
            is useful for determining the speed of various layers.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Layer.Name">
            <summary>This property gets and sets the name for the layer.</summary>
            <decimalDegreesValue>This property gets the name for the layer.</decimalDegreesValue>
            <remarks>
            The name is user defined. It is useful to set, as it may be used for higher level
            components such as legends, etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Layer.IsVisible">
            <summary>This property gets and set the visible state of the layer.</summary>
            <decimalDegreesValue>This property gets the visible state of the layer.</decimalDegreesValue>
            <remarks>
            If this property is set to false, the layer will not draw. We ensure this in the
            Draw method. This is useful for legends and other controls that control the visibility
            of layers.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Layer.DrawingExceptionMode">
            <summary>
            Gets or sets the DrawExcpetionMode when exception happens.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AdornmentLayer.#ctor">
            <summary>This method is the default constructor for the AdornmentLayer.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AdornmentLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the AdornmentLayer.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. This method
            draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            You can use the full power of the GeoCanvas to do the drawing.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the geoCanvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the labelsInAllLayers, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a mapUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="labelsInAllLayers">This parameter represents the labels used for collision detection and duplication checking.</param>
            <param name="canvas">This parameter is the canvas object (or a GeoImage) to draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AdornmentLayer.GetDrawingLocation(ThinkGeo.MapSuite.Core.GeoCanvas,System.Single,System.Single)">
            <summary>This method returns the drawing location of the AdornmentLayer.</summary>
            <returns>
            It returns the upper left screen point of where the AdornmentLayer will be
            drawn.
            </returns>
            <param name="canvas">This parameter is the canvas used in drawing.</param>
            <param name="adornmentWidth">This parameter is the width of the adornment.</param>
            <param name="adornmentHeight">This parameter is the height of the adornment</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AdornmentLayer.Location">
            <summary>This property gets and sets the drawing location of the AdornmentLayer.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AdornmentLayer.XOffsetInPixel">
            <summary>This property gets and sets the X pixel offset for the AdornmentLayer.</summary>
            <remarks>
            This property allows you to specify an X offset. It is useful, when combined with
            a Y offset, to do things like modify the location of the
            adornment.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AdornmentLayer.YOffsetInPixel">
            <summary>This property gets and sets the Y pixel offset for the AdornmentLayer.</summary>
            <remarks>
            This property allows you to specify a Y offset. It is useful, when combined with
            an X offset, to do things like modify the location of the
            adornment.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ScaleLineAdornmentLayer.#ctor">
            <summary>
            Creates a new instance of the <strong>ScaleLineAdornmentLayer</strong> class. The
            default location of this <strong>ScaleLineAdornmentLayer</strong> is the lower left corner of
            the CurrentExtent of the map.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ScaleLineAdornmentLayer.#ctor(ThinkGeo.MapSuite.Core.ScreenPointF)">
            <summary>
            Creates a new instance of the <strong>ScaleLineAdornmentLayer</strong> class by
            passing in the specified ScreenPoint, which will be the start position of this
            <strong>ScaleLineAdornmentLayer</strong> when it is shown on the map.
            </summary>
            <param name="startPoint">The start position of the ScaleLineAdornmentLayer that will be shown on the Map.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ScaleLineAdornmentLayer.#ctor(ThinkGeo.MapSuite.Core.AdornmentLocation)">
            <summary>
            Creates a new instance of the <strong>ScaleLineAdornmentLayer</strong> class by
            passing in the specified enumeration of the <strong>AdornmentLocation</strong> that will be used
            to set the start position of this <strong>ScaleLineAdornmentLayer</strong> when it is shown on the
            map.
            </summary>
            <param name="location">
            This parameter specifies the location of the start point of the
            ScaleLineAdornmentLayer.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ScaleLineAdornmentLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the Layer.</summary>
            <remarks>
            This abstract method is called from the concrete public method Draw. This
            method draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties to
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter represents the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ScaleLineAdornmentLayer.DisplayUnitString">
            <summary>
            This propery is a dictionary that exposes what text will be drawn to represent the ScaleLine
            Unit.
            </summary>
            <remarks>
            We will display different letters for different units of measure; for example: "m"
            for meters, "ft" for feet, etc.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GoogleMapZoomLevelSet">
            <summary>This class represents the zoom levels used by Google Maps.</summary>
            <returns>None</returns>
            <remarks>
            If you want to create some layers that match up with Google Maps layers, you
            should use this ZoomSet.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ZoomLevelSet">
            <summary>This class represents a collection of ZoomLevels.</summary>
            <remarks>
            This class represents a collection of ZoomLevels. Each ZoomLevel has a different
            scale and can store Styles that determine how InternalFeatures draw.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ZoomLevelSet.#ctor">
            <summary>This is the default constructor.</summary>
            <returns>None</returns>
            <remarks>
            This constructor is where we set the default scales for each ZoomLevel. If you
            inherit from this class to create your own custom ZoomSet, then you should not call the
            base constructor if you want to supply your own custom ZoomLevels.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ZoomLevelSet.GetZoomLevel(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the active ZoomLevel based on an extent, a map unit and a screen
            width.
            </summary>
            <returns>
            This method returns the active ZoomLevel based on an extent, a map unit and a screen
            width.
            </returns>
            <param name="extent">This parameter is a world extent.</param>
            <param name="screenWidth">This parameter is the width of the map in pixels.</param>
            <param name="mapUnit">This parameter is the unit of the map.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ZoomLevelSet.GetZoomLevel(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,System.Single)">
            <summary>
            This method returns the active ZoomLevel based on an extent, a map unit and a screen
            width.
            </summary>
            <returns>
            This method returns the active ZoomLevel based on an extent, a map unit and a screen
            width.
            </returns>
            <param name="extent">This parameter is a world extent.</param>
            <param name="screenWidth">This parameter is the width of the map in pixels.</param>
            <param name="mapUnit">This parameter is the unit of the map.</param>
            <param name="dpi">This parameter is the dpi of the extent.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ZoomLevelSet.GetZoomLevelForDrawing(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,System.Single)">
            <summary>
            This method returns the active ZoomLevel based on an extent, a map unit and a canvas
            width.
            </summary>
            <returns>
            This method returns the active ZoomLevel based on an extent, map unit and a canvas
            width.
            </returns>
            <param name="extent">This parameter is a world extent.</param>
            <param name="screenWidth">This parameter is the width of the canvas in pixels.</param>
            <param name="mapUnit">This parameter is the unit of the map.</param>
            <param name="dpi">This parameter is the dpi of the extent.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ZoomLevelSet.GetZoomLevelForDrawing(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the active ZoomLevel based on an extent, a map unit and a canvas
            width.
            </summary>
            <returns>
            This method returns the active ZoomLevel based on an extent, map unit and a canvas
            width.
            </returns>
            <param name="extent">This parameter is a world extent.</param>
            <param name="screenWidth">This parameter is the width of the canvas in pixels.</param>
            <param name="mapUnit">This parameter is the unit of the map.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ZoomLevelSet.GetZoomLevels">
            <summary>This method return all of the zoomLevels in the zoomLevelSet.</summary>
            <returns>This method return all of the zoomlevels in the zoomLevelSet.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ZoomLevelSet.GetLowerZoomLevelScale(System.Double,ThinkGeo.MapSuite.Core.ZoomLevelSet)">
            <summary>
            ZoomToScale in, the result is less than input
            </summary>
            <param name="currentScale"></param>
            <param name="zoomLevelSet"></param>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ZoomLevelSet.GetHigherZoomLevelScale(System.Double,ThinkGeo.MapSuite.Core.ZoomLevelSet)">
            <summary>
            ZoomToScale out, the result is greater than input
            </summary>
            <param name="currentScale"></param>
            <param name="zoomLevelSet"></param>
            <returns></returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.Name">
            <summary>This property gets and sets the name for the ZoomSet.</summary>
            <decimalDegreesValue>This property gets the name for the ZoomSet.</decimalDegreesValue>
            <remarks>
            The name is user defined. It is useful to set, as it may be used for higher level
            components such as legends, etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.CustomZoomLevels">
            <summary>This property gets the custom zoom levels from the zoomLevelSet.</summary>
            <remarks>None</remarks>
            <value>This property gets the custom zoom levels from the zoomLevelSet.</value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel01">
            <summary>This property gets the ZoomLevel for Level01.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level01.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel02">
            <summary>This property gets the ZoomLevel for Level02.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level02.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel03">
            <summary>This property gets the ZoomLevel for Level03.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level03.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel04">
            <summary>This property gets the ZoomLevel for Level04.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level04.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel05">
            <summary>This property gets the ZoomLevel for Level05.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level05.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel06">
            <summary>This property gets the ZoomLevel for Level06.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level06.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel07">
            <summary>This property gets the ZoomLevel for Level07.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level07.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel08">
            <summary>This property gets the ZoomLevel for Level08.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level08.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel09">
            <summary>This property gets the ZoomLevel for Level09.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level09.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel10">
            <summary>This property gets the ZoomLevel for Level10.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level10.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel11">
            <summary>This property gets the ZoomLevel for Level11.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level11.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel12">
            <summary>This property gets the ZoomLevel for Level12.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level12.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel13">
            <summary>This property gets the ZoomLevel for Level13.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level13.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel14">
            <summary>This property gets the ZoomLevel for Level14.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level14.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel15">
            <summary>This property gets the ZoomLevel for Level15.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level15.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel16">
            <summary>This property gets the ZoomLevel for Level16.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level16.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel17">
            <summary>This property gets the ZoomLevel for Level17.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level17.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel18">
            <summary>This property gets the ZoomLevel for Level18.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level18.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel19">
            <summary>This property gets the ZoomLevel for Level19.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level19.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevelSet.ZoomLevel20">
            <summary>This property gets the ZoomLevel for Level20.</summary>
            <decimalDegreesValue>This property gets the ZoomLevel for Level20.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GoogleMapZoomLevelSet.#ctor">
            <summary>This class represents the zoom levels used by Google Maps.</summary>
            <returns>None</returns>
            <remarks>
            If you want to create some layers that match up with Google Maps layers, you
            should use this ZoomSet.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GoogleMapsMapType">
            <summary>This enumeration specifies the map types available from Google Maps.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GoogleMapsMapType.RoadMap">
            <summary>Specifies that the Google map displays a normal street map.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GoogleMapsMapType.Mobile">
            <summary>Specifies that the Google map displays a mobile map.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GoogleMapsMapType.Satellite">
            <summary>Specifies that the Google map displays satellite images.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GoogleMapsMapType.Terrain">
            <summary>
            Specifies that the Google map displays a transparent layer of major
            streets on satellite images (hybrid mode).
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GoogleMapsMapType.Hybrid">
            <summary>
            Specifies that the Google map displays maps with physical features
            such as terrain and vegetation.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RequestedDataWfsFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the RequestedData event in WfsFeatureSource.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RequestedDataWfsFeatureSourceEventArgs.#ctor">
            <summary>This is a default constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RequestedDataWfsFeatureSourceEventArgs.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="serviceUrl">This parameter specified the serviceUrl for the WfsFeatureSource.</param>
            <param name="xmlResponse">This parameter specified the xmlResponse string get back from the service Url.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RequestedDataWfsFeatureSourceEventArgs.XmlResponse">
            <summary>
            This property gets or sets the xml response string back from for the WfsFeatureSource service url.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RequestedDataWfsFeatureSourceEventArgs.ServiceUrl">
            <summary>
            This property gets or sets the serviceUrl for the WfsFeatureSource.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DbfReadWriteMode">
            <summary>
            Dbf read write mode
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.UnitSystem">
            <summary>
            System of measurement.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.UnitSystem.Imperial">
            <summary>
            Imperial measurement system.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.UnitSystem.Metric">
            <summary>
            Metric measurement system.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ValueStyle">
            <remarks>
            Value Style:<br/>
            	<br/>
            The ValueStyle allows you to match data in the FeatureSource against a value string. If
            the value matches, then we will use the style defined in that item to do the drawing.
            For example, let's say you have some data that contains states, and each state is categorized as either a high,
            medium or low pollution state. Based on the string values of "High", Medium" and "Low",
            we can match on these. If a feature's data for the column matched the string "High", then
            we would use the high ValueItem's styles to draw that feature. This can be applied to all
            kinds of things, such as road classifications, etc.<br/>
            	<br/>
            This can be somewhat slow because we have to match data from the FeatureSource. If
            performance is key, then instead of using the ValueStyle, we recommend that you create a set
            custom index for your layer, one index with only "High" elements, one for "Medium" and so on.
            Then load each as a separate layer. In this way, you would only have one data set, but
            multiple indexes. This is the fastest way if you are working with Shape Files. If you are
            working with spatial databases, then we suggest creating a view to segment out each
            category.
            </remarks>
            <summary>
            This class allows you to match a value with data in the feature to determine how
            to draw that feature.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ValueStyle.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, you need to set the
            required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, you need to set the required properties
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ValueStyle.#ctor(System.String,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.ValueItem})">
            <summary>
            This is a constructor for this class.
            </summary>
            <param name="columnName">The columnName used to match with the value specified in the items.</param>
            <param name="valueItems">The collection of ValueItems. Each item can have its own value to match.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ValueStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If columnName is null, we will throw an ArgumentNullException.</exception>        
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ValueStyle.GetRequiredColumnNamesCore">
            <remarks>
             This abstract method is called from the concrete public method
             GetRequiredFieldNames. In this method, we return the column names that are required for
             the style to draw the feature properly. For example, if you have a style that colors
             areas blue when a certain column value is over 100, then you need to be sure you include
             that column name. This will ensure that the column data is returned to you in the
             feature when it is ready to draw.<br/>
             	<br/>
             In many of the styles, we add properties to allow the user to specify which field they
             need; then, in the GetRequiredColumnNamesCore, we read that property and add it to the
             collection.
             </remarks>
             <summary>
             This method returns the column data for each feature that is required for the
             style to properly draw.
             </summary>
             <returns>This method returns a collection of the column names that it needs.</returns>
             <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If columnName is null, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ValueStyle.ColumnName">
            <summary>
            This property gets and sets the column name used to match with the value
            specified in the items.
            </summary>
            <value>
            This property gets the column name used to match with the value specified in
            the items.
            </value>
            <remarks>This is the column we use for matching.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ValueStyle.ValueItems">
            <summary>
            This property gets the collection of ValueItems. Each item can have its own value to
            match.
            </summary>
            <value>This property gets the collection of ValueItems.</value>
            <remarks>
            You will want to add ValueItems to this collection. Each item can have its own
            style and matching string.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.AreaStyle">
            <summary>This class is used to draw area features.</summary>
            <remarks>
            You should use this class to draw area features. You can specify a fill brush to
            draw the interior and an outline pen to draw the border. You can optionally choose to
            use only the outline pen or the fill brush, which enables you to generate different effects.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyle.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>This constructor does not specify an outline pen or fill brush.</overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, you will need to set the properties of the fill brush
            and outline pen manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyle.#ctor(ThinkGeo.MapSuite.Core.GeoSolidBrush)">
            <summary>This is the constructor for the class.</summary>
            <overloads>This constructor allows you to specify a fill brush without an outline.</overloads>
            <returns>None</returns>
            <remarks>
            This constructor allows you to specify just a fill brush. In this way, the area
            you draw will not have an outline.
            </remarks>
            <param name="fillSolidBrush">This parameter is the solid brush you want to fill the area with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyle.#ctor(ThinkGeo.MapSuite.Core.GeoPen)">
            <summary>This is the constructor for the class.</summary>
            <remarks>
            This constructor allows you to specify just an outline pen. In this way, the area
            you draw will have an outline, but a transparent interior (no fill).
            </remarks>
            <overloads>
            This constructor allows you to specify an outline pen without a filled-in
            area.
            </overloads>
            <returns>None</returns>
            <param name="outlinePen">This parameter is the outline pen you want to use to outline the area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyle.#ctor(ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoSolidBrush)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify an outline pen with a filled-in
            area.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor allows you to specify a fill brush and an outline pen.</remarks>
            <param name="outlinePen">This parameter is the outline pen you want to use to outline the area.</param>
            <param name="fillSolidBrush">This parameter is the solid brush you wish to fill the area with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyle.#ctor(ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoSolidBrush,ThinkGeo.MapSuite.Core.PenBrushDrawingOrder)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify an outline pen with a filled-in area. It
            also lets you select whether the pen or brush is used first.
            </overloads>
            <remarks>
            This constructor allows you to specify a fill brush and an outline pen. It also
            allows you to specify which is drawn first. If the pen is drawn first, the outline
            will be thinner than if the pen is drawn last. The effect is subtle but
            noticeable.
            </remarks>
            <returns>None</returns>
            <param name="outlinePen">This parameter is the outline pen you want to use to outline the area.</param>
            <param name="fillSolidBrush">This parameter is the solid brush you wish to fill the area with.</param>
            <param name="penBrushDrawingOrder">
            This parameter allows you to choose whether the outline pen or the fill brush is drawn
            first.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If OutlinePen is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If FillSolidBrush is null, we will throw an ArgumentNullException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyle.DrawSampleCore(ThinkGeo.MapSuite.Core.GeoCanvas)">
            <summary>This method draws a sample feature on the canvas you provided.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. In this
            method, we draw a sample style on the canvas you provided. This is typically used to
            display a legend or other sample area.<br/>
            	<br/>
            When implementing this virtual method, consider the canvas size and draw the sample
            image appropriately. You should keep in mind that the sample typically shows up on a
            legend.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyle.XOffsetInPixel">
            <summary>This property gets and sets the X pixel offset for drawing each feature.</summary>
            <value>This property gets the X pixel offset for drawing each feature.</value>
            <remarks>
            This property allows you to specify an X offset. When combined with a Y offset, it
            enables you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyle.YOffsetInPixel">
            <remarks>
            This property allows you to specify a Y offset. When combined with an X offset, it
            enables you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to align it with raster
            satellite data.
            </remarks>
            <summary>This property gets and sets the Y pixel offset for drawing each feature.</summary>
            <value>This property gets the Y pixel offset for drawing each feature.</value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyle.FillSolidBrush">
            <summary>
            This property gets and sets the solid brush you want to use to fill in the area
            features.
            </summary>
            <value>
            This property represents the solid brush you want to use to fill in the area
            features.
            </value>
            <remarks>
            This solid brush is used to fill in the area features that will draw. You can also
            optionally specify an outline pen to give the area an outline. The default solid
            brush has a fill color of transparent, which means it will not draw anything.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyle.CustomAreaStyles">
            <summary>
            This property returns a collection of area styles, allowing you to stack multiple
            area styles on top of each other.
            </summary>
            <value>This property returns a collection of area styles.</value>
            <remarks>
            Using this collection, you can stack multiple area styles on top of each other.
            When we draw the features, we will draw them in order that they exist in the collection. You can use
            these stacks to create drop shadow effects, multiple colored outlines,
            etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyle.OutlinePen">
            <summary>
            This property gets and sets the outline pen you want to use to outline the
            features.
            </summary>
            <value>
            This property gets the outline pen you want to use to outline the
            features.
            </value>
            <remarks>
            This outline pen is used to outline the features that will draw. You can also
            optionally specify a fill brush to give the area a solid fill. The default outline
            pen color is transparent, which means it will not draw anything.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyle.PenBrushDrawingOrder">
            <summary>This property gets and sets the pen and brush drawing order.</summary>
            <value>This property gets the pen and brush drawing order.</value>
            <remarks>
            This property controls whether the outline pen or the fill brush is drawn first. The
            default is for the fill brush to be drawn first. If you have the outline pen draw first
            then the thickness of the pen will be smaller, creating a subtle but noticeable
            effect.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyle.Advanced">
            <summary>This property lets you access the advanced properties of the style.</summary>
            <value>This property lets you access the advanced properties of the style.</value>
            <remarks>This property lets you access the advanced properties of the style.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas">
            <summary>
            This class represents a canvas that is used to draw geographic shapes with
            GDI+.
            </summary>
            <remarks>
            	<para>This class allows you to use GDI+ drawing to render your features.<br/>
            		<br/>
                The basic flow of the use of the class is to first call BeginDrawing and pass
                in a image along with its world extent.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.#ctor">
            <remarks>None</remarks>
            <summary>This method is the default constructor for the GdiPlusGeoCanvas.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.DrawAreaCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.ScreenPointF[]},ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Core.PenBrushDrawingOrder)">
            <summary>This method draws the area on the GeoCanvas.</summary>
            <overloads>
            This overload allows you to pass in the GeoPen and the DrawingLevel you want to
            draw on.
            </overloads>
            <remarks>
            	<para>This method is used to draw on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how things are drawn. Specify the GeoBrush to
                fill in an area. Specify the GeoPen to outline an area using that
                GeoPen. You can also call an overload that will allow you to specify both a GeoPen
                and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when you are
                drawing multiple areas. This is very useful when you want to draw a drop shadow, for
                example. In that case, you could draw the black backdrop on the lowest level with an offset, then
                draw the normal shape on a higher level without an offset.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the areaShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the areaShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen and a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <param name="screenPoints">This parameter is the area point in screen coordinates.</param>
            <param name="outlinePen">This parameter describes the outline GeoPen that will be used to draw the area.</param>
            <param name="fillBrush">This parameter describes the GeoBrush that will be used to draw the area.</param>
            <param name="xOffset"> This parameter determines the X offset for the area to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the area to be drawn.</param>
            <param name="penBrushDrawingOrder">This parameter determines pen and brush drawing order.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.DrawLineCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.ScreenPointF},ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single)">
            <remarks>
            	<para>This method is used to draw a line on the GeoCanvas using the specified GeoPen.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple lines. This is very useful when you want to draw a road, for example. You can
                draw the black background on the lowest level, then draw a slightly thinner white line on a higher
                level. This will result in a great effect for a road.</para>
            </remarks>
            <summary>Draws a LineShape on the GeoCanvas.</summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the lineShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the linePen, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <param name="screenPoints">This parameter represents the line points in screen coordinates.</param>
            <param name="linePen">
            This parameter describes the GeoPen that will be used to draw the
            LineShape.
            </param>
            <param name="xOffset"> This parameter determines the X offset for the line to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the line to be drawn.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel that the GeoPen will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.DrawEllipseCore(ThinkGeo.MapSuite.Core.ScreenPointF,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,ThinkGeo.MapSuite.Core.PenBrushDrawingOrder)">
            <summary>Draws the point on the GeoCanvas.</summary>
            <remarks>
            	<para>This method is used to draw a point on the GeoCanvas. It provides you with a number of
                overloads that allow you to control how it is drawn. Specify the GeoBrush to fill in the
                area of the point. Specify the GeoPen to outline the point using that GeoPen.
                You can also call a overload that will allow you to specify
                both a GeoPen and a GeoBrush.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing many points.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the pointShapeWkb parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pointShapeWkb, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outlinePen and a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <param name="screenPoint">This parameter is the point in screen coordinates.</param>
            <param name="outlinePen">
            This parameter describes the outline GeoPen that will be used to draw the
            point.
            </param>
            <param name="fillBrush">
            This parameter describes the fill GeoBrush that will be used to draw the
            point.
            </param>
            <param name="drawingLevel">
            This parameter determines the DrawingLevel that the GeoPen or GeoBrush will draw
            on.
            </param>
            <param name="xOffset"> This parameter determines the X offset of the ellipse to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset of the ellipse to be drawn.</param>
            <param name="width">This parameter describes the width of the ellipse to be drawn.</param>
            <param name="height">This parameter describes the height of the ellipse to be drawn.</param>
            <param name="penBrushDrawingOrder">This parameter determines pen and brush drawing order.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.DrawScreenImageWithoutScalingCore(ThinkGeo.MapSuite.Core.GeoImage,System.Single,System.Single,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws an unscaled image on the GeoCanvas.</summary>
            <remarks>Drawing an image unscaled is faster than using the API that scales it.</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing an invalid image parameter will throw an ArgumentException.</exception>
            <param name="image">The image you want to draw unscaled.</param>
            <param name="centerXInScreen">The X coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="centerYInScreen">The Y coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.DrawScreenImageCore(ThinkGeo.MapSuite.Core.GeoImage,System.Single,System.Single,System.Single,System.Single,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws a scaled image on the GeoCanvas.</summary>
            <remarks>
            Drawing an image scaled is slower than using the API that draws it
            unscaled.
            </remarks>
            <param name="image">The image you want to draw.</param>
            <param name="centerXInScreen">The X coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="centerYInScreen">The Y coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="widthInScreen">
            The width you want to scale the image to. This is the width at which the image will be
            drawn.
            </param>
            <param name="heightInScreen">
            The height you want to scale the image to. This is the height at which the image will be
            drawn.
            </param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a widthInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a heightInScreen that is not greater than 0, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.DrawTextCore(System.String,ThinkGeo.MapSuite.Core.GeoFont,ThinkGeo.MapSuite.Core.GeoBrush,ThinkGeo.MapSuite.Core.GeoPen,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.ScreenPointF},ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>
            	<para>This method allows you to draw text at the specified location, using the
                specified brush and font parameters.</para>
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the fillBrush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string as the text parameter, we will throw an ArgumentException.</exception>        
            <remarks>
            	<para>This method is used to draw text on the GeoCanvas.</para>
            	<para>The DrawingLevel allows you to specify the level you will draw on when
                drawing multiple text items. This is very useful when you want to draw a drop shadow,
                for example. You can draw the black backdrop on the lowest level with an offset, then
                draw the normal text on a higher level without an offset.</para>
            </remarks>
            <param name="text">This parameter specifies the text you wish to draw.</param>
            <param name="font">This parameter represents the font you wish to use to draw the text.</param>
            <param name="fillBrush">
            This parameter specifies the kind of fill you want to use to draw the
            text.
            </param>
            <param name="drawingLevel">
            This parameter specifies the drawing level you wish to draw the text on. Higher
            levels overwrite lower levels.
            </param>
            <param name="haloPen"> This parameter specifies the HaloPen that will be used to draw the text, when the HaloPen effect is needed.</param>
            <param name="xOffset"> This parameter determines the X offset for the text to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the text to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the text to be drawn.</param>
            <param name="textPathInScreen">This parameter specifies the path on which to draw the text.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.MeasureTextCore(System.String,ThinkGeo.MapSuite.Core.GeoFont)">
            <summary>
            This method returns the rectangle that contains the specified text, when that text is drawn
            with the specified font.
            </summary>
            <remarks>This method is typically used for labeling, to determine whether labels overlap.</remarks>
            <returns>
            This method returns the rectangle that contains the specified text, when that text is drawn
            with the specified font.
            </returns>
            <param name="text">This parameter represents the text you want to measure.</param>
            <param name="font">This parameter represents the font of the text you want to measure.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the text, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the font, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a blank string as the text parameter, we will throw an ArgumentException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.BeginDrawingCore(System.Object,ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <remarks>
            This is the first method that needs to be called before any drawing takes place.
            Calling this method will set the IsDrawing property to true. When you finish drawing,
            you must call EndDrawing to commit the changes to the image.
            </remarks>
            <summary>This method begins the act of drawing on the GeoCanvas.</summary>
            <param name="nativeImage">This parameter represents the image you want the GeoCanvas to draw on.</param>
            <param name="worldExtent">This parameter is the world extent of the canvasImage.</param>
            <param name="drawingMapUnit">This parameter is the map unit of the canvasImage.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.EndDrawingCore">
            <summary>This method ends drawing and commits the drawing on the GeoCanvas.</summary>
            <remarks>
            This method should be called when you are finished drawing. It will commit the
            image changes to the image you passed in on BeginDrawing. It will also set
            IsDrawing to false. After you call this method it will put the GeoCanvas into an
            invalid state, so if you then call any drawing methods it will raise an
            exception.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.FlushCore">
            <summary>This method flush drawing and commits the drawing on the GeoCanvas.</summary>
            <remarks>
            This method should be called when you are finished drawing. It will commit the
            image changes to the image you passed in on BeginDrawing. It will also set
            IsDrawing to false. After you call this method it will put the GeoCanvas into an
            invalid state, so if you then call any drawing methods it will raise an
            exception.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.ToNativeImageCore(ThinkGeo.MapSuite.Core.GeoImage)">
            <summary>This method returns a native image object from the specified GeoCanvas.</summary>
            <returns>This method returns a native image object from the specified GeoCanvas.</returns>
            <remarks>
            It is faster to provide a native image object to the canvas for drawing. In some
            cases, you may not know what the native image type is. For example, for GDI+ it is a
            bitmap class, but in GDI it may be a handled to an HBitmap. If you are not sure how to
            create the native image object, you should first create a GeoImage and then call this
            method and it will pass back the native image object. You can then use it to get
            excellent drawing performance on the GeoCanvas.
            </remarks>
            <param name="image">This parameter is the GeoCanvas you want to convert to a native image.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.ToGeoImageCore(System.Object)">
            <summary>This method returns a GeoImage from a native image object.</summary>
            <returns>This method returns a GeoImage from a native image object.</returns>
            <remarks>
            This method will allows you to convert your native image object to a GeoImage.
            Many times, when you work with a GeoCanvas, you may not know the format of the native
            image. Using this method you can always convert it back to a GeoImage, which is a stream
            of a TIFF.
            </remarks>
            <param name="nativeImage">
            This parameter is the native image object you want to convert to a
            GeoImage.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.GetStreamFromGeoImage(ThinkGeo.MapSuite.Core.GeoImage)">
            <summary>This method returns a stream that represents the GeoImage in TIFF format.</summary>
            <returns>This method returns a stream that represents the GeoImage in TIFF format.</returns>
            <remarks>
            This method allows you to get the stream out of a GeoImage. The stream is a
            memory stream and the bytes are in TIFF format. Once you have the stream, you can then save it to
            whatever format you need.
            </remarks>
            <param name="image">This parameter is the GeoImage you want to convert to a stream.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.FillBackground(ThinkGeo.MapSuite.Core.GeoImage,ThinkGeo.MapSuite.Core.GeoBrush)">
            <summary>This method fills the specified GeoImage with the specified GeoBrush.</summary>
            <returns>None</returns>
            <remarks>
            This method allows you to fill a GeoImage with the specific fill style of the GeoBrush you
            pass in. It is useful for setting backgrounds.
            </remarks>
            <param name="image">This parameter is the GeoImage you want to set the background on.</param>
            <param name="brush">This parameter is the GeoBrush you want to fill the background with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.ConvertGeoImageToMemoryStream(ThinkGeo.MapSuite.Core.GeoImage)">
            <summary>This method converts a GeoImage to a memory stream.</summary>
            <overloads>This overload saves the bytes to the memory stream in TIFF format.</overloads>
            <returns>This method converts a GeoImage to a memory stream.</returns>
            <remarks>
            This method is used to get a TIFF memory stream from a GeoImage using the
            canvas-specific methods. If you need to get a format other than TIFF, you can
            use the other overload which allows you to specify the output format.
            </remarks>
            <param name="image">This parameter is the GeoImage you want to convert to a stream.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.ConvertGeoImageToMemoryStream(ThinkGeo.MapSuite.Core.GeoImage,System.Drawing.Imaging.ImageFormat)">
            <summary>This method converts a GeoImage to a memory stream.</summary>
            <overloads>
            This overload saves the bytes to the memory stream in the format you
            specify.
            </overloads>
            <returns>
            The return is a memory stream with the bytes formatted according to the image format
            you specify.
            </returns>
            <remarks>
            This method allows you to save the GeoImage to any format you specify. This
            allows you to convert it to a PNG, or a variety of other formats, and then save it to
            disk.
            </remarks>
            <param name="image">This parameter is the GeoImage you want to convert to a memory stream.</param>
            <param name="imageFormat">This parameter is the image format you want the stream to be in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.CreateGeoImage(System.Int32,System.Int32)">
            <summary>This method returns a GeoImage based on the height and width you provide.</summary>
            <returns>This method returns a GeoImage based on the height and width you provide.</returns>
            <remarks>You can use this static member to easily create a GeoCanvas.</remarks>
            <param name="width">This parameter is the width of the GeoImage.</param>
            <param name="height">This parameter is the height of the GeoImage.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.GetCanvasWidthCore(System.Object)">
            <summary>
            This method gets the canvas width of the specified native image object.
            </summary>
            <param name="nativeImage">The native image will be used to get the canvas width.</param>
            <returns>The returning canvas width.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.GetCanvasHeightCore(System.Object)">
            <summary>
            This method gets the canvas height of the specified native image object.
            </summary>
            <param name="nativeImage">The native image will be used to get the canvas height.</param>
            <returns>The returning canvas height.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.DrawWorldImageWithoutScaling(System.Drawing.Bitmap,System.Double,System.Double,ThinkGeo.MapSuite.Core.DrawingLevel)">
            <summary>Draws an unscaled image on the GeoCanvas.</summary>
            <remarks>Drawing an image unscaled is faster than using the API that scales it.</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <param name="image">The image you want to draw unscaled.</param>
            <param name="centerXInWorld">The X coordinate of the center point (in world coordinates) of where you want to draw the image.</param>
            <param name="centerYInWorld">The Y coordinate of the center point (in world coordinates) of where you want to draw the image.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.DrawWorldImageWithoutScaling(System.Drawing.Bitmap,System.Double,System.Double,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws an unscaled image on the GeoCanvas.</summary>
            <remarks>Drawing an image unscaled is faster than using the API that scales it.</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <param name="image">The image you want to draw unscaled.</param>
            <param name="centerXInWorld">The X coordinate of the center point (in world coordinates) of where you want to draw the image.</param>
            <param name="centerYInWorld">The Y coordinate of the center point (in world coordinates) of where you want to draw the image.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset (in pixels) for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset (in pixels) for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.DrawScreenImageWithoutScaling(System.Drawing.Bitmap,System.Single,System.Single,ThinkGeo.MapSuite.Core.DrawingLevel,System.Single,System.Single,System.Single)">
            <summary>Draws an unscaled image on the GeoCanvas.</summary>
            <remarks>Drawing an image unscaled is faster than using the API that scales it.</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas' IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a drawingLevel that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
            <param name="image">The image you want to draw unscaled.</param>
            <param name="centerXInScreen">The X coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="centerYInScreen">The Y coordinate of the center point (in screen coordinates) of where you want to draw the image.</param>
            <param name="drawingLevel">This parameter determines the DrawingLevel the image will draw on.</param>
            <param name="xOffset"> This parameter determines the X offset for the image to be drawn.</param>
            <param name="yOffset"> This parameter determines the Y offset for the image to be drawn.</param>
            <param name="rotateAngle"> This parameter determines the rotation angle for the image to be drawn.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.CompositingQuality">
            <summary>This property returns or sets the quality level to use during compositing.</summary>
            <remarks>
            	<para>This property is used for GDI+ drawing. The excerpt below is from the GDI+
                documentation:<br/>
                <br/>
                Compositing is done during rendering when the source pixels are
                combined with the destination pixels to produce the resultant pixels. The quality
                of compositing directly relates to the visual quality of the output and is
                inversely proportional to the render time. The higher the quality, the slower the
                render time. This is because the higher the quality level, the more surrounding
                pixels need to be taken into account during the composite. The linear quality
                setting (AssumeLinear) compromises by providing better quality than the default
                quality at a slightly lower speed.</para>
            </remarks>
            <decimalDegreesValue>This property returns the quality level to use during compositing.</decimalDegreesValue>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a CompositingQuality that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.SmoothingMode">
            <summary>This property returns or sets the rendering quality for this GeoCanvas.</summary>
            <decimalDegreesValue>This property returns the rendering quality for this GeoCanvas.</decimalDegreesValue>
            <remarks>
            	<para>This property is used for GDI+ drawing. The excerpt below is from the GDI+
                documentation:<br/>
            		<br/>
            		<br/>
                The smoothing mode specifies whether lines, curves, and the edges of filled areas
                use smoothing (also called antialiasing). One exception is that path gradient
                brushes do not obey the smoothing mode. Areas filled using a PathGradientBrush are
                rendered the same way (aliased) regardless of the SmoothingMode property.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a SmoothingMode that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.HasKeyColor">
            <summary>
            This property indicates whether a GdiPlusGeoCanvas has the KeyColor or not. If it has no
            KeyColor, it will throw an exception when you get or set the value of KeyColors property.
            </summary>
            <remarks>The default value is true.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusGeoCanvas.TextRenderingHint">
            <remarks>
            	<para>This property is used for GDI+ drawing. The excerpt below is from the GDI+
                documentation:<br/>
            		<br/>
                The text rendering hint specifies whether text renders with antialiasing.</para>
            </remarks>
            <summary>
            This property returns or sets the rendering mode for text associated with this
            GeoCanvas.
            </summary>
            <decimalDegreesValue>
            This property returns the rendering mode for text associated with this
            GeoCanvas.
            </decimalDegreesValue>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a TextRenderHint that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException.</exception>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ShapeFileType">
            <summary>This enumeration represents the types stored in the Shape File.</summary>
            <remarks>
            There are a number of formats as described above that are not currently
            supported. They are primarily not supported because Map Suite is a 2D tool and does not
            currently display 3D graphics.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileType.Null">
            <summary>Null</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileType.Point">
            <summary>Point</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileType.Polyline">
            <summary>Polyline</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileType.Polygon">
            <summary>Polygon</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileType.Multipoint">
            <summary>Multipoint</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileType.PointZ">
            <summary>PointZ - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileType.PolylineZ">
            <summary>PolylineZ - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileType.PolygonZ">
            <summary>PolygonZ - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileType.MultipointZ">
            <summary>MultiPointZ - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileType.PointM">
            <summary>PointM - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileType.PolylineM">
            <summary>PolylineM - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileType.PolygonM">
            <summary>PolygonM - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileType.MultipointM">
            <summary>MultipointM - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileType.Multipatch">
            <summary>MultiPatch - This is currently not supported.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ClosingFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the ClosingFeatureSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClosingFeatureSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DrawingFeaturesEventArgs">
            <summary>
            This is the event arguments class for the DrawingFeatures event of the
            FeatureLayer.
            </summary>
            <remarks>
            This is the event arguments class for the DrawingFeatures event of the
            FeatureLayer. You can use the FeaturesToDraw property to add and remove features to draw
            before the FeatureLayer actually draws them.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DrawingFeaturesEventArgs.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DrawingFeaturesEventArgs.#ctor(System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.Feature})">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="featuresToDraw">This parameter represents the faatures that will be drawn.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DrawingFeaturesEventArgs.FeaturesToDraw">
            <summary>This property gets the collection of InternalFeatures that will draw.</summary>
            <decimalDegreesValue>This property gets the collection of InternalFeatures that will draw.</decimalDegreesValue>
            <remarks>
            This property gets the collection of InternalFeatures that will draw. You can add, remove
            or edit items in this collection and they will be considered for drawing in the
            FeatureLayer.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Feature">
            <summary>
            	<para>The class Feature is the basic unit of which a FeatureSource is composed. A
                FeatureSource can be taken from a collection of Features stored in a ShapeFile,
                SQL Server 2008, Oracle, etc.</para>
            	<para>A Feature is the basic data unit structure which is comprised of IDs that mark the
                identification of the Feature, a shape and a collection of data.</para>
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This method allows you to pass in a BaseShape to construct your Feature.</overloads>
            <returns>None</returns>
            <remarks>
            When you create the Feature, specify the ID of the BaseShape you want to use as a basis.
            </remarks>
            <param name="baseShape">
            This parameter represents the base shape you wish to use as the basis of the new
            Feature.
            </param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape that has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(System.Byte[])">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload allows you to create a feature using well-known binary.</overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to create a feature using well-known binary. The Id for
            this Feature will be a random GUID.
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to create the feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(System.Byte[],System.String)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>
            This overload allows you to create a feature using well-known binary and
            specify the Id.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to create a feature using well-known binary and
            specify the Id.
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to create the Feature.</param>
            <param name="id">This parameter is the Id used for the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(System.String)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload allows you to create a feature using well-known text.</overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to create a feature using well-known text. The Id for
            the Feature will be a random GUID.
            </remarks>
            <param name="wellKnownText">This parameter is the well-known text used to create the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(System.String,System.String)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>
            This overload allows you to create the Feature from well-known text and specify
            the Id.
            </overloads>
            <remarks>
            This overload allows you to create the Feature from well-known text and specify
            the Id.
            </remarks>
            <returns>None</returns>
            <param name="wellKnownText">This parameter is the well-known text used to create the Feature.</param>
            <param name="id">This parameter is the Id used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>
            This overload allows you to create the Feature from a baseShape and specify
            the column values.
            </overloads>
            <remarks>
            This overload allows you to create the Feature from a baseShape and specify
            the column values.
            </remarks>
            <returns>None</returns>
            <param name="baseShape">This parameter is the baseShape used to create the Feature.</param>
            <param name="columnValues">This parameter is the columnValues used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>
            This overload allows you to create the Feature from well-known text and feature ID, as well as specify
            the column values.
            </overloads>
            <remarks>
            This overload allows you to create the Feature from well-known text and feature ID, as well as specify
            the column values.
            </remarks>
            <returns>None</returns>
            <param name="wellKnownText">This parameter is the well-known text used to create the Feature.</param>
            <param name="id">This parameter is the Id used in the Feature.</param>
            <param name="columnValues">This parameter is the columnValues used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(System.Byte[],System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>
            This overload allows you to create the Feature from well-known binary and feature ID, as well as specify
            the column values.
            </overloads>
            <remarks>
            This overload allows you to create the Feature from well-known binary and feature ID, as well as specify
            the column values.
            </remarks>
            <returns>None</returns>
            <param name="wellKnownBinary">This parameter is the well-known binary used to create the Feature.</param>
            <param name="id">This parameter is the Id used in the Feature.</param>
            <param name="columnValues">This parameter is the columnValues used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(System.Byte[],System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>
            This overload allows you to create the Feature from well-known binary and feature ID, as well as specify
            the column values.
            </overloads>
            <remarks>
            This overload allows you to create the Feature from well-known binary and feature ID, as well as specify
            the column values.
            </remarks>
            <returns>None</returns>
            <param name="wellKnownBinary">This parameter is the well-known binary used to create the Feature.</param>
            <param name="id">This parameter is the Id used in the Feature.</param>
            <param name="columnValues">This parameter is the columnValues used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(ThinkGeo.MapSuite.Core.Vertex)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload creates a point Feature for the vertex you pass in.</overloads>
            <returns>None</returns>
            <remarks>You can use this constructor to create a point Feature easily.</remarks>
            <param name="vertex">
            This parameter is the x &amp; y decimalDegreesValue pair used to make the point. The Id for the
            Feature will be a random GUID.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(ThinkGeo.MapSuite.Core.Vertex,System.String)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload creates a point Feature for the vertex you pass in.</overloads>
            <returns>None</returns>
            <remarks>You can use this constructor to create a point Feature and specify the Id.</remarks>
            <param name="vertex">
            This parameter is the x &amp; y decimalDegreesValue pair used to make the point. The Id for the
            Feature will be the value you pass in through the id parameter.
            </param>
            <param name="id">This parameter is the Id used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(ThinkGeo.MapSuite.Core.Vertex,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload creates a point Feature for the vertex you pass in.</overloads>
            <returns>None</returns>
            <remarks>You can use this constructor to create a point Feature and specify the Id as well as the column values.</remarks>
            <param name="vertex">
            This parameter is the x &amp; y decimalDegreesValue pair used to make the point. The Id for the
            Feature will be the value you pass in through the id parameter.
            </param>
            <param name="id">This parameter is the Id used in the Feature.</param>
            <param name="columnValues">This parameter is the columnValues used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(System.Double,System.Double)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload creates a point feature for the vertex you pass in.</overloads>
            <returns>None</returns>
            <remarks>You can use this constructor to create a point Feature based on x and y coordinates.</remarks>
            <param name="x">
            This parameter is the x decimalDegreesValue pair used to make the point. The Id for the
            Feature will be a random GUID.
            </param>
            <param name="y">
            This parameter is the y decimalDegreesValue pair used to make the point. The Id for the
            Feature will be a random GUID.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(System.Double,System.Double,System.String)">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload creates a point feature for the vertex you pass in.</overloads>
            <returns>None</returns>
            <remarks>You can use this constructor to create a point Feature based on x and y coordinates and specify the Id.</remarks>
            <param name="x">
            This parameter is the x decimalDegreesValue pair used to make the point. 
            </param>
            <param name="y">
            This parameter is the y decimalDegreesValue pair used to make the point. 
            </param>
            <param name="id">This parameter is the Id used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.#ctor(System.Double,System.Double,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method is the constructor for the Feature.</summary>
            <overloads>This overload creates a point feature for the vertex you pass in.</overloads>
            <returns>None</returns>
            <remarks>You can use this constructor to create a point Feature based on x and y coordinates and specify both the Id and the column values.</remarks>
            <param name="x">
            This parameter is the x decimalDegreesValue pair used to make the point. 
            </param>
            <param name="y">
            This parameter is the y decimalDegreesValue pair used to make the point. 
            </param>
            <param name="id">This parameter is the Id used in the Feature.</param>
            <param name="columnValues">This parameter is the columnValues used in the Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.GetWellKnownBinary">
            <summary>This method returns the well-known binary that represents the Feature.</summary>
            <returns>This method returns the well-known binary that represents the Feature.</returns>
            <remarks>
            This will return a copy of the well-known binary that represents the
            Feature.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.GetWellKnownType">
            <summary>This method returns the well known type that represents the Feature.</summary>
            <returns>This method returns the well known type that represents the Feature.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.GetShape">
            <summary>This method returns the shape class that represents the Feature.</summary>
            <returns>This method returns the shape class that represents the Feature.</returns>
            <remarks>
            This method allows you to get a shape class from a Feature. Because the Feature stores
            the geometry for itself in well-known binary, it may take some time to generate a shape
            class if the geometry is complex.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.GetWellKnownText">
            <summary>This method returns the well-known text that represents the Feature.</summary>
            <returns>This method returns the well-known text that represents the Feature.</returns>
            <remarks>
            This method allows you to get the well-known text from a Feature. Because the Feature
            stores the geometry for itself in well-known binary, it may take some time to generate
            the text if the geometry is complex.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.GetBoundingBox">
            <summary>This method returns the bounding box of the Feature.</summary>
            <returns>This method returns the bounding box of the Feature.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.CloneDeep(System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method clones the entire structure, creating a totally separate copy.</summary>
            <returns>
            This method returns a clone of the entire structure, creating a totally separate
            copy.
            </returns>
            <remarks>
            This method will return a complete copy of the Feature. As this is a deep clone,
            there are no shared references between the source and the copy.
            </remarks>
            <param name="returningColumnNames">
            This parameter represents the columnar data fields that you wish to include in the
            clone.
            </param>       
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.CloneDeep(ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <summary>This method clones the entire structure, creating a totally separate copy.</summary>
            <returns>
            This method returns a clone of the entire structure, creating a totally separate
            copy.
            </returns>
            <remarks>
            This method will return a complete copy of the Feature. As this is a deep clone,
            there are no shared references between the source and the copy.
            </remarks>
            <param name="returningColumnNamesType">
            This parameter allows you to select a type from the ReturningColumnsType that you wish
            to return with.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.IsValid">
            <summary>This method returns the results of some simple validity tests on the Feature.</summary>
            <returns>This method returns the results of some simple validity tests on the Feature.</returns>
            <remarks>
            This method is used primarily to ensure that a Feature is valid. The reason is,
            since this is a structure, we cannot control the main constructor that allows you
            to create a Feature in an invalid state -- that state being one with no well-known binary at
            its core. If you use the constructure set provided, then the state should always be
            valid. This is a property you may want to check before you work with a Feature.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.Equals(System.Object)">
            <summary>This method compares two InternalFeatures to see if they are equal.</summary>
            <overloads>This method compares two InternalFeatures to see if they are equal.</overloads>
            <returns>This method compares two InternalFeatures to see if they are equal.</returns>
            <remarks>None</remarks>
            <param name="obj">The first Feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.GetHashCode">
            <summary>This method returns a semi-unique hash code for the Feature.</summary>
            <returns>This method returns a semi-unique hash code for the Feature.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.op_Equality(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.Feature)">
            <summary>This operator returns if two InternalFeatures are equal.</summary>
            <returns>This operator returns if two InternalFeatures are equal.</returns>
            <remarks>None</remarks>
            <param name="feature1">The first Feature to compare.</param>
            <param name="feature2">The second Feature to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Feature.op_Inequality(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.Feature)">
            <summary>This operator returns if two InternalFeatures are not equal.</summary>
            <returns>This operator returns if two InternalFeatures are not equal.</returns>
            <remarks>None</remarks>
            <param name="feature1">The first Feature to compare.</param>
            <param name="feature2">The second Feature to compare.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Feature.Id">
            <summary>This property gets the Id for the Feature.</summary>
            <decimalDegreesValue>This property gets the Id for the Feature.</decimalDegreesValue>
            <remarks>
            The Id is a string that represents the unique identifier for this Feature. If the
            feature is returned from a FeatureSource, the Id will be the unique field
            descriptor used by the FeatureSource. For Shape Files this may be an integer, but for
            spatial databases the Id may be a GUID.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Feature.Tag">
            <summary>
            The tag of the Feature.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Feature.ColumnValues">
            <summary>
            This property gets a dictionary of values to represent the column data related to
            this Feature.
            </summary>
            <decimalDegreesValue>
            This property gets a dictionary of values to represent the column data related to
            this Feature.
            </decimalDegreesValue>
            <remarks>
            This property holds the column data related to this Feature. You can find the
            values in the dictionary using the column name as the key. Most methods that query and
            return InternalFeatures allow you to specify which columns of data you want returned with the
            results. You can also freely add and modify the data, as it is simply an in-memory
            dictionary. Any values added, deleted or updated will have no effect unless the Feature
            is part of a transaction.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LeafPage">
            <summary>
            LeafPage is a block of data in memeory that represents the class Leaf.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DataPage">
            <summary>
            DataPage is a base class of LeafPage and ChildPage.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RTPage">
            <summary>
            RTPage is a abstract class.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RTPage.Flush">
            <summary>
            Write contents of memory to disk, if modified.
            </summary>
            <returns>
            	true for success  
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RTPage.#ctor(ThinkGeo.MapSuite.Core.RtreeFile,ThinkGeo.MapSuite.Core.Gist_Ext_Id)">
            <summary>
            Constructor for new page.
            </summary>
            <param name="rtFile">		RtreeFile object	</param>
            <param name="extId">	page No.			</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RTPage.#ctor(ThinkGeo.MapSuite.Core.RtreeFile,System.UInt32,ThinkGeo.MapSuite.Core.Gist_Ext_Id)">
            <summary>
            Constructor for existing page.
            </summary>
            <param name="rtFile">		RtreeFile object	</param>
            <param name="pageNo">	page No.			</param>
            <param name="extId">	file type Id		</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RTPage.#ctor(ThinkGeo.MapSuite.Core.RtreeFile,System.UInt32)">
            <summary>
            Constructor for existing page.
            </summary>
            <param name="rtFile">		RtreeFile object	</param>
            <param name="pageNo">	page No.			</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RTPage.#ctor(ThinkGeo.MapSuite.Core.RtreeFile)">
            <summary>
             Constructor for open header page .
            </summary>
            <param name="rtFile">RtreeFile object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RTPage.Load">
            <summary>
            Initialize page.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RTPage.SetModified">
            <summary>
            Set modified flag.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RTPage.GetFileStream">
            <summary>
            Get file stream.
            </summary>
            <returns>filestream object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RTPage.GetFileType">
            <summary>
            Get file type .
            </summary>
            <returns>gistExtId</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RTPage.GetRtreeFile">
            <summary>
            Get RTFile object.
            </summary>
            <returns>RTFile object</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RTPage.PageNo">
            <summary>
            Property page number.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.InsertRecord(ThinkGeo.MapSuite.Core.Record)">
            <summary>
            Insert record for override
            </summary>
            <param name="rec">Record object for insertion.</param>
            <returns>False</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.DeleteRecord(System.Int32)">
            <summary>
            Delete a record according to its index for override.
            </summary>
            <param name="idx">Index of the record.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.Flush">
            <summary>
            Override method for writing contents to disk.
            </summary>
            <returns>
            	true for success  
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.#ctor(ThinkGeo.MapSuite.Core.RtreeFile,System.UInt32,ThinkGeo.MapSuite.Core.Gist_Ext_Id)">
            <summary>
            Constructor for existing page in file.
            </summary>
            <param name="rtFile">	FileStream object	</param>
            <param name="pageNo">	Page No.			</param>
            <param name="extId">	File type Id		</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.#ctor(ThinkGeo.MapSuite.Core.RtreeFile,ThinkGeo.MapSuite.Core.Gist_Ext_Id)">
            <summary>
            Constructor for new page
            </summary>
            <param name="rtFile">	FileStream object	</param>
            <param name="extId">	File type Id		</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.GetLevel">
            <summary>
            Get the level of this page.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.SetLevel(System.UInt16)">
            <summary>
            Set the level for this page.
            </summary>
            <param name="level">level</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.SetPageNo(System.UInt32)">
            <summary>
            Set the page number for this page.
            </summary>
            <param name="pageNo">page no.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.InitForEmptyPage">
            <summary>
            Initialize for an empty page, write the page header and the page end.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.GetRecordCount">
            <summary>
            Get the record count of this page.
            </summary>
            <returns>record count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.ReadPageHeader">
            <summary>
            Read page header.
            </summary>
            <returns>
            	true for success  
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.WritePageHeader">
            <summary>
            Write page header.
            </summary>
            <returns>
            	true for success  
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.ReadRecordSetHeader">
            <summary>
            Read RecordSetHeader from memory stream.
            </summary>
            <returns>		
            	true for success  
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.WriteRecordSetHeader">
            <summary>
            Write RecordSetHeader to memory stream.
            </summary>
            <returns>		
            	true for success  
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.GetFirstRecord">
            <summary>
            Get the first record for override.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.GetNextRecord">
            <summary>
            Get the next record for overrride. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.IsEof">
            <summary>
            Check if cursor has reached the end of this page.
            </summary>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.GetRecord(System.Int32)">
            <summary>
            Get record according to index for override.
            </summary>
            <param name="idx">	Record index	</param>
            <returns>			Record object	</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.GetMaxRecordCount">
            <summary>
            Get max record count for override.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.Dump">
            <summary>
            Dump the current page.
            </summary>
            <returns> true </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.GetMBB">
            <summary>
            Virtual funtion for getting min boundary box.
            </summary>
            <returns> RECTANGLE_D object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.GetFreePageNo">
            <summary>
            Get free page No.
            </summary>
            <returns> free page No.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataPage.UpdateEntry(ThinkGeo.MapSuite.Core.Entry,System.Int32)">
            <summary>
            Update entry after splitting for override.
            </summary>
            <param name="ent">The entry to update.</param>
            <param name="idx">Index of entry.</param>
            <returns>false</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DataPage.PageHeader">
            <summary>
            Property PageHeader
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DataPage.RecordSetHeader">
            <summary>
            Property RecordSetHeader
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LeafPage.#ctor(ThinkGeo.MapSuite.Core.RtreeFile,System.UInt32,ThinkGeo.MapSuite.Core.Gist_Ext_Id)">
            <summary>
            
            </summary>
            <param name="rtFile"></param>
            <param name="pageNo"></param>
            <param name="extId"></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LeafPage.#ctor(ThinkGeo.MapSuite.Core.RtreeFile,ThinkGeo.MapSuite.Core.Gist_Ext_Id)">
            <summary>
            Constructor for new page.
            </summary>
            <param name="rtFile"></param>
            <param name="extId"></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LeafPage.CreateRecordObj">
            <summary>
            Create a record object according to type for override.
            </summary>
            <returns> Record object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LeafPage.GetRecord(System.Int32)">
            <summary>
            Get a record according its index.
            </summary>
            <param name="idx">	record index	</param>
            <returns>			Record object	</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LeafPage.GetFirstRecord">
            <summary>
            Get the first record.
            </summary>
            <returns>Record object.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LeafPage.GetNextRecord">
            <summary>
            Get the next record.
            </summary>
            <returns>Record object. If the end of the page is reached, returns null.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LeafPage.InsertRecord(ThinkGeo.MapSuite.Core.Record)">
            <summary>
            Insert one record in this page; this page may be deleted
            </summary>
            <param name="rec">Record object.</param>
            <returns>
            true for success  
            false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LeafPage.Compress">
            <summary>
            Compress the current page to free deleted space.
            Gets all records in this page and re-inserts them from the header of the data area.
            </summary>
            <returns>
             true for success
             false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LeafPage.SimpleInsertRecord(ThinkGeo.MapSuite.Core.Record)">
            <summary>
            Insert one record into this page.
            </summary>
            <param name="rec">Record object</param>
            <returns>
            true for success  
            false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LeafPage.DeleteRecord(System.Int32)">
            <summary>
            Override function for deleting a record according to its index.
            </summary>
            <param name="idx">Index of the record to be deleted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LeafPage.GetMaxRecordCount">
            <summary>
            Get max record count. 
            </summary>
            <returns> max record count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LeafPage.GetMBB">
            <summary>
            Get the minimum boundary box of all the records in this page.
            </summary>
            <returns> RECTANGLE_D object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LeafPage.Dump">
            <summary>
            Dump the current page for debugging.
            </summary>
            <returns> string containing page contents </returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.SendingRequestWmsRasterSourceEventArgs">
            <summary>
            The event args containing the event data used by SecuredTiledWmsRasterSource.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.SendingRequestWmsRasterSourceEventArgs.#ctor(System.Uri)">
            <summary>
            Create an instance of SendingRequestWmsRasterSourceEventArgs
            </summary>
            <param name="requestUri"></param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SendingRequestWmsRasterSourceEventArgs.RequestUri">
            <summary>
            The request uri
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.OverwriteMode">
            <summary>
            This enumeration represents whether a file should be overwrite or not if the file
            exists.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.OverwriteMode.Overwrite">
            <summary>Over write the file if the file exits.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.OverwriteMode.DoNotOverwrite">
            <summary>Do not over write the file if the file exits.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MapSuiteTileMatrix">
            <summary>
            This class defines the TileMatrix system used in MapSuite component.
            </summary>
            <remarks>
            This MapSuite Tile Matrix system is the TileMatrix system designed for use
            both in Desktop Edition and Web Edition.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.TileMatrix">
            <summary>
            This is the base class inherits from Matrix which describe the Matrix system used
            for Tilling system.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Matrix">
            <summary>
            This class represents a base Matrix which encapsulate the tile caculation logics.
            </summary>
            <remarks>
            This class is abstract and designed to be inherited to create your own
            TileMatrix. The derived TileMatrix classes are typically used on a TileMatrixSet.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.#ctor">
            <summary>This method is the default protected constructor.</summary>
            <returns>None</returns>
            <remarks>If you use this constructor, you have to set the properties correctly before use it.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.#ctor(System.String,System.Double,System.Double,ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.MatrixReferenceCorner)">
            <summary>This method is the default protected constructor.</summary>
            <param name="boundingBox">This parameter specified the boundingBox of the Matrix.</param>
            <param name="cellHeight">This parameter specified the cell height(in DecimalDegrees) of the Matrix.</param>
            <param name="cellWidth">This parameter specified the cell width(in DecimalDegrees) of the Matrix.</param>
            <param name="id">This parameter specified the id of the Matrix.</param>
            <param name="referenceCorner">This parameter specified the cacluation reference corner of the Matrix.</param>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.#ctor(System.String,System.Double,System.Double,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.MatrixReferenceCorner,System.Int64,System.Int64)">
            <summary>This method is the default protected constructor.</summary>
            <param name="cellHeight">This parameter specified the cell height(in DecimalDegrees) of the Matrix.</param>
            <param name="cellWidth">This parameter specified the cell width(in DecimalDegrees) of the Matrix.</param>
            <param name="id">This parameter specified the id of the Matrix.</param>
            <param name="referenceCorner">This parameter specified the cacluation reference corner of the Matrix.</param>
            <param name="columnCount">This parameter specified the column count of the Matrix.</param>
            <param name="rowCount">This parameter specified the row count of the Matrix.</param>
            <param name="referencePoint">This parameter specified the cacluation reference point of the Matrix.</param>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.GetAllCells">
            <summary>This method returns all the cells of the TileMatrix.</summary>
            <returns>This method returns a collection of TileMatrixCell.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">The InvalidOperationException will be thown if too many cells(greater than maximumCellCount) are need to returned back.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.GetCell(System.Int64,System.Int64)">
            <summary>
            Get the cell by passing a specified row and column.
            </summary>
            <param name="row">This parameter specifies the row based on 1.</param>
            <param name="column">This parameter specifies the row based on 1.</param>
            <returns>The returning cell by specified the row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.GetCell(ThinkGeo.MapSuite.Core.PointShape)">
            <summary>
            Get the cell by passing a specified point shape location.
            </summary>
            <param name="intersectingPoint">The parameter specified the target point location.</param>
            <returns>The returning cell by specifing the target point location.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.GetRowIndex(ThinkGeo.MapSuite.Core.PointShape)">
            <summary>
            Get the row index by passing a specified point shape location.
            </summary>
            <param name="intersectingPoint">The parameter specified the target point location.</param>
            <returns>The returning row index by specifing the target point location.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.GetColumnIndex(ThinkGeo.MapSuite.Core.PointShape)">
            <summary>
            Get the column index by passing a specified point shape location.
            </summary>
            <param name="intersectingPoint">The parameter specified the target point location.</param>
            <returns>The returning column index by specifing the target point location.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.GetIntersectingCells(ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This method returns the intersecting cells of the TileMatrix.</summary>
            <param name="worldExtent">This parameter specifies extent which is used to get the tiles back from. </param>
            <returns>This method returns a collection of TileMatrixCell which intersecting with the passed in extent.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">The InvalidOperationException will be thown if too many cells(greater than maximumCellCount) are need to returned back.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.GetContainedCells(ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This method returns the contained cells of the TileMatrix.</summary>
            <param name="worldExtent">This parameter specifies extent which is used to get the tiles back from. </param>
            <returns>This method returns a collection of TileMatrixCell which contained in the passed in extent.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">The InvalidOperationException will be thown if too many cells(greater than maximumCellCount) are need to returned back.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.GetIntersectingRowColumnRange(ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This method returns the RowColumnRange of the TileMatrix intersects the passed in extent.</summary>
            <param name="worldExtent">This parameter specifies extent which is used to get the tiles back from. </param>
            <returns>This method returns the RowColumnRange intersects the passed in extent.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.GetContainedRowColumnRange(ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This method returns the RowColumnRange of the TileMatrix contained the passed in extent.</summary>
            <param name="worldExtent">This parameter specifies extent which is used to get the tiles back from. </param>
            <returns>This method returns the RowColumnRange contained the passed in extent.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.SetMatrix(System.String,System.Double,System.Double,ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.MatrixReferenceCorner)">
            <summary>
            This method sets the Matrix system by passing in each variables.
            </summary>
            <param name="id">This parameter specifies the id to set the Matrix.</param>
            <param name="cellWidth">This parameter specifies the cell width(in decimalDegrees) to set the Matrix.</param>
            <param name="cellHeight">This parameter specifies the cell height(in decimalDegrees) to set the Matrix.</param>
            <param name="boundingBox">This parameter specifies the boundingBox to set the Matrix.</param>
            <param name="referenceCorner">This parameter specifies the reference corner to set the Matrix.</param>
            <remarks>Accroding to the these given parameters, the referencePoint, rowCount, columnCount can be caculated.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.SetMatrix(System.String,System.Double,System.Double,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.MatrixReferenceCorner,System.Int64,System.Int64)">
            <summary>
            This method sets the Matrix system by passing in each variables.
            </summary>
            <param name="id">This parameter specifies the id to set the Matrix.</param>
            <param name="cellWidth">This parameter specifies the cell width(in decimalDegrees) to set the Matrix.</param>
            <param name="cellHeight">This parameter specifies the cell height(in decimalDegrees) to set the Matrix.</param>
            <param name="referencePoint">This parameter specifies the reference Point to set the Matrix.</param>
            <param name="referenceCorner">This parameter specifies the reference corner to set the Matrix.</param>
            <param name="rowCount">This parameter specifies the row count to set the Matrix.</param>
            <param name="columnCount">This parameter specifies the column count to set the Matrix.</param>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Matrix.SetMatrix(System.Double,System.Double)">
            <summary>
            This method sets the Matrix system by passing the cellWidth and cellHeight.
            </summary>
            <param name="cellWidth">This parameter specifies the cell width(in decimalDegrees) to set the Matrix.</param>
            <param name="cellHeight">This parameter specifies the cell height(in decimalDegrees) to set the Matrix.</param>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Matrix.CellWidth">
            <summary>
            This property gets the cell width of the Matrix.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Matrix.CellHeight">
            <summary>
            This property gets the cell height of the Matrix.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Matrix.BoundingBox">
            <summary>
            This property gets or sets the BouningBox of the Matrix.
            </summary>
            <remarks>The bounding box of the Matrix is related with the 
            referencePoint, cellWidth, cellHeight and the rowCount and columnCount.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Matrix.RowCount">
            <summary>
            This property gets the row count of the Matrix.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Matrix.ColumnCount">
            <summary>
            This property gets the column count of the Matrix.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Matrix.Id">
            <summary>
            This property gets or sets the id of the Matrix.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileMatrix.#ctor(System.String,System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.MatrixReferenceCorner,System.Int64,System.Int64)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>]
            <param name="id">This parameter specifies the id to set the Matrix.</param>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <param name="columnCount">This parameter specifies the column count to set the Matrix.</param>
            <param name="referencePoint">This parameter specifies the reference point location to set the Matrix.</param>
            <param name="rowCount">This parameter specifies the row count to set the Matrix.</param>
            <param name="referenceCorner">This parameter specifies the reference corner to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are caculated via these given parameters.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileMatrix.#ctor(System.String,System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.MatrixReferenceCorner)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <param name="id">This parameter specifies the id to set the Matrix.</param>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <param name="boundingBox">This parameter specifies the boundingBox to set the Matrix.</param>
            <param name="referenceCorner">This parameter specifies the reference corner to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are caculated via these given parameters.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileMatrix.GetResolutionFromScale(System.Double)">
            <summary>
            This method will get resolution from scale and can be overridden.
            </summary>
            <param name="scale">This parameter specifies the target scale to get resolution from.</param>
            <returns>Returns the resolution corresponding to the passed in scale.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileMatrix.Scale">
            <summary>
            This property gets or sets the Scale for the TileMatrix.
            </summary>
            <remarks> When set a different Scale, it will recaculate the parameters in TileMatrix.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileMatrix.TileWidth">
            <summary>
            This property gets or sets the TileWidth for the TileMatrix.
            </summary>
            <remarks> When set a different TileWidth, it will recaculate the parameters in TileMatrix.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileMatrix.TileHeight">
            <summary>
            This property gets or sets the TileHeight for the TileMatrix.
            </summary>
            <remarks> When set a different TileHeight, it will recaculate the parameters in TileMatrix.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileMatrix.BoundingBoxUnit">
            <summary>
            This property gets or sets the BoundingBoxUnit for the TileMatrix.
            </summary>
            <remarks> When set a different BoundingBoxUnit, it will recaculate the parameters in TileMatrix. Also,
            The default boundingBox value depends on the BoundingBoxUint.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapSuiteTileMatrix.#ctor(System.Double)">
            <summary>
            This is the constructor by passing the scale.
            </summary>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are used their default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapSuiteTileMatrix.#ctor(System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are used their default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapSuiteTileMatrix.#ctor(System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.RectangleShape)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <param name="boundingBox">This parameter specifies the bounding box to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are used their default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapSuiteTileMatrix.#ctor(System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.PointShape,System.Int64,System.Int64)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <param name="columnCount">This parameter specifies the column count to set the Matrix.</param>
            <param name="referencePoint">This parameter specifies the reference point location to set the Matrix.</param>
            <param name="rowCount">This parameter specifies the row count to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are used their default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapSuiteTileMatrix.#ctor(System.String,System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.RectangleShape)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <param name="id">This parameter specifies the id to set the Matrix.</param>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are used their default values.</remarks>
            <param name="boundingBox">This parameter specifies the bounding box to set the Matrix.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapSuiteTileMatrix.#ctor(System.String,System.Double,System.Int32,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.PointShape,System.Int64,System.Int64)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <param name="id">This parameter specifies the id to set the Matrix.</param>
            <param name="boundingBoxUnit">This parameter specifies the boundingBox Unit to set the Matrix.</param>
            <param name="scale">This parameter specifies the target scale to set the Matrix.</param>
            <param name="tileHeight">This parameter specifies the tile height(in decimalDegrees) to set the Matrix.</param>
            <param name="tileWidth">This parameter specifies the tile width(in decimalDegrees) to set the Matrix.</param>
            <param name="columnCount">This parameter specifies the column count to set the Matrix.</param>
            <param name="referencePoint">This parameter specifies the reference point location to set the Matrix.</param>
            <param name="rowCount">This parameter specifies the row count to set the Matrix.</param>
            <remarks>If you use this constructor, all other properties are used their default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapSuiteTileMatrix.GetResolutionFromScale(System.Double)">
            <summary>
            This method will get resolution from scale and can be overridden.
            </summary>
            <param name="scale">This parameter specifies the target scale to get resolution from.</param>
            <returns>Returns the resolution corresponding to the passed in scale.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.FLP">
            <summary>
            definition of struct FLP
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WellKnownType">
            <summary>
            This describes a set of enumerations that list the valid types of
            geometries.
            </summary>
            <remarks>
            Each of the geometries listed is either a subset or compatible with the OpenGIS
            specifications or the simple feature specifications. Each different kind of geometry
            can also be converted to well-known text and well-known binary. We have added some
            additional geometry types (such as the ellipse and rectangle) which normally are not
            included as separate GIS geometries but are very useful and can easily be converted to
            standard types.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.WellKnownType.Invalid">
            <summary>
            An invalid shape type.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.WellKnownType.Point">
            <summary>
            A Point is a geometry that represents a single location in coordinate
            space.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.WellKnownType.Line">
            <summary>A Line is a curve with linear interpolation between points.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.WellKnownType.Polygon">
            <summary>
            A Polygon is a planar surface representing a multisided geometry. It is defined
            by a single exterior boundary and zero or more interior boundaries, where each interior
            boundary defines a hole in the Polygon.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.WellKnownType.Multipoint">
            <summary>
            A MultiPoint is a geometry collection composed of Point elements. The points are
            not connected or ordered in any way.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.WellKnownType.Multiline">
            <summary>A MultiLine is a geometry collection composed of Line elements.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.WellKnownType.Multipolygon">
            <summary>A MultiPolygon is a object composed of one or more Polygon elements.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.WellKnownType.GeometryCollection">
            <summary>A GeometryCollection is a object composed of one or more Shape elements.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DrawingLineCap">
            <summary>
            	<para>This enumeration represents the available cap styles with which a GeoPen
                object can end a line.</para>
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineCap.Round">
            <summary>This member specifies a round line cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineCap.AnchorMask">
            <summary>
            This member specifies a mask used to check whether a line cap is an anchor
            cap.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineCap.ArrowAnchor">
            <summary>This member specifies an arrow-shaped anchor cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineCap.Custom">
            <summary>This member specifies a custom line cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineCap.DiamondAnchor">
            <summary>This member specifies a diamond anchor cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineCap.Flat">
            <summary>This member specifies a flat line cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineCap.NoAnchor">
            <summary>This member specifies no anchor.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineCap.RoundAnchor">
            <summary>This member specifies a round anchor cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineCap.Square">
            <summary>This member specifies a square line cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineCap.SquareAnchor">
            <summary>This member specifies a square anchor line cap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineCap.Triangle">
            <summary>This member specifies a triangular line cap.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Leaf">
            <summary>
            A Leaf node. Contains pointers to the real data.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Node">
            <summary>
            Node is an abstract class that implements all common functions in Leaf and Child.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.CreateBytype(ThinkGeo.MapSuite.Core.DataPage)">
            <summary>
            Create a node by page type.
            </summary>
            <param name="dtPage">DataPage object</param>
            <returns>Node object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.#ctor(ThinkGeo.MapSuite.Core.DataPage)">
            <summary>
            Constructor.
            </summary>
            <param name="page">DataPage object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.GetFileType">
            <summary>
            Get file type.
            </summary>
            <returns>file type Id</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.Check">
            <summary>
            Check the integrity of the node.
            </summary>
            <returns>
            	true for OK
            	false for corrupt file
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.GetSubNode(System.Int32)">
            <summary>
            Get the index Entry's sub node.
            </summary>
            <param name="index">index		</param>
            <returns>			child node	</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.GetLevel">
            <summary>
            Get the level of node.
            </summary>
            <returns>level</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.SetLevel(System.UInt16)">
            <summary>
            Set the level for this node.
            </summary>
            <param name="level">level</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.GetPageNo">
            <summary>
            Get the page no. of this node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.SetPageNo(System.UInt32)">
            <summary>
            Set the page no. for this node.
            </summary>
            <param name="pageNo"></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.GetFirstRecord">
            <summary>
            Get the first record of the current node.
            </summary>
            <returns>Record object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.GetNextRecord">
            <summary>
            Get the next record.
            </summary>
            <returns>Record object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.IsEof">
            <summary>
            Test if the cursor has reached the end of the node.
            </summary>
            <returns>
            	true for end
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.GetRecordCount">
            <summary>
            Return the record count in this node.
            </summary>
            <returns>record count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.GetTotalRecordCount">
            <summary>
            Get the total count of records in the current node and its sub nodes,
            if they are leaf nodes.
            </summary>
            <returns>record count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.GetMBB">
            <summary>
            Get the minimum boundary box of this node.
            </summary>
            <returns>Min boundary RECTANGLE_D object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.IsContains(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Test if the node contains the specified RECTANGLE_D.
            </summary>
            <param name="rt">RECTANGLE_D to test</param>
            <returns>
            	true for contains
            	false for not
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.IsContained(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Test if the node is contained by the specified RECTANGLE_D.
            </summary>
            <param name="rt">RECTANGLE_D to test</param>
            <returns>
            	true for contained
            	false for not
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.IsOverlaps(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Test if the node overlaps with a specific RECTANGLE_D.
            </summary>
            <param name="rt">RECTANGLE_D to test</param>
            <returns>
            	true for overlap
            	false for not
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.GetAllRecordsIDSetInThisNode(System.Collections.ArrayList@)">
            <summary>
            Get the record ID Set in this node, including sub nodes if they are leaf nodes.
            Returns records count, add records id to arraylist object.
            </summary>
            <param name="al">Array list for records' IDs</param>
            <returns>Records' count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.GetNearest(ThinkGeo.MapSuite.Core.POINT,ThinkGeo.MapSuite.Core.Node,System.Int32)">
            <summary>
            Get nMax nearest record
            </summary>
            <param name="p">	Query point				    </param>
            <param name="nRoot">Root node					</param>
            <param name="nMax">	The record count you want	</param>
            <returns>Record list</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.GetNearest(ThinkGeo.MapSuite.Core.Node,ThinkGeo.MapSuite.Core.POINT,System.Double,System.Int32,System.Collections.ArrayList@,System.Collections.ArrayList@,System.Collections.ArrayList@)">
            <summary>
            Get nMax nearnest record
            </summary>
            <param name="node">				Current node				</param>
            <param name="p">				Query Point					</param>
            <param name="nearest">			Current mindistance			</param>
            <param name="nMax">				The point number you want	</param>
            <param name="nodeStack">		Nodelist needed to search	</param>
            <param name="candidateStack">	Candidate record list		</param>
            <param name="resuLbStack">		Hold resuLb					</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.AddNodeToNodeStack(System.Collections.ArrayList@,ThinkGeo.MapSuite.Core.Node,ThinkGeo.MapSuite.Core.POINT)">
            <summary>
            Add the current node's subnodes to NodeStack.
            </summary>
            <param name="nodeStack">Nodelist need to search	</param>
            <param name="node">		Current node			</param>
            <param name="p">		Query point				</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.AddCandiatesToResuLbStack(System.Collections.ArrayList@,System.Collections.ArrayList@,System.Int32,System.Double)">
            <summary>
            Add record to resuLbStack by nearest.
            </summary>
            <param name="candidateStack">	Candidate record list			</param>
            <param name="resuLbStack">		resuLb list						</param>
            <param name="nMax">				The point number want to search	</param>
            <param name="nearest">			Current mindistance				</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.AddToCandiateStack(ThinkGeo.MapSuite.Core.Node,ThinkGeo.MapSuite.Core.POINT,System.Collections.ArrayList@)">
            <summary>
            Add a Leaf node's record to candidateStack and sort them.
            </summary>
            <param name="node">				Leaf node		</param>
            <param name="p">				Query point		</param>
            <param name="candidateStack">	candidateStack	</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.Contains(ThinkGeo.MapSuite.Core.RECTANGLE_D,System.Collections.ArrayList@)">
            <summary>
            Return the count of records that contains the specific RECTANGLE_D.
            </summary>
            <param name="rt">	RECTANGLE_D to test			</param>
            <param name="al">	Arraylist for records' ids	</param>
            <returns>			Count of record				</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.Contained(ThinkGeo.MapSuite.Core.RECTANGLE_D,System.Collections.ArrayList@)">
            <summary>
            Return the count of records contained in RECTANGLE_D.
            </summary>
            <param name="rt">	RECTANGLE_D to test			</param>
            <param name="al">	array list for records' ids	</param>
            <returns>			Count of record				</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.Overlaps(ThinkGeo.MapSuite.Core.RECTANGLE_D,System.Collections.ArrayList@)">
            <summary>
            Return the number of records that overlap with RECTANGLE_D.
            </summary>
            <param name="rt">RECTANGLE_D to test		</param>
            <param name="al">arraylist for records' ids	</param>
            <returns>Count of record</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.Dump">
            <summary>
            Dump this node's contents for debugging.
            </summary>
            <returns>node's contents</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.GetRecord(System.Int32)">
            <summary>
            Get record according its index.
            </summary>
            <param name="idx">	record index	</param>
            <returns>			record object	</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.IsRoot">
            <summary>
            Test if Node is root node.
            </summary>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.IsLeaf">
            <summary>
            Test if Node is leaf node.
            </summary>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.IsChild">
            <summary>
            Test if node is child node.
            </summary>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.QuadraticSplit(System.Collections.ArrayList)">
            <summary>
            Quadratic algorithm for spliting a node.
            </summary>
            <param name="rectList">ArrayList of RECTANGLE_D for splitting</param>
            <returns>two groups index </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.PickNext(ThinkGeo.MapSuite.Core.RECTANGLE_D[],System.Collections.ArrayList@,System.Collections.ArrayList@,System.Collections.ArrayList@,ThinkGeo.MapSuite.Core.RECTANGLE_D@,ThinkGeo.MapSuite.Core.RECTANGLE_D@)">
            <summary>
            Select one remaining entry for classification as a group
            </summary>
            <param name="rectArr">		RECTANGLE_D[] array for splitting	</param>
            <param name="spRectList">	Resting index of RECTANGLE_D		</param>
            <param name="leftRectList">	Index of left group					</param>
            <param name="rightRectList">Index of right group				</param>
            <param name="mbr1">			MBB of left group					</param>
            <param name="mbr2">			MBB of right group					</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.AddRest(System.Collections.ArrayList@,System.Collections.ArrayList@)">
            <summary>
            Add the rest index of RECTANGLE_D to a specific group.
            </summary>
            <param name="spRectList">	Resting index of RECTANGLE_D</param>
            <param name="rectList">		Index of left or right group</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.PickSeeds(ThinkGeo.MapSuite.Core.RECTANGLE_D[])">
            <summary>
            Select two records to be the first elements of the pages.
            </summary>
            <returns> int array contains two record index</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.AdjustTree(ThinkGeo.MapSuite.Core.Node,System.Int32,System.Boolean)">
            <summary>
            Called by insert to adjust the parents of the node that
             was modified by the insertion. 
             Stops when it reaches the root.
            </summary>
            <param name="n">		The child node that caused the need for adjustment.	</param>
            <param name="index">	For adjusting entry's index							</param>
            <param name="bSplitted">true for split, false for otherwise				</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.UpdateEntry(ThinkGeo.MapSuite.Core.Node,ThinkGeo.MapSuite.Core.Entry,System.Int32)">
            <summary>
            Update the specified node's entry.
            </summary>
            <param name="n">	Node object	</param>
            <param name="ent">	Entry object</param>
            <param name="index">index		</param>
            <returns>
            	true for sucess
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.FindLeastEnlargement(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Find the least enlargement entry to contain the specified RECTANGLE_D.
            </summary>
            <param name="rt">	RECTANGLE_D object	</param>
            <returns>			Entry's index		</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.InsertRecord(ThinkGeo.MapSuite.Core.Record,ThinkGeo.MapSuite.Core.Node[]@)">
            <summary>
            Insert record for recursive calling.
            </summary>
            <param name="rec">		Record object	</param>
            <param name="nodelist">	Node array		</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.InsertRecordInThisNode(ThinkGeo.MapSuite.Core.Record,ThinkGeo.MapSuite.Core.Node[]@)">
            <summary>
            Insert a record into current node.
            </summary>
            <param name="rec">		Record object	</param>
            <param name="nodeList">	Node array		</param>
            <returns>
            	true for success
            	flase for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.GetFreePageNo">
            <summary>
            Get free page number.
            </summary>
            <returns>page No.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.SplitRoot(ThinkGeo.MapSuite.Core.Node[])">
            <summary>
            Create a new root according to two nodes. 
            </summary>
            <param name="a">Node array that contains two nodes</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.MoveNodeToLast(ThinkGeo.MapSuite.Core.Node)">
            <summary>
            Move a node to the end of file.
            </summary>
            <param name="node">Node to be moved</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.Delete(ThinkGeo.MapSuite.Core.Record)">
            <summary>
            Delete a Record.
            </summary>
            <param name="delRec">The record to be deleted.</param>
            <returns>
            	true for deletion
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.FindPointRecordLeaf(ThinkGeo.MapSuite.Core.Record,System.Int32@,ThinkGeo.MapSuite.Core.Leaf@,ThinkGeo.MapSuite.Core.Node)">
            <summary>
            Find a leaf node whose type is point.
            </summary>
            <param name="rec">		Record object to delete				    </param>
            <param name="idx">		Index of record to delete			    </param>
            <param name="leafToDel">Leaf node in which to delete the record </param>
            <param name="subNode">	Node object							    </param>
            <returns>
             true for find 
             flase for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.FindRectRecordLeaf(ThinkGeo.MapSuite.Core.Record,System.Int32@,ThinkGeo.MapSuite.Core.Leaf@,ThinkGeo.MapSuite.Core.Node)">
            <summary>
            Find leaf node whose type is rectangle.
            </summary>
            <param name="rec">		Record object to delete				    </param>
            <param name="idx">		Index of record to delete		    	</param>
            <param name="leafToDel">Leaf node in which to delete the record	</param>
            <param name="subNode">	Node object							    </param>
            <returns>
             true for find 
             flase for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Node.DeleteRecord(System.Int32)">
            <summary>
            Delete a Record by index
            </summary>
            <param name="idx"></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Leaf.#ctor(ThinkGeo.MapSuite.Core.LeafPage)">
            <summary>
            Constructor
            </summary>
            <param name="page">LeafPage object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Leaf.GetAllRecordsIDSetInThisNode(System.Collections.ArrayList@)">
            <summary>
            Override method for getting record ID Set in this node.
            Return records count, add records ID to arraylist object.
            </summary>
            <param name="al">Array list for records' IDs</param>
            <returns>Records' count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Leaf.Contains(ThinkGeo.MapSuite.Core.RECTANGLE_D,System.Collections.ArrayList@)">
            <summary>
            Return the count of records that contains a specific area.
            </summary>
            <param name="rt">	RECTANGLE_D to test			</param>
            <param name="al">	Array list for records' IDs	</param>
            <returns>			Count of records			</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Leaf.Contained(ThinkGeo.MapSuite.Core.RECTANGLE_D,System.Collections.ArrayList@)">
            <summary>
            Return the count of records contained in RECTANGLE_D.
            </summary>
            <param name="rt">	RECTANGLE_D to test			</param>
            <param name="al">	Array list for records' IDs	</param>
            <returns>			Count of records			</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Leaf.Overlaps(ThinkGeo.MapSuite.Core.RECTANGLE_D,System.Collections.ArrayList@)">
            <summary>
            Return the number of records that overlap with RECTANGLE_D.
            </summary>
            <param name="rt">RECTANGLE_D to test		</param>
            <param name="al">Array list for records' IDs	</param>
            <returns>Count of record</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Leaf.InsertRecord(ThinkGeo.MapSuite.Core.Record,ThinkGeo.MapSuite.Core.Node[]@)">
            <summary>
            Insert a record.
            </summary>
            <param name="rec">Record object</param>
            <param name="nodeList"></param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Leaf.FindLeaf(ThinkGeo.MapSuite.Core.Record,System.Int32@,ThinkGeo.MapSuite.Core.Leaf@)">
            <summary>
            Override FindLeaf, which finds the leaf node containing a given Record.
            </summary>
            <param name="delRec">	Record for deletion									</param>
            <param name="idx">		If FindLeaf, represents the return index of the record for deletion	</param>
            <param name="leafToDel">Leaf node from which to delete the record</param>
            <returns>
            	true for found 
            	false for otherwise
            </returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ChildPage">
            <summary>
            ChildPage is a block of data in memory that represents a ChildPage.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ChildPage.#ctor(ThinkGeo.MapSuite.Core.RtreeFile,System.UInt32,ThinkGeo.MapSuite.Core.Gist_Ext_Id)">
            <summary>
            Constructor
            </summary>
            <param name="rtFile">	RtreeFile object	</param>
            <param name="pageNo">	Page No.			</param>
            <param name="extId">	File type Id		</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ChildPage.#ctor(ThinkGeo.MapSuite.Core.RtreeFile,ThinkGeo.MapSuite.Core.Gist_Ext_Id)">
            <summary>
            Constructor for new page
            </summary>
            <param name="rtFile">	RtreeFile object</param>
            <param name="extId">	File type Id	</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ChildPage.CreateRecordObj">
            <summary>
            Override function for creating Entry object
            </summary>
            <returns>Entry object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ChildPage.GetMaxRecordCount">
            <summary>
            Override method for getting max record count
            </summary>
            <returns>Max record count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ChildPage.UpdateEntry(ThinkGeo.MapSuite.Core.Entry,System.Int32)">
            <summary>
            Update the current node's entry after its leaf has been split.
            </summary>
            <param name="ent">Entry object</param>
            <param name="idx">Entry's index</param>
            <returns>
            	True for success  
            	False for failure
            </returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.AdornmentLayerDrawingEventArgs">
            <summary>
            This is the event arguments class for the AdornmentLayerDrawing event. It
            is raised before the AdornmentLayer is drawn.
            </summary>
            <remarks>
            This is the event arguments class for the AdornmentLayerDrawing event. It
            is raised before the AdornmentLayer is drawn. This event allows you to manipulate the
            AdornmentLayer, or draw something with the canvas before the AdornmentLayer draws.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AdornmentLayerDrawingEventArgs.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AdornmentLayerDrawingEventArgs.#ctor(ThinkGeo.MapSuite.Core.AdornmentLayer)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="adornmentLayer">This parameter is the AdornmentLayer that will be drawn.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AdornmentLayerDrawingEventArgs.AdornmentLayer">
            <summary>This property gets and sets the AdornmentLayer that will be drawn.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WorldMapKitProjection">
            <summary>
            This enumeration represents which projection will use for world map kit.
            </summary>
            <remarks>The Default item is the same as DecimalDegrees.</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.WorldMapKitProjection.Default">
            <summary>
            The same as DecimalDegrees.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.WorldMapKitProjection.DecimalDegrees">
            <summary>
            DecimalDegrees, for example, the EPSG:4326 is decimal degrees. 
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.WorldMapKitProjection.SphericalMercator">
            <summary>
            SphericalMercator, for example, the Google Maps use EPSG:900913 is spherical mercator.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.OpenStreetMapLayer.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a Layer which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method opens the Layer so that it is initialized and ready to use.</summary>
            <remarks>
            This abstract method is called from the concrete public method Open. The
            open method plays an important role, as it is responsible for initializing the Layer.
            Most methods on the Layer will throw an exception if the state of the Layer is not
            opened. When the map draws each layer, the layer will be opened as one of its first steps;
            then, after it is finished drawing with that layer, it will close it. In this way, we
            are sure to release all resources used by the Layer.<br/>
            <br/>
            When implementing the abstract method, consider opening the FeatureSource or
            RasterSource. You will get a chance to close these in the Close method of the
            Layer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.OpenStreetMapLayer.CloseCore">
            <summary>
            This method closes the Layer and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This abstract method is called from the concrete public method Close. The close
            method plays an important role in the life cycle of the Layer. It may be called after
            drawing to release any memory and other resources that were allocated since the Open
            method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed Layer is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.OpenStreetMapLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the Layer.</summary>
            <remarks>
            This method is the concrete wrapper for the abstract method DrawCore. This
                method draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties that
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter represents the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.OpenStreetMapLayer.FetchImageInThread(System.Object)">
            <summary>
            Fetch the image from GoogleMaps service in other thread.
            </summary>
            <param name="obj">Represents an object that encapsulates the parameters which will pass in the thread.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.OpenStreetMapLayer.GetPictureFormat">
            <summary>
            Get picture format string which will use for request url.
            </summary>
            <returns>Get picture format string which will use for request url.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.OpenStreetMapLayer.TimeoutInSeconds">
            <summary>
            Gets or sets a value represents the request timeout from the OpenStreetMap server.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.OpenStreetMapLayer.CacheDirectory">
            <summary>
            Gets or sets a value represents the directory for image cache.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.OpenStreetMapLayer.WebProxy">
            <summary>
            This property gets or sets the proxy used for requesting a Web Response.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GraticuleAdornmentLayer">
            <summary>
            GraticuleAdornmentLayer shows Meridians and Parallels displaying through the map. Meridians are lines of longitude and they have a North South orientation. Parallels are lines of latitude and they have an East West orientation. 
            Showing graticule for latitude and longitude is a standard way in cartography to give spatial references to the users. 
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GraticuleAdornmentLayer.#ctor">
            <summary>
            This is the default constructor of the class.
            </summary>
            <remarks>If use this constructor, the projection is null.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GraticuleAdornmentLayer.#ctor(ThinkGeo.MapSuite.Core.Projection)">
            <summary>
            This is a constructor for the class.
            </summary>
            <overloads>This constructor allows you to pass in the Projection.</overloads>
            <param name="projection">This parameter represents the external projection which the map is actually displayed in, the internal projection is the Geodetic projection (Decimal Degrees).</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GraticuleAdornmentLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the AdornmentLayer.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. This method
            draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            You can use the full power of the GeoCanvas to do the drawing.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the geoCanvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the labelsInAllLayers, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a mapUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="labelsInAllLayers">This parameter represents the labels used for collision detection and duplication checking.</param>
            <param name="canvas">This parameter is the canvas object (or a GeoImage) to draw on.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GraticuleAdornmentLayer.GraticuleLineStyle">
            <summary>
            Gets or Sets the LineStyle of the Meridians and Parallels.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GraticuleAdornmentLayer.GraticuleTextFont">
            <summary>
            Gets or Sets the GeoFont of the Meridians and Parallels.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GraticuleAdornmentLayer.GraticuleTextBrush">
            <summary>
            Gets or Sets the GeoBrush of the Meridians and Parallels.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GraticuleAdornmentLayer.Projection">
            <summary>
            Gets or Sets the Projection of the Meridians and Parallels.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WmsLayerStyle">
            <summary> 
            Structure for storing information about a WMS Layer Style. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsLayerStyle.Title">
            <summary> 
            Title of this requesting WMS layer. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsLayerStyle.Name">
            <summary> 
            Name of this requesting WMS layer. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsLayerStyle.Abstract">
            <summary> 
            Abstract of this requesting WMS layer. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsContactInformation.VoiceTelephone">
            <summary> 
            Telephone (voice) number.
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsContactInformation.FacsimileTelephone">
            <summary> 
            Fax number. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsContactInformation.ElectronicMailAddress">
            <summary> 
            E-mail address. 
            </summary> 
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.FileBitmapTileCache">
            <summary>
            This class is a concrete class inherits from BitmapTileCache.
            In this class, the tiles will be saved in disk and can be viewed very
            conveniently.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.BitmapTileCache">
            <summary>
            This is the base class for BitmapTileCache system which inherits from TileCache class.
            </summary>
            <remarks>TileCahce system is very efficient in improving the performance of
            application, especially when large data or remote server images are included.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.TileCache">
            <summary>
            This is the base class for TileCache system.
            </summary>
            <remarks>TileCahce system is very efficient in improving the performance of
            application, especially when large data or remote server images are included.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileCache.#ctor(System.String,ThinkGeo.MapSuite.Core.TileImageFormat,ThinkGeo.MapSuite.Core.TileMatrix)">
            <summary>
            This is the constructor of the class.
            </summary>
            <param name="cacheId">This is the cache identifier which marks its difference with other TileCache.</param>
            <param name="imageFormat">This is the imageFormate showing what kind of image we are trying to save.</param>
            <param name="tileMatrix">This is the tile matrix system which is used for caculating tiles.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileCache.SaveTile(ThinkGeo.MapSuite.Core.Tile)">
            <summary>
            This method will save the target tile passed in.
            </summary>
            <param name="tile">The target tile to be saved.</param>
            <remarks>This method will not take effect when the ReadOnly is set to true.</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the target tile, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileCache.SaveTiles(System.Drawing.Bitmap,ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>
            This method will save the bitmap with its extent attached into tiles.
            </summary>
            <param name="bitmap">The target bitmap to be saved into tiles.</param>
            <param name="bitmapExtent">The target extent for the bitmap.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the target bitmap, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileCache.DeleteTiles(ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>
            This method will delete the tiles within the passed in worldExtent.
            </summary>
            <param name="worldExtent">The target extent to delete all tiles within it.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileCache.DeleteTile(ThinkGeo.MapSuite.Core.Tile)">
            <summary>
            This method will delete the target tile passed in.
            </summary>
            <param name="tile">The target tile to be deleted.</param>
            <remarks>This method will not take effect when the ReadOnly is set to true.</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the target tile, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileCache.ClearCache">
            <summary>
            This method will clear all the tiles in the tileCache.
            </summary>
            <remarks>This method will not take effect when the ReadOnly is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileCache.ClearCacheCore">
            <summary>
            This abstract method will clear all the tiles in the tileCache, for each 
            sub TileCache class must implement this method.
            </summary>
            <remarks>This method will not take effect when the ReadOnly is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileCache.SaveTileCore(ThinkGeo.MapSuite.Core.Tile)">
            <summary>
            This abstract method will save the target tile passed in, for each 
            sub TileCache class must implement this method.
            </summary>
            <param name="tile">The target tile to be saved.</param>
            <remarks>This method will not take effect when the ReadOnly is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileCache.DeleteTileCore(ThinkGeo.MapSuite.Core.Tile)">
            <summary>
            This abstract method will delete the target tile passed in, for each 
            sub TileCache class must implement this method.
            </summary>
            <param name="tile">The target tile to be deleted.</param>
            <remarks>This method will not take effect when the ReadOnly is set to true.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileCache.TileMatrix">
            <summary>
            Gets or sets the TileMatrix which is used in caculation for tiles.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileCache.ReadOnly">
            <summary>
            Gets or sets the Mode for the TileCache. If it is ReadOnly, then we will 
            not save or delete tiles in it.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileCache.TileAccessMode">
            <summary>
            Gets or sets the Mode for the TileCache access the tiles. The Default value is ReadAddDelete
            </summary>
            <remarks>If you want it to take effect, you need set the ReadOnly property false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileCache.NoDataTileImage">
            <summary>
            This property returns back a preset image showing the tile data is missing.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileCache.LoadingTileImage">
            <summary>
            This property returns back a preset image showing the Tile is loading.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileCache.ImageFormat">
            <summary>
            Gets or sets the tile image format.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileCache.JpegQuality">
            <summary>
            Gets or sets the Jpeg quality , this property only take effects when setting 
            the ImageFormat to Jpeg.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileCache.CacheId">
            <summary>
            Gets or sets the id of the TileCache.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BitmapTileCache.#ctor(System.String,ThinkGeo.MapSuite.Core.TileImageFormat,ThinkGeo.MapSuite.Core.TileMatrix)">
            <summary>
            This is the constructor of the class.
            </summary>
            <param name="cacheId">This is the cache identifier which marks its difference with other TileCache.</param>
            <param name="imageFormat">This is the imageFormate showing what kind of image we are trying to save.</param>
            <param name="tileMatrix">This is the tile matrix system which is used for caculating tiles.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BitmapTileCache.GetTile(ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>
            This method returns the BitmapTile corresponding to the tile bounding box passed in.
            </summary>
            <param name="tileBoundingBox">The target boundingBox for the tile to fetch.</param>
            <returns>Returns the BitmapTile corresponding to the passed in boundingBox.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape is not a valid rectangle, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BitmapTileCache.GetTile(System.Int64,System.Int64)">
            <summary>
            This method returns the BitmapTile corresponding to passed in row and column.
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the BitmapTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BitmapTileCache.GetTiles(ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>
            This method returns all the BitmapTiles within the passed in world extent.
            </summary>
            <param name="worldExtent">The target worldExtent will be used to fetch all the BitmapTiles from.</param>
            <returns>Returns a collection of BitmapTiles within the passed in worldExtent.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape is not a valid rectangle, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BitmapTileCache.GetTileCore(System.Int64,System.Int64)">
            <summary>
            This abstract method returns the BitmapTile corresponding to passed in row and column. 
            Each concrete TileCache need to implement this logic to get tile from a row and column.
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the BitmapTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BitmapTileCache.GetHigherScaleTile(ThinkGeo.MapSuite.Core.RectangleShape,System.Double)">
            <summary>
            This method will return the HigherScale BitmapTile which is always used for preview 
            effects when ZoomIn or ZoomOut.
            </summary>
            <param name="tileBoundingBox">The parameter specifies the current tile bounding box.</param>
            <param name="tileScale">This parameter specifies the current tile scale.</param>
            <returns>Returns the higher scale(higher zoomLevel) bitmap tile.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BitmapTileCache.GetHigherScaleTileCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Double)">
            <summary>
            This method is virtual and can be overriden by its sub classes.
            This method will return the HigherScale BitmapTile which is always used for preview 
            effects when ZoomIn or ZoomOut.
            </summary>
            <param name="tileBoundingBox">The parameter specifies the current tile bounding box.</param>
            <param name="tileScale">This parameter specifies the current tile scale.</param>
            <returns>Returns the higher scale(higher zoomLevel) bitmap tile.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BitmapTileCache.MergeBitmaps(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.BitmapTile},System.Double)">
            <summary>
            This method will merege the passed in bitmap tiles into a larege bitmap tile.
            </summary>
            <param name="tilesToMerge">The collection of tiles to be mereged.</param>
            <param name="scale">The target scale for result mereged bitmap tile.</param>
            <returns>Returns a merged bitmap tile.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileBitmapTileCache.#ctor">
            <summary>
            This is the default constructor.
            </summary>
            <remarks>If you use this constructor, you have to set the properties manually.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileBitmapTileCache.#ctor(System.String)">
            <summary>
            This is the overloads constructor.
            </summary>
            <param name="cacheDirectory">This parameter specifies the cache directory of the tile cache.</param>
            <remarks>If you use this constructor, the other properties are set with default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileBitmapTileCache.#ctor(System.String,System.String)">
            <summary>
            This is the overloads constructor.
            </summary>
            <param name="cacheDirectory">This parameter specifies the cache directory of the tile cache.</param>
            <param name="cacheId">This parameter specifies the cache id of the tile cache.</param>
            <remarks>If you use this constructor, the other properties are set with default values.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileBitmapTileCache.#ctor(System.String,System.String,ThinkGeo.MapSuite.Core.TileImageFormat,ThinkGeo.MapSuite.Core.TileMatrix)">
            <summary>
            This is the constructor with all the parameters needed passed in.
            </summary>
            <param name="cacheDirectory">This parameter specifies the cache directory of the tile cache.</param>
            <param name="cacheId">This parameter specifies the cache id of the tile cache.</param>
            <param name="imageFormat">This parameter specifies the image format of the tile cahce.</param>
            <param name="tileMatrix">This parameter specifies the tile matrix of the tile cache.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileBitmapTileCache.GetTileCore(System.Int64,System.Int64)">
            <summary>
            This method returns the BitmapTile corresponding to passed in row and column. 
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the BitmapTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileBitmapTileCache.SaveTileCore(ThinkGeo.MapSuite.Core.Tile)">
            <summary>
            This method will save the target tile passed in, you could override this API to create your own logic.
            </summary>
            <param name="tile">The target tile to be saved.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileBitmapTileCache.DeleteTileCore(ThinkGeo.MapSuite.Core.Tile)">
            <summary>
            This method will delete the target tile passed in.
            </summary>
            <param name="tile">The target tile to be deleted.</param>
            <remarks>This method will not take effect when the ReadOnly is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileBitmapTileCache.ClearCacheCore">
            <summary>
            This method will clear all the tiles in the tileCache.
            </summary>
            <remarks>This method will not take effect when the ReadOnly is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileBitmapTileCache.GetHigherScaleTileCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Double)">
            <summary>
            This method overrides the logic in its base class BitmapTileCache.
            This method will return the HigherScale BitmapTile which is always used for preview 
            effects when ZoomIn or ZoomOut.
            </summary>
            <param name="tileBoundingBox">The parameter specifies the current tile bounding box.</param>
            <param name="tileScale">This parameter specifies the current tile scale.</param>
            <returns>Returns the higher scale(higher zoomLevel) bitmap tile.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FileBitmapTileCache.CacheDirectory">
            <summary>
            Gets or sets the cache direcory.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Proj4Projection">
            <summary>
            This projection class uses the Proj4 engine to project data from one Srid to
            another.
            </summary>
            <remarks>
            This projection class uses the Proj4 engine to project data from one Srid to
            another. Proj4 is a very popular projection library the support thousands for
            projections. It uses a special text format to feed in parameters about the to and from
            projection. Though it uses its own format many organizations have recognized it and
            provide their projection definition in this format. Within this class we support the
            latest EPSG (European Petroleum Survey Group) SRID (Spatial Reference System
            Identifiers) list. You can find more information about these on the web. The SRID list
            is very popular and we include a text version with in our install.<br/>
            	<br/>
            Note that one thing that confuses people is that when they go to or from latitude and
            longitude they do not know what SRID to use. The proper SRID is 4326 for WGS84 pair
            coordinates in degrees with Greenwich as the central meridian.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Projection">
            <summary>
            This class represents a projection that you wish to apply to a
            FeatureSource.
            </summary>
            <remarks>
            This class is abstract and designed to be inherited to create your own
            projection. The derived projection classes are typically used on a FeatureSource or
            Layer. It is used to project coordinates from one projection to another and back again.
            It is important to note that you need to implement the projection both ways.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.#ctor">
            <summary>This method is the default protected constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.CloneDeep">
            <summary>Create a copy of Projection using the deep clone process.</summary>
            <returns>A cloned Projection.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.CloneDeepCore">
            <summary>Create a copy of GeoCanvas using the deep clone process. The default implementation uses serialization.</summary>
            <returns>A cloned GeoCanvas.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.Open">
            <remarks>
            This method opens the projection and gets it ready to use.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>This method opens the projection and gets it ready to use.</summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.OpenCore">
            <returns>None</returns>
            <remarks>
            As this is the core version of the Open method, it is intended to be overridden in an
            inherited version of the class. When overriding, you will be responsible for getting the
            projection classes' state ready for doing projections.
            </remarks>
            <summary>This method opens the projection and gets it ready to use.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.Close">
            <summary>
            This method closes the projection and gets it ready for serialization if
            necessary.
            </summary>
            <returns>None</returns>
            <remarks>
            This method closes the projection and gets it ready for serialization if
            necessary.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.CloseCore">
            <summary>
            This method closes the projection and gets it ready for serialization if
            necessary.
            </summary>
            <returns>None</returns>
            <remarks>
            As this is the core version of the Close method, it is intended to be overridden in
            an inherited version of the class. When overriding, you will be responsible freeing any
            state you have maintained and getting the class ready for serialization if necessary.
            Note that the object may be opened again, so you want to make sure you can open and
            close the object multiple times without any ill effects.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.ConvertToExternalProjection(System.Double,System.Double)">
            <summary>This method returns a projected vertex based on the coordinates passed in.</summary>
            <overloads>
            This overload projects a set of coordinates passed in as an X &amp; Y
            decimalDegreesValue.
            </overloads>
            <returns>This method returns a projected vertex based on the coordinates passed in.</returns>
            <remarks>
            This method returns a projected vertex based on the coordinates passed in.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="x">This parameter is the X decimalDegreesValue of the point that will be projected.</param>
            <param name="y">This parameter is the Y decimalDegreesValue of the point that will be projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.ConvertToExternalProjection(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns a projected BaseShape based on the baseShape passed
            in.
            </summary>
            <returns>This method returns a projected baseShape for the passed-in BaseShape.</returns>
            <remarks>
            This method returns a projected baseShape based on the BaseShape passed in.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="baseShape">This parameter is the baseShape (in decimalDegreesValue) to be projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.ConvertToExternalProjection(ThinkGeo.MapSuite.Core.Feature)">
            <remarks>
            This method returns a projected Feature based on the Feature passed in.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <returns>This method returns a projected Feature for the passed-in Feature.</returns>
            <summary>This method returns a projected Feature based on the Feature passed in.</summary>
            <param name="feature">
            This parameter is the Feature that contains a BaseShape in decimalDegreesValue
            to be projected.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.ConvertToExternalProjection(ThinkGeo.MapSuite.Core.RectangleShape)">
            <overloads>This overload takes in a rectangle to project.</overloads>
            <summary>This method returns a projected rectangle based on the rectangle passed in.</summary>
            <returns>This method returns a projected rectangle based on the rectangle passed in.</returns>
            <remarks>This method returns a projected rectangle based on the rectangle passed in.</remarks>
            <param name="rectangleShape">This parameter represents the rectangle you want to project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.ConvertToExternalProjectionCore(System.Double[],System.Double[])">
            <summary>
            This method returns projected vertices based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically, you can call the
            projection utility library that has interfaces for dozens of different types of
            projections.
            </remarks>
            <param name="x">This parameter is the X values of the points that will be projected.</param>
            <param name="y">This parameter is the Y values of the points that will be projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.ConvertToInternalProjection(System.Double,System.Double)">
            <summary>
            This method returns a de-projected vertex based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns a de-projected vertex based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a de-projected vertex based on the coordinates passed
            in.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <overloads>
            This overload de-projects a set of coordinates passed in as an X &amp; Y
            decimalDegreesValue.
            </overloads>
            <param name="x">This parameter is the X decimalDegreesValue of the point that will be de-projected.</param>
            <param name="y">This parameter is the Y decimalDegreesValue of the point that will be de-projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.ConvertToInternalProjection(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns a de-projected BaseShape based on the BaseShape passed
            in.
            </summary>
            <returns>This method returns a de-projected BaseShape for the passed in BaseShape.</returns>
            <remarks>
            This method returns a de-projected BaseShape based on the BaseShape passed
            in.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <param name="baseShape">This parameter is the baseShape (in decimalDegreesValue) to be de-projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.ConvertToInternalProjection(ThinkGeo.MapSuite.Core.Feature)">
            <summary>This method returns a de-projected Feature based on the Feature passed in.</summary>
            <remarks>
            This method returns a de-projected Feature based on the Feature passed in.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <returns>This method returns a de-projected Feature for the passed-in Feature.</returns>
            <param name="feature">
            This parameter is the Feature that contains a BaseShape in decimalDegreesValue
            to be de-projected.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.ConvertToInternalProjection(ThinkGeo.MapSuite.Core.RectangleShape)">
            <overloads>This overload takes in a rectangle to de-project.</overloads>
            <summary>
            This method returns a de-projected rectangle based on the rectangle passed
            in.
            </summary>
            <returns>
            This method returns a de-projected rectangle based on the rectangle passed
            in.
            </returns>
            <remarks>
            This method returns a de-projected rectangle based on the rectangle passed
            in.
            </remarks>
            <param name="rectangleShape">This parameter represents the rectangle you want to de-project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.ConvertToInternalProjectionCore(System.Double[],System.Double[])">
            <summary>
            This method returns de-projected vertices based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns de-projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a de-projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically, you can call the
            projection utility library that has interfaces for dozens of different types of
            projections. The de-projection is important because, inside of the FeatureSource, you
            will in many cases go to and from various projections.
            </remarks>
            <param name="x">This parameter is the X values of the points that will be de-projected.</param>
            <param name="y">This parameter is the Y values of the points that will be de-projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.ConvertToExternalProjection(System.Byte[])">
            <summary>
            This method returns projected well-known binary based on the well-known binary
            passed in.
            </summary>
            <returns>
            This method returns projected well-known binary based on the well-known binary
            passed in.
            </returns>
            <remarks>
            This method will project an entire shape in well-known binary. It is useful when
            you need to convert a large block of points.
            </remarks>
            <overloads>This overload takes in well-known binary to project.</overloads>
            <param name="wellKnownBinary">This parameter represents the well-known binary shape you wish to project.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Projection.ConvertToInternalProjection(System.Byte[])">
            <summary>
            This method returns de-projected well-known binary based on the well-known binary
            passed in.
            </summary>
            <returns>
            This method returns de-projected well-known binary based on the well-known binary
            passed in.
            </returns>
            <remarks>
            This method will de-project an entire shape in well-known binary. It is useful
            when you need to convert a large block of points.
            </remarks>
            <overloads>This overload takes in well-known binary to de-project.</overloads>
            <param name="wellKnownBinary">This parameter represents the well-known binary shape you wish to project.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Projection.IsOpen">
            <summary>This property gets the state of the projection (whether it is opened or closed).</summary>
            <decimalDegreesValue>This property gets the state of the projection (whether it is opened or closed).</decimalDegreesValue>
            <remarks>
            This method will reflect whether the projection is opened or closed. It is set in the
            concrete methods Open and Close, so if you inherit from this class and override
            OpenCore or CloseCore, you will not need to be concerned with setting this
            property.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Projection.CanReproject">
            <summary>
            This property indicates whether this projection should be used.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.#ctor">
            <summary>
            This is the default constructor for this class.
            </summary>
            <remarks>This conctructor pass nothing. After this cconstructor , you should 
            set the InternalProjectionParametersString property and ExternalProjectionParametersString 
            property before open to use.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in Proj4 text parameters for the to and from
            projection. The parameters typically look like "+proj=longlat +ellps=WGS84 +datum=WGS84
            +no_defs"
            </overloads>
            <returns>None</returns>
            <remarks>
            This constructor allows you to pass in Proj4 text parameters for the to and from
            projection. The parameters typically look like "+proj=longlat +ellps=WGS84 +datum=WGS84
            +no_defs" You should use this constructor when you know the parameters. If you know the
            SRID directly you can use the other constructor that takes the SRID.
            </remarks>
            <param name="internalProjectionParametersString">This parameter is the projection parameters describing the data.</param>
            <param name="externalProjectionParametersString">
            This parameter is the projection parameters describing the projection you want to
            go to.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.#ctor(System.Int32,System.Int32)">
            <summary>
            This is a constructor for the class.
            </summary>
            <returns>None</returns>
            <remarks>
            This constructor allows you to pass in Proj4 srid parameters for the to and from
            projection. The parameters typically look like 4320 stands for "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
            and 4604 stands for " +proj=longlat +ellps=clrk80 +towgs84=174,359,365,0,0,0,0 +no_defs".
            You should use this constructor when you know the parameters. If you know the
            SRID directly you can use the other constructor that takes the SRID.
            </remarks>
            <param name="internalEpsgSrid">This parameter is the projection srid parameter describing the data.</param>
            <param name="externalEpsgSrid">This parameter is the projection srid parameter describing the projection you want to go to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.Dispose">
            <summary>This is the dispose method for the class.</summary>
            <overloads>
            This dispose releases the handles of the Proj4 library. You should normally use
            Close instead of dispose unless you really want to never use this instance
            again.
            </overloads>
            <returns>None</returns>
            <remarks>
            	<para>This dispose releases the handles of the Proj4 library. You should normally
                use Close instead of dispose unless you really want to never use this instance
                again.<br/>
            		<br/>
                Normally when a layer is finished drawing it will call the Close of the projection
                class. This allows the object to be serialize but used again in the future. You
                should only use the Dispose method when you do not want to use this class
                again.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.OpenCore">
            <returns>None</returns>
            <remarks>
            As this is the core version of the Open method it is intended to be overridden in
            inherited version of the class. When overriding you will be responsible for getting the
            projection classes state ready for doing projections.<br/>
            	<br/>
            In this override we call the Proj4 methods get it ready for projection.
            </remarks>
            <summary>This method open the projection and gets it ready to use.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.CloseCore">
            <summary>
            This method closes the projection and gets it ready to serialization if
            necessary.
            </summary>
            <returns>None</returns>
            <remarks>
            As this is the core version of the Close method it is intended to be overridden
            in inherited version of the class. When overriding you will be responsible freeing any
            state you have maintained and getting the class ready to serialization if necessary.
            Note that the object may be opened again so you want to make sure you can open and
            close the object multiple tiles without any ill effects.<br/>
            	<br/>
            In this override we call the Proj4 methods get release the handles and memory.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.ConvertToExternalProjectionCore(System.Double[],System.Double[])">
            <summary>This method returns a projected vertex based on the coordinates passed in.</summary>
            <returns>
            This method returns a projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically you can call the
            projection utility library that has interfaces for dozens of different types of
            projections.
            </remarks>
            <param name="x">This parameter is the X values of the points that will be projected.</param>
            <param name="y">This parameter is the Y values of the points that will be projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.ConvertToInternalProjectionCore(System.Double[],System.Double[])">
            <summary>
            This method returns a de-projected vertex based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns a de-projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a de-projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically you can call the
            projection utility library that has interfaces for dozens of different types of
            projections. The de-projection is important because inside of the FeatureSource you
            will in many cases to to and from various projections.
            </remarks>
            <param name="x">This parameter is the X values of the points that will be de-projected.</param>
            <param name="y">This parameter is the Y values of the points that will be de-projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.Finalize">
            <summary>
            This is the dispose method for the class.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetEpsgParametersString(System.Int32)">
            <summary>
            This method is a static API to get a projection text from EPSG(European Petroleum Survey Group).
            </summary>
            <remarks>More information about it can reference to EPSG.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetEpsgParameters(System.Int32)">
            <summary>
            This method is a API to get a projection text from EPSG(European Petroleum Survey Group).
            </summary>
            <remarks>More information about it can reference to EPSG.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetEsriParametersString(System.Int32)">
            <summary>
            This method is a static API to get a projection text from ERSI.
            </summary>
            <remarks>More information about it can reference to ERSI.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetEsriParameters(System.Int32)">
            <summary>
            This method is a API to get a projection text from ERSI.
            </summary>
            <remarks>More information about it can reference to ERSI.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetEsriExtraParametersString(System.Int32)">
            <summary>
            This method is a static API to get a projection text from ERSI Extra projections.
            </summary>
            <remarks>More information about it can reference to ESRI.extra.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetEsriExtraParameters(System.Int32)">
            <summary>
            This method is a API to get a projection text from ERSI Extra projections.
            </summary>
            <remarks>More information about it can reference to ESRI.extra.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetGL27ParametersString(System.String)">
            <summary>
            This method is a static API to get a projection text from GL27 Extra projections.
            </summary>
            <remarks>More information about it can reference to GL27.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetGL27Parameters(System.String)">
            <summary>
            This method is a API to get a projection text from GL27 Extra projections.
            </summary>
            <remarks>More information about it can reference to GL27.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetNad27ParametersString(System.Int32)">
            <summary>
            This method is a static API to get a projection text from Nad27 Extra projections.
            </summary>
            <remarks>More information about it can reference to Nad27.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetNad27Parameters(System.Int32)">
            <summary>
            This method is a API to get a projection text from Nad27 Extra projections.
            </summary>
            <remarks>More information about it can reference to Nad27.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetNad83ParametersString(System.Int32)">
            <summary>
            This method is a static API to get a projection text from Nad83 Extra projections.
            </summary>
            <remarks>More information about it can reference to Nad83.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetNad83Parameters(System.Int32)">
            <summary>
            This method is a API to get a projection text from Nad83 Extra projections.
            </summary>
            <remarks>More information about it can reference to Nad83.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetOtherExtraParametersString(System.Int32)">
            <summary>
            This method is a static API to get a projection text from other projections except EPSG
            ,ERSI, ERSIExtra,GL27,NAD27,NAD83,World.
            </summary>
            <remarks>More information about it can reference to Other.extra.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetOtherExtraParameters(System.Int32)">
            <summary>
            This API is to get a projection text from other projections except EPSG
            ,ERSI, ERSIExtra,GL27,NAD27,NAD83,World.
            </summary>
            <remarks>More information about it can reference to Other.extra.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetWorldParametersString(System.String)">
            <summary>
            This method is a static API to get a projection text from World projections.
            </summary>
            <remarks>More information about it can reference to World.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetWorldParameters(System.String)">
            <summary>
            This method is a API to get a projection text from World projections.
            </summary>
            <remarks>More information about it can reference to World.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetGoogleMapParametersString">
            <summary>
            This method is a static API to get a projection used by GoogleMap.
            </summary>
            <returns>A text for a projection used by GoogleMap , it should like this "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj4Projection.GetGoogleMapParameters">
            <summary>
            This method is a static API to get a projection used by GoogleMap.
            </summary>
            <returns>A text for a projection used by GoogleMap , it should like this "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Proj4Projection.DecimalDegreeBoundary">
            <summary>This property specifies the Boundary for decimaldegree values.</summary>
            <remarks>
            	<para>The default boundary is(-179.9, 89.9, 179.9, -89.9). That means when I want
                to project a PointShape(-179,91,89.91) out, in fact what it projects is
                (-179.9,89.9) because of its out of boundary.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Proj4Projection.InternalProjectionParametersString">
            <summary>
            Gets or sets the Proj4 text parameter for the from projection. This parameter
            typically look like "+Proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs".
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Proj4Projection.ExternalProjectionParametersString">
            <summary>
            Gets or sets the Proj4 text parameter for the to projection. This parameter
            typically look like "+proj=utm +zone=33 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs".
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GridFeatureSource">
            <summary>
            Reads cell data from a grid file and displays them in appropriate colors based on
            their values.
            </summary>
            <remarks>
                The <strong>GridFeatureSource</strong> displays cells with different colors in a
                rectangle area of map. The color of a cell depends on the cell value in the grid
                file. The grid file provides information about the grid, such as rows and columns
                number, cordinate of lower left corner, cell size, and values of cells. 
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GridFeatureSource.#ctor">
            <summary>This is the constructor the for the class. If you use this constructor then you need to set
            the required properties manually.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GridFeatureSource.#ctor(System.String)">
            <summary>This is the class constructor.</summary>
            <overloads>
            This constructor allows you to pass in a path and file name.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="gridPathFilename">This parameter represents the path and file name to the grid file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GridFeatureSource.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has already been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concreate public method Open.
            The open method play an important role as it is responsible for initializing the
            FeatureSource. Most methods on the FeatureSource will throw an exception if the state
            of the FeatureSource is not opened. When the map draws each layer it will open the
            FeatureSource as one of its first steps, then after it is finished drawing with that
            layer it will close it. In this way we are sure to release all resources used by the
            FeatureSource.<br/>
            	<br/>
            When implementing this virtual method consider opening files for file based source,
            connecting to databases in the database based sources and so on. You will get a chance
            to close these in the Close method of the FeatureSource.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GridFeatureSource.CloseCore">
            <summary>
            This method closes the FeatureSource and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concreate public method Close.
            The close method plays an important role in the life cycle of the FeatureSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            It is recommended that if you override this method that you take the following things
            into account. This method may be called multiple times so we suggest you write the so
            that that a call to a closed FeatureSource is ignored and does not generate an error.
            We also suggest that in the close you free all resources that have been opened.
            Remember that the object will not be destroyed but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GridFeatureSource.GetColumnsCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the columns available for the FeatureSource.</summary>
            <remarks>
            As this is the virtual core version of the Columns method it is intended to
            be overridden in inherited version of the class. When overriding you will be
            responsible for getting a list of all of the columns supported by the FeatureSource. In
            this way the FeatureSource will know what columns are available and will remove any
            extra columns when making calls to other core methods. For example if you have a
            FeatureSource that has three columns of information and the user calls a method and
            requests four columns of information, something they can do with custom fields, we will
            first compare what they are asking for to the results of the GetColumnsCore. In this
            way we can strip out custom columns before calling other Core methods which are only
            responsible for returning data in the FeatureSource. For more information on custom
            fields you can see the documentation on the OnCustomFieldsFetch.
            </remarks>
            <returns>This method returns the columns available for the FeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GridFeatureSource.CommitTransactionCore(ThinkGeo.MapSuite.Core.TransactionBuffer)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction it will throw an InvalidOperationException.</exception>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
            <remarks>
            	<para>This method will commit the existing transaction to its underlying source of
                data. It will pass back the results of how the commit went to include any error
                received. If you are implementing your own FeatureSource then this is one of the
                crucial methods you must create. It should be fairly straight forward that you will
                loop through the transaction buffer and add, edit or delete the InternalFeatures in your
                underlying data source. Remember to build and pass back the TransactionResult class
                so that users of your FeatureSource can respond to failures you may encounter
                committing the InternalFeatures. We will handle the end of the transaction and also the
                cleanup of the transaction buffer. Your task will be to commit the records and
                produce a TransactionResult return.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited
                implementation of any specific source such as Oracle Spatial or Shape files. In
                this way it functions the same way for every FeatureSource. You start by calling
                the BeginTransaction. This allocates a collection of in memory change buffers that
                are used to store changes until you commit the transaction. So for example when you
                call the Add, Delete or Update method the changes to the feature are stored in
                memory only. If for any reason you choose to abandon the transaction you can call
                RollbackTransaction at any time and the in memory buffer will be deleted and the
                changes will be lost. When you are ready to commit the transaction you call the
                CommitTransaction and the collections of changes are then passed to the
                CommitTransactionCore method and the implementer of the specific FeatureSource is
                responsible for integrating your changes into the underlying FeatureSource. By
                default the IsLiveTransaction property is set to false which means that until you
                commit the changes the FeatureSource API will not reflect any changes that are in
                the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true then things function
                slightly differently. The live transaction concept means that all of the
                modification you perform during a transaction are live from the standpoint of the
                querying methods on the object.</para>
            	<para>To setup an example imagine that you have a FeatureSource that has 10 records
                in it. Next you begin a transaction and then call GetAllFeatures, the result would
                be 10 records. After that you call a delete on one of the records and call the
                GetAllFeatures again, this time you only get nine records. You receive nine records
                even though the transaction has not yet been committed. In the same sense you could
                have added a new record or modified an existing one and those changes are
                considered live though not committed.</para>
            	<para>In the case where you modify records such as expanding the size of a polygon
                those changes as well are reflected. So for example you expand a polygon by
                doubling its size and then do a spatial query that would not normally return the
                smaller record but would return the larger records, in this case the larger record
                is returned. You can set this property to be false as well in which case all of the
                spatial related methods would ignore anything that is currently in the transaction
                buffer waiting to be committed. In this case only after committing the transaction
                would the FeatureSource reflect the changes.</para>
            </remarks>
            <returns>
            The return decimalDegreesValue of this method is a TransactionResult class which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful and any error that were encountered during the
            committing of the transaction.
            </returns>
            <param name="transactions">
            This parameter encapsulates all of the adds, edits and deleted that make up the
            transaction. You will use this data to write the changes to your underlying data
            source.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GridFeatureSource.GetAllFeaturesCore(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. You will not need
            to consider anything about pending transactions as this will be handled in the non Core
            version of the method.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We wanted as the framework developers to provide you
            the user with as much default virtual implementation as possible. To do this we needed
            a way to get access to all of the features. For example, we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all the records then we can brute force
            the answer. In this way if you inherited form this class and only implemented this one
            method we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource
            it comes with a price. The price is that it is very inefficient. In the case we just
            discussed about finding all of the InternalFeatures in a bounding box we would not want to look
            at every record to fulfil this method. Instead we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be fast. For
            example in Oracle Spatial there is a specific SQL statement to do this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. It will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.
            </remarks>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GridFeatureSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetBoundingBox. It does not take into account any transaction activity as this is
                the responsibility of the concreate public method GetBoundingBox. In this way as a
                developer if you choose to override this method you do not have to consider
                transaction at all.<br/>
            		<br/>
                The default implementation of GetBoundingBoxCore uses the GetAllRecordsCore method
                to calculate the bounding box of the FeatureSource. We strongly recommend that you
                provide your own implementation for this method that will be more efficient<br/>
            		<br/>
                If you do not override this method the means it gets the BoundingBox is by calling
                the GetAllFeatureCore method and deriving it from each feature. This is a very
                inefficient way to get the BoundingBox in most data sources. It is highly
                recommended that you override this method and replace it with a highly optimized
                version. For example in a ShapeFile the BoundingBox is in the main header of the
                file. Similarly if you are using Oracle Spatial you can execute a simple query to
                get the BoundingBox of all of the record without returning them. In these ways you
                can greatly improve the performance of this method.</para>
            </remarks>
            <summary>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </summary>
            <returns>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GridFeatureSource.GetCountCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <summary>
            This method returns the count of the number of records in this
            FeatureSource.
            </summary>
            <returns>
            This method returns the count of the number of records in this
            FeatureSource.
            </returns>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetCount. It does not take into account any transaction activity as this is the
                responsibility of the concreate public method GetCount. In this way as a developer
                if you choose to override this method you do not have to consider transaction at
                all.<br/>
            		<br/>
                The default implementation of GetCountCore uses the GetAllRecordsCore method to
                calculate how many records there are in the FeatureSource. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient<br/>
            		<br/>
                If you do not override this method the means it gets the count is by calling the
                GetAllFeatureCore method and counting each feature. This is a very inefficient way
                to get the count in most data sources. It is highly recommended that you override
                this method and replace it with a highly optimized version. For example in a
                ShapeFile the record count is in the main header of the file. Similarly if you are
                using Oracle Spatial you can execute a simple query to get the count of all of the
                record without returning them. In these ways you can greatly improve the
                performance of this method.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GridFeatureSource.GetFeaturesInsideBoundingBoxCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box.
            </summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions as this is handled by the concreate version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesInsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding box. We
            strongly recommend that you provide your own implementation for this method that will
            be more efficient. It is especially important for this method as many other default
            virtual methods use this for their calculations. We highly recommend when you override
            this method that you use any spatial indexes you have at your disposal to make this
            method as fast as possible.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GridFeatureSource.PathFilename">
            <summary>This property gets and sets the path and file of the grid file you want to use.</summary>
            <decimalDegreesValue>This property returns the path and file of the grid file you want to use.</decimalDegreesValue>
            <remarks>
            When you specify the path and file name it should be in the correct format.
            If the path and filename you provided we cannot find it then we will throw an exception.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GridFeatureSource.CellSize">
            <summary>
            Gets the cell size of the grid.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GridFeatureSource.NumberOfColumns">
            <summary>
            Gets column number of the grid.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GridFeatureSource.NumberOfRows">
            <summary>
            Gets row number of the grid.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GridFeatureSource.LowerLeftPoint">
            <summary>
            Gets LowerLeft PointShape of the grid.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GridFeatureSource.NoDataValue">
            <summary>
            Gets the NoDataValue in the grid.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GridFeatureSource.IsEditable">
            <summary>This property returns if the FeatureSource allows edits or is read only.</summary>
            <decimalDegreesValue>
            This property returns if the FeatureSource allows edits or is read only. The
            property returns true if the FeatureSource allows edits and false if the FeatureSource
            is read only.
            </decimalDegreesValue>
            <remarks>
            	<para>This property is useful to check if a specific FeatureSource accepts editing.
                If you call the BeginTransaction and this property is false then an exception will
                be raised.<br/>
            		<br/>
                For developers who are creating or extending a FeatureSource it is expected that
                you override this virtual method if the new FeatureSource you are creating allows
                edits. By default the decimalDegreesValue if false meaning that if you want to allow edits you
                must override this method and return true.</para>
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ComFunc">
            <summary>
            Definition of static Class ComFunc for the math or the adjustment function
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.Adjlon(System.Double,System.Int32@)">
            <summary>
            adjust the deviation for the variable lon
            </summary>
            <param name="lon">lon is the variable that it will be adjusted</param>
            <returns>adjusted variable</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.aasin(System.Double,System.Int32@)">
            <summary>
            the function will be done when the asin's parameter has some deviation
            </summary>
            <param name="v">the parameter of be adjusted</param>
            <returns>has been coculated the result by adjusted</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.aatan2(System.Double,System.Double,System.Int32@)">
            <summary>
            it will be called to coculate for atan2 when parameters of the atan2 function have some deviation
            </summary>
            <param name="n">the y parameter of atan2</param>
            <param name="d">the x parameter of atan2</param>
            <returns>the result of coculated that parameters has been adjusted</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.aacos(System.Double,System.Int32@)">
            <summary>
            it will be called to coculate for acos when the parameter of the acos function have some deviation
            </summary>
            <param name="v">the parameter of aacos</param>
            <returns>the result of coculated that parameters has been adjusted</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.asqrt(System.Double,System.Int32@)">
            <summary>
            it will be called to coculate for sqrt when the parameter of the sqrt function have some deviation
            </summary>
            <param name="v">the parameter that it have some deviation</param>
            <returns>the result of coculated that parameters has been adjusted</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.GetParam(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Int32@)">
            <summary>
            Get the system's parameters through parameters of called line
            </summary>
            <param name="paras">the general collection of handled</param>
            <param name="param">the original parameter</param>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.Dmstor(System.String,System.Int32@)">
            <summary>
            get the real result when the parameter is a string
            </summary>
            <param name="p">the string will be converted</param>
            <returns>double value</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.proj_strtod(System.String,System.String@)">
            <summary>
            make the parameter of a string to a double value
            </summary>
            <param name="handleStr">the parameter that it will be done</param>
            <param name="tempStr">the string will be remained after the parameter changed</param>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.GetTag(System.String)">
            <summary>
            get symbol char after substring &lt; and &gt;
            </summary>
            <param name="lineStr">command line string</param>
            <returns>result of handled string</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.GetDefaultConfigFile(System.String,System.IO.FileAccess)">
            <summary>
            get parameters by file path if parameters have 'nodef'
            </summary>
            <param name="filePath">file path string</param>
            <param name="fileAccess">permission of file</param>
            <returns>file stream</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.IsLSB">
            <summary>
            determine the os is LSB or not
            </summary>
            <returns>the OS is LSB then return true else return false</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.SwapWords(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            swap the sequence of binary data
            </summary>
            <param name="data">binary buffer</param>
            <param name="offsetIndex">the offset index</param>
            <param name="wordSize">the word's size</param>
            <param name="wordCount">the number of changing</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.ConvertByteArrayToString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            make the binary buffer to string
            </summary>
            <param name="characters">binary buffer</param>
            <param name="index">handling index</param>
            <param name="count">the number of handling</param>
            <returns>transformed string</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.ConvertByteArrayToInt32(System.Byte[],System.Int32,System.Int32,System.Int32@)">
            <summary>
            make the binary buffer to int32
            </summary>
            <param name="byteArray">binary buffer</param>
            <param name="index">handling index</param>
            <param name="count">the number of handling</param>
            <returns>the result of int32</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.ConvertByteArrayToDouble(System.Byte[],System.Int32,System.Int32)">
            <summary>
            make the binary buffer to double value
            </summary>
            <param name="byteArray">binary buffer</param>
            <param name="index">handling index</param>
            <param name="count">the number of handling</param>
            <returns>the value of double</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ComFunc.GetValidStrByAlphaStart(System.String)">
            <summary>
            valid the string of not a number
            </summary>
            <param name="param">the validing string</param>
            <returns>valided string</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.TileAccessMode">
            <summary>This enumeration represents how the tileCache should access the tiles.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.TileAccessMode.Default">
            <summary>The default mode is ReadAddDelete.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.TileAccessMode.ReadOnly">
            <summary>This mode represents the tileCache just can read tiles from it.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.TileAccessMode.ReadAdd">
            <summary>This mode represents the tileCache can read tiles from it and add tiles to it, but can not delete tiles.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.TileAccessMode.ReadAddDelete">
            <summary>This mode represents the tileCache is no limited that can read, add, delete tiles.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Resources.String">
            <summary>
              Looks up a localized string similar to NoData.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MultipointShape">
            <summary>This class represents one or more point shapes.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PointBaseShape">
            <summary>
            This abstract class is the root of all point-based shapes, such as PointShape
            and MultiPointShape.
            </summary>
            <remarks>
            	<para>This class is used as the base class for point shapes such as:<br/>
            		<br/>
                PointShape<br/>
                MultiPointShape<br/>
            		<br/>
                It can be inherited from to create your own specialized point geometry. If you
                choose to do this, your new class must conform to one of the well-known text standard
                shapes in order for the base implementations to work properly.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointBaseShape.#ctor">
            <summary>This is the default constructor for PointBaseShape.</summary>
            <remarks>This constructor simply calls the base constructor.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.#ctor">
            <summary>This constructor creates a MultipointShape.</summary>
            <overloads>This overload creates the MultipointShape without any points.</overloads>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.PointShape})">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the points, we will throw an ArgumentNullException.</exception>
            <summary>This constructor creates a MultipointShape by passing in predefined points.</summary>
            <overloads>This constructor creates a MultipointShape by passing in predefined points.</overloads>
            <param name="points">This parameter specifies the points passed into the MultiPointShape.</param>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature})">
            <summary>This constructor creates a MultipointShape by passing in predefined point features.</summary>
            <overloads>This constructor creates a MultipointShape by passing in predefined point features.</overloads>
            <param name="pointFeatures">This parameter specifies the points passed into the MultiPointShape.</param>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.#ctor(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This constructor creates a MultipointShape by passing in a Multipoint type Feature.
            </summary>
            <param name="multipointFeature">This parameter specifies the Multipoint feature that will be used to create the Multipoint shape.</param>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a feature that contains a shape which is not a MultipointShape, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the MultipointShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates the LineShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and the copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.ScaleUp(System.Double)">
            <summary>
            This method increases the size of the shape by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <param name="percentage">This is the percentage by which to increase the shape’s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the shape by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <param name="percentage">This is the percentage by which to increase the shape’s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.ScaleDown(System.Double)">
            <summary>
            This method decreases the size of the shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to decrease the shape’s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to decrease the shape’s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.ConvexHull">
            <summary>
            This method returns the convex hull of the shape (defined as the smallest convex
            ring that contains all the points in the shape).
            </summary>
            <returns>
            This method returns the convex hull of the shape (defined as the smallest convex
            ring that contains all the points in the shape).
            </returns>
            <remarks>
            This method is useful when you want to create a perimeter around the shape. For
            example, if you had a MultiPolygon which represented buildings on a campus, you could
            easily get the convex hull of the buildings and determine the perimeter of all of the
            buildings together. This also works with MultiPoint shapes, where each point may
            represent a certain type of person you are doing statistics on. With convex hull, you
            can get an idea of the regions those points are located in.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.ConvexHullCore">
            <summary>
            This method returns the convex hull of the shape (defined as the smallest convex
            ring that contains all the points in the shape).
            </summary>
            <returns>
            This method returns the convex hull of the shape (defined as the smallest convex
            ring that contains all the points in the shape).
            </returns>
            <remarks>
            This method is useful when you want to create a perimeter around the shape. For
            example, if you had a MultiPolygon which represented buildings on a campus, you could
            easily get the convex hull of the buildings and determine the perimeter of all of the
            buildings together. This also works with MultiPoint shapes, where each point may
            represent a certain type of person you are doing statistics on. With convex hull, you
            can get an idea of the regions those points are located in.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.RegisterCore(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on the DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another based on an X
                and Y offset distance. It is important to note that with this overload the X and Y
                offset units are based off of the distanceUnit parameter. For example if your shape
                is in decimal degrees and you call this method with an X offset of one and a Y
                offset of one and you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way you can easily move a shape in decimal degrees five miles to
                on the X axis and 3 miles on the Y axis.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure of the
                translate. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the shape from one location to another based on a
            direction in degrees and distance.
            </summary>
            <overloads>In this overload the distance is in the same GeographicUnit as the shape.</overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an
                angleInDegrees and distance parameter. With this overload, it is important to note
                that the distance units are the same GeographicUnit as the shape. For example,
                if your shape is in decimal degrees and you call this method with a distance of 1,
                you're going to move this shape 1 decimal degree in direction of the
                angleInDegrees. In many cases it is more useful to specify the DistanceUnit of movement,
                such as in miles or yards, so for these scenarios there is another overload you may
                want to use instead.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="distance">
            The distance is the number of units to move the shape in the angle specified. The
            distance unit will be the same as the GeographyUnit for the shape. The distance must be
            greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.RotateCore(ThinkGeo.MapSuite.Core.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.GetClosestPointToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box’s upper left and lower right
                points will be equal. This will create a RectangleShape with no area.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.GetDistanceToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <returns>
            This method returns the distance between the current shape and the
            targetShape.
            </returns>
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <remarks>None</remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.GetWellKnownTextCore">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric shapes.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Core.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe a geometry as a binary array. Well-known
            binary is useful when you want to save a geometry in an efficient format using as little
            space as possible. An alternative to well-known binary is well-known text, which is a
            textual representation of a geometry object. We have methods that work with well-known
            text as well.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies whther the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.ValidateCore(ThinkGeo.MapSuite.Core.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.GetCrossingCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.RemoveVertex(ThinkGeo.MapSuite.Core.Vertex,ThinkGeo.MapSuite.Core.MultipointShape)">
            <summary>
            This method removes the point which the same coordinate as selected vertex from multipoint shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be the same coordinate as a point of multipoint shape, otherwise it will return false and multipoint shape will keep the same.</param>
            <param name="multipointShape">The multipoint shape will be removed one vertex.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipointShape.RemoveVertex(ThinkGeo.MapSuite.Core.Vertex)">
            <summary>
            This method removes the point which the same coordinate as selected vertex from multipoint shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be the same coordinate of a point of multipoint shape, otherwise it will return false and multipoint shape will keep the same.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultipointShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <decimalDegreesValue>This property specifies whether the shape can be rotated.</decimalDegreesValue>
            <remarks>
            If this property returns false and you attempt call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultipointShape.Points">
            <summary>
            This property is the collection of points that make up the
            MultipointShape.
            </summary>
            <decimalDegreesValue>
            This property is the collection of PointShapes that make up the
            MultipointShape.
            </decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LineBaseShape">
            <summary>
            This abstract class is the root of all line-based shapes, such as LineShape
            and MultilineShape.
            </summary>
            <remarks>
            	<para>This class is used as the base class for line shapes such as:<br/>
            		<br/>
                LineShape<br/>
                MultilineShape<br/>
            		<br/>
                It can be inherited from to create your own specialized line geometry. If you
                choose to do this, your new class must conform to one of the well-known text standard
                shapes in order for the base implementations to work properly.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.#ctor">
            <summary>This is the default constructor for AreaBaseShape.</summary>
            <remarks>This constructor simply calls the base constructor.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.GetLength(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This method returns the length of the line shape.</summary>
            <overloads>
            This overload returns the length in the unit of your choice, based on
            the returningUnit parameter specified.
            </overloads>
            <returns>
            This overload returns the length in the unit of your choice, based on
            the returningUnit parameter specified.
            </returns>
            <remarks>
            This is a useful method when you want to know the total length of a line-based
            shape. If the shape is a MultiLineShape, then the length is the sum of all of its
            lines.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the distance unit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.GetLengthCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This method returns the length of the line shape.</summary>
            <overloads>
            This overload returns the length in the unit of your choice, based on
            the returningUnit parameter specified.
            </overloads>
            <returns>
            This overload returns the length in the unit of your choice, based on
            the returningUnit parameter specified.
            </returns>
            <remarks>
            This is a useful method when you want to know the total length of a line-based
            shape. If the shape is a MultiLineShape, then the length is the sum of all of its
            lines.
            	<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the distance unit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.ScaleUp(ThinkGeo.MapSuite.Core.LineBaseShape,System.Double)">
            <summary>
            This method returns a new shape that is increased by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster as you apply the operation
            multiple times. There is also a ScaleDown method that will shrink the shape as
            well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method we reserve the right to
            add events and other logic to pre or post process data returned by the Core version of
            the method. In this way we leave our framework open on our end but also allow you the
            developer to extend our logic to your needs. If you have questions about this please
            contact support as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="sourceShape">This parameter is the basis for the scale up up but is not modified.</param>
            <param name="percentage">This is the percentage by which to increase the shape’s size.</param>
            <returns>a scaled line type shape.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.ScaleUp(ThinkGeo.MapSuite.Core.Feature,System.Double)">
            <summary>
            This method returns a new feature that is increased by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to increase the size of the feature. Note
            that a larger percentage will scale the shape up faster as you apply the operation
            multiple times. There is also a ScaleDown method that will shrink the shape as
            well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method we reserve the right to
            add events and other logic to pre or post process data returned by the Core version of
            the method. In this way we leave our framework open on our end but also allow you the
            developer to extend our logic to your needs. If you have questions about this please
            contact support as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="sourceLine">This parameter is the basis for the scale up up but is not modified.</param>
            <param name="percentage">This is the percentage by which to increase the shape’s size.</param>
            <returns>a scaled line type feature.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.ScaleUp(System.Double)">
            <summary>
            This method increases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster as you apply the operation
            multiple times. There is also a ScaleDown method that will shrink the shape as
            well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method we reserve the right to
            add events and other logic to pre or post process data returned by the Core version of
            the method. In this way we leave our framework open on our end but also allow you the
            developer to extend our logic to your needs. If you have questions about this please
            contact support as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to increase the shape’s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster as you apply the operation
            multiple times. There is also a ScaleDown method that will shrink the shape as
            well.
            	<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to increase the shape’s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.ScaleDown(ThinkGeo.MapSuite.Core.LineBaseShape,System.Double)">
            <summary>
            This method returns a new shape that is decreases by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster as you apply the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape as
            well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method we reserve the right to
            add events and other logic to pre or post process data returned by the Core version of
            the method. In this way we leave our framework open on our end but also allow you the
            developer to extend our logic to your needs. If you have questions about this please
            contact support as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="sourceLineBaseShape">This parameter is the basis for the scale up up but is not modified.</param>
            <param name="percentage">This is the percentage by which to decrease the shape’s size.</param>
            <returns> a scaled down line type shape.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.ScaleDown(ThinkGeo.MapSuite.Core.Feature,System.Double)">
            <summary>
            This method returns a new feature that is decreases by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to decrease the size of the feature. Note
            that a larger percentage will scale the shape down faster as you apply the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape as
            well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method we reserve the right to
            add events and other logic to pre or post process data returned by the Core version of
            the method. In this way we leave our framework open on our end but also allow you the
            developer to extend our logic to your needs. If you have questions about this please
            contact support as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="sourceLine">This parameter is the basis for the scale up up but is not modified.</param>
            <param name="percentage">This is the percentage by which to decrease the shape’s size.</param>
            <returns> a scaled down line type feature.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.ScaleDown(System.Double)">
            <summary>
            This method decreases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster as you apply the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape as
            well.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method we reserve the right to
            add events and other logic to pre or post process data returned by the Core version of
            the method. In this way we leave our framework open on our end but also allow you the
            developer to extend our logic to your needs. If you have questions about this please
            contact support as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to decrease the shape’s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster as you apply the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape as
            well.
            	<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to decrease the shape’s size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.ConvexHull">
            <summary>
            This method returns the convex hull of the shape defined as the smallest convex
            ring that contains all the points in the shape.
            </summary>
            <returns>
            This method returns a RingShape defined as the smallest convex ring that contains
            all the points in the shape.
            </returns>
            <remarks>
            This method is useful when you want to create a perimeter around the shape. For
            example if you had a MultiPolygon which represented buildings in a campus you could
            easily get the convex hull of the buildings and determine the perimeter of all of the
            buildings together. This also works with MultiPoint shapes where each point may
            represent a certain type of person you are doing statistics on. With convex hull you
            can get an idea of the regions those points are located in.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method we reserve the right to
            add events and other logic to pre or post process data returned by the Core version of
            the method. In this way we leave our framework open on our end but also allow you the
            developer to extend our logic to your needs. If you have questions about this please
            contact support as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.ConvexHullCore">
            <summary>
            This method returns the convex hull of the shape defined as the smallest convex
            ring that contains all the points in the shape.
            </summary>
            <returns>
            This method returns a RingShape defined as the smallest convex ring that contains
            all the points in the shape.
            </returns>
            	<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            <remarks>
            This method is useful when you want to create a perimeter around the shape. For
            example, if you had a MultiPolygon that represented buildings on a campus, you could
            easily get the convex hull of the buildings and determine the perimeter of all of the
            buildings together. This also works with MultiPoint shapes, where each point may
            represent a certain type of person you are doing statistics on. With convex hull, you
            can get an idea of the regions those points are located in.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.Simplify(ThinkGeo.MapSuite.Core.LineBaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Double,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.SimplificationType)">
            <summary>
            Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.
            </summary>
            <param name="targetShape">target shape which will be simplified.</param>
            <param name="targetShapeUnit">the geography unit of the target shape</param>
            <param name="toleranceUnit">the distance unit of tolerance</param>
            <param name="tolerance">distance tolerance</param>
            <param name="simplificationType">Specifies which algorthm will be use to simplify.</param>
            <returns>Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="System.ArgumentOutOfRangeException">Passing an invalid tolerance which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid simplificationType will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid shapeUnit will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid toleranceUnit will thrown an ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.Simplify(ThinkGeo.MapSuite.Core.LineBaseShape,System.Double,ThinkGeo.MapSuite.Core.SimplificationType)">
            <summary>
            Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.
            </summary>
            <returns>Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="System.ArgumentOutOfRangeException">Passing an invalid tolerance which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid simplificationType will thrown an ArgumentOutOfRangeException.</exception>
            <param name="targetShape">target shape which will be simplified.</param>
            <param name="tolerance">distance tolerance</param>
            <param name="simplificationType">Specifies which algorthm will be use to simplify.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.Simplify(ThinkGeo.MapSuite.Core.GeographyUnit,System.Double,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.SimplificationType)">
            <summary>
            Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.
            </summary>
            <param name="shapeUnit">the geography unit of the target shape</param>
            <param name="toleranceUnit">the distance unit of tolerance</param>
            <param name="tolerance">distance tolerance</param>
            <param name="simplificationType">Specifies which algorthm will be use to simplify.</param>
            <returns>Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="System.ArgumentOutOfRangeException">Passing an invalid tolerance which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid simplificationType will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid shapeUnit will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid toleranceUnit will thrown an ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.Simplify(System.Double,ThinkGeo.MapSuite.Core.SimplificationType)">
            <summary>
            Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.
            </summary>
            <returns>Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="System.ArgumentOutOfRangeException">Passing an invalid tolerance which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid simplificationType will thrown an ArgumentOutOfRangeException.</exception>
            <param name="tolerance">distance tolerance</param>
            <param name="simplificationType">Specifies which algorthm will be use to simplify.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineBaseShape.SimplifyCore(System.Double,ThinkGeo.MapSuite.Core.SimplificationType)">
            <summary>
            Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.
            </summary>
            <param name="tolerance">distance tolerance</param>
            <param name="simplificationType">Specifies which algorthm will be use to simplify.</param>
            <returns>Simplify the LineBaseShape to MultilineShape depends on distance tolerance and different SimplificationType.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="System.ArgumentOutOfRangeException">Passing an invalid tolerance which is less than 0 will thrown an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid simplificationType will thrown an ArgumentOutOfRangeException.</exception>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.StandardColors">
            <summary>
            This class is a convenient way to access a predefined set of standard
            colors.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.ActiveBorder">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.ActiveCaption">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.ActiveCaptionText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.AppWorkspace">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Control">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.ControlDark">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.ControlDarkDark">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.ControlLight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.ControlLightLight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.ControlText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Desktop">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.GrayText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Highlight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.HighlightText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.HotTrack">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.InactiveBorder">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.InactiveCaption">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.InactiveCaptionText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Info">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.InfoText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Menu">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MenuText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.ScrollBar">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Window">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.WindowFrame">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.WindowText">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Transparent">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.AliceBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.AntiqueWhite">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Aqua">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Aquamarine">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Azure">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Beige">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Bisque">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Black">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.BlanchedAlmond">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Blue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.BlueViolet">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Brown">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.BurlyWood">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.CadetBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Chartreuse">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Chocolate">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Coral">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.CornflowerBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Cornsilk">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Crimson">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Cyan">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkCyan">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkGoldenrod">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkKhaki">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkMagenta">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkOliveGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkOrange">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkOrchid">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkSalmon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkSeaGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkSlateBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkSlateGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkTurquoise">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DarkViolet">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DeepPink">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DeepSkyBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DimGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.DodgerBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Firebrick">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.FloralWhite">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.ForestGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Fuchsia">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Gainsboro">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.GhostWhite">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Gold">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Goldenrod">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Gray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Green">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.GreenYellow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Honeydew">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.HotPink">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.IndianRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Indigo">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Ivory">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Khaki">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Lavender">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LavenderBlush">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LawnGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LemonChiffon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LightBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LightCoral">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LightCyan">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LightGoldenrodYellow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LightGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LightGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LightPink">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LightSalmon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LightSeaGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LightSkyBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LightSlateGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LightSteelBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LightYellow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Lime">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.LimeGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Linen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Magenta">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Maroon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MediumAquamarine">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MediumBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MediumOrchid">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MediumPurple">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MediumSeaGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MediumSlateBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MediumSpringGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MediumTurquoise">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MediumVioletRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MidnightBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MintCream">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MistyRose">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Moccasin">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.NavajoWhite">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Navy">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.OldLace">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Olive">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.OliveDrab">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Orange">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.OrangeRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Orchid">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.PaleGoldenrod">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.PaleGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.PaleTurquoise">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.PaleVioletRed">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.PapayaWhip">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.PeachPuff">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Peru">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Pink">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Plum">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.PowderBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Purple">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Red">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.RosyBrown">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.RoyalBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.SaddleBrown">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Salmon">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.SandyBrown">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.SeaGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.SeaShell">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Sienna">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Silver">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.SkyBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.SlateBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.SlateGray">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Snow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.SpringGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.SteelBlue">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Tan">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Teal">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Thistle">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Tomato">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Turquoise">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Violet">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Wheat">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.White">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.WhiteSmoke">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.Yellow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.YellowGreen">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.ButtonFace">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.ButtonHighlight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.ButtonShadow">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.GradientActiveCaption">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.GradientInactiveCaption">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MenuBar">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StandardColors.MenuHighlight">
            <summary>This property gets the color based on the GDI+ version of the color.</summary>
            <decimalDegreesValue>This property gets the color based on the GDI+ version of the color.</decimalDegreesValue>
            <remarks>This property exposes the colors that ship with GDI+.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.OpeningFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in the OpeningFeatureSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.OpeningFeatureSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.InMemoryFeatureSource">
            <summary>
            This class represents a FeatureSource backed by memory, more specifically an in
            memory collection InternalFeatures.
            </summary>
            <remarks>
            You can use this kind of FeatureSource when your InternalFeatures come from an external
            source which there is no FeatureSource specifically designed for it. An exmaple may be
            real time GPS locations. Another example might be location that a user selected by
            clicking on the screen.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureSource.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.FeatureSourceColumn})">
            <summary>
            Create a new instance of the InMemoryFeatureSource class.
            </summary>
            <remarks>By calling this API to create a new instance of InMemoryFeatureSource, there will 
            have no features in the created featureSource. After this, you can added the feature to the 
            instance , and another even better opion is call another overloads constructor by passing 
            the features too.</remarks>
            <param name="featureSourceColumns">The featuresSourceColumns to instance the InMemoryFeatureSource.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureSource.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.FeatureSourceColumn},System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature})">
            <summary>
            Create a new instance of the InMemoryFeatureSource class by passing a featureSourceColumns and an initial features.
            </summary>
            <param name="featureSourceColumns">The featuresSourceColumns to instance the InMemoryFeatureSource.</param>
            <param name="features">The features to instance the InMemoryFeatureSource.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureSource.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.FeatureSourceColumn},System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.BaseShape})">
            <summary>
            Create a new instance of the InMemoryFeatureSource class by passing a featureSourceColumns and an initial shapes to construct the shapes.
            </summary>
            <param name="featureSourceColumns">The featuresSourceColumns to instance the InMemoryFeatureSource.</param>
            <param name="shapes">The shapes to contruct the features used to instance the InMemoryFeatureSource.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureSource.BuildIndex">
            <summary>
            This method build a spatial index for a passed group of featurs which increases access speed.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureSource.GetCountCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <summary>
            This method returns the count of the number of records in this
            FeatureSource.
            </summary>
            <returns>
            This method returns the count of the number of records in this
            FeatureSource.
            </returns>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetCount. It does not take into account any transaction activity as this is the
                responsibility of the concreate public method GetCount. In this way as a developer
                if you choose to override this method you do not have to consider transaction at
                all.<br/>
            		<br/>
                The default implementation of GetCountCore uses the GetAllRecordsCore method to
                calculate how many records there are in the FeatureSource. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient<br/>
            		<br/>
                If you do not override this method the means it gets the count is by calling the
                GetAllFeatureCore method and counting each feature. This is a very inefficient way
                to get the count in most data sources. It is highly recommended that you override
                this method and replace it with a highly optimized version. For example in a
                ShapeFile the record count is in the main header of the file. Similarly if you are
                using Oracle Spatial you can execute a simple query to get the count of all of the
                record without returning them. In these ways you can greatly improve the
                performance of this method.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureSource.CommitTransactionCore(ThinkGeo.MapSuite.Core.TransactionBuffer)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction it will throw an InvalidOperationException.</exception>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
            <remarks>
            	<para>This method will commit the existing transaction to its underlying source of
                data. It will pass back the results of how the commit went to include any error
                received. If you are implementing your own FeatureSource then this is one of the
                crucial methods you must create. It should be fairly straight forward that you will
                loop through the transaction buffer and add, edit or delete the InternalFeatures in your
                underlying data source. Remember to build and pass back the TransactionResult class
                so that users of your FeatureSource can respond to failures you may encounter
                committing the InternalFeatures. We will handle the end of the transaction and also the
                cleanup of the transaction buffer. Your task will be to commit the records and
                produce a TransactionResult return.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited
                implementation of any specific source such as Oracle Spatial or Shape files. In
                this way it functions the same way for every FeatureSource. You start by calling
                the BeginTransaction. This allocates a collection of in memory change buffers that
                are used to store changes until you commit the transaction. So for example when you
                call the Add, Delete or Update method the changes to the feature are stored in
                memory only. If for any reason you choose to abandon the transaction you can call
                RollbackTransaction at any time and the in memory buffer will be deleted and the
                changes will be lost. When you are ready to commit the transaction you call the
                CommitTransaction and the collections of changes are then passed to the
                CommitTransactionCore method and the implementer of the specific FeatureSource is
                responsible for integrating your changes into the underlying FeatureSource. By
                default the IsLiveTransaction property is set to false which means that until you
                commit the changes the FeatureSource API will not reflect any changes that are in
                the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true then things function
                slightly differently. The live transaction concept means that all of the
                modification you perform during a transaction are live from the standpoint of the
                querying methods on the object.</para>
            	<para>To setup an example imagine that you have a FeatureSource that has 10 records
                in it. Next you begin a transaction and then call GetAllFeatures, the result would
                be 10 records. After that you call a delete on one of the records and call the
                GetAllFeatures again, this time you only get nine records. You receive nine records
                even though the transaction has not yet been committed. In the same sense you could
                have added a new record or modified an existing one and those changes are
                considered live though not committed.</para>
            	<para>In the case where you modify records such as expanding the size of a polygon
                those changes as well are reflected. So for example you expand a polygon by
                doubling its size and then do a spatial query that would not normally return the
                smaller record but would return the larger records, in this case the larger record
                is returned. You can set this property to be false as well in which case all of the
                spatial related methods would ignore anything that is currently in the transaction
                buffer waiting to be committed. In this case only after committing the transaction
                would the FeatureSource reflect the changes.</para>
            </remarks>
            <returns>
            The return decimalDegreesValue of this method is a TransactionResult class which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful and any error that were encountered during the
            committing of the transaction.
            </returns>
            <param name="transactions">
            This parameter encapsulates all of the adds, edits and deleted that make up the
            transaction. You will use this data to write the changes to your underlying data
            source.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureSource.GetAllFeaturesCore(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. You will not need
            to consider anything about pending transactions as this will be handled in the non Core
            version of the method.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We wanted as the framework developers to provide you
            the user with as much default virtual implementation as possible. To do this we needed
            a way to get access to all of the features. For example, we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all the records then we can brute force
            the answer. In this way if you inherited form this class and only implemented this one
            method we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource
            it comes with a price. The price is that it is very inefficient. In the case we just
            discussed about finding all of the InternalFeatures in a bounding box we would not want to look
            at every record to fulfil this method. Instead we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be fast. For
            example in Oracle Spatial there is a specific SQL statement to do this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. It will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.
            </remarks>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureSource.GetFeaturesInsideBoundingBoxCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource that are inside of the
            specified bounding box.
            </summary>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource that are inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions, as this is handled by the concrete version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesInsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding box. We
            strongly recommend that you provide your own implementation for this method that will
            be more efficient. That is especially important for this method, as many other default
            virtual methods use this for their calculations. When you override this method, we highly recommend
            that you use any spatial indexes you have at your disposal to make this
            method as fast as possible.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data that you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureSource.GetFeaturesOutsideBoundingBoxCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </returns>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </summary>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box. If you are in a transaction and that transaction is live,
            this method will also take that into consideration.<br/>
            	<br/>
            	<br/>
            The default implementation of GetFeaturesOutsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are outside of the bounding box.
            We strongly recommend that you provide your own implementation for this method that
            will be more efficient.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureSource.GetColumnsCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the columns available for the FeatureSource.</summary>
            <remarks>
            When overriding you will be responsible for getting a list of all of the columns
            supported by the FeatureSource. In this way the FeatureSource will know what columns
            are available and will remove any extra columns when making calls to other core
            methods. For example if you have a FeatureSource that has three columns of information
            and the user calls a method and requests four columns of information, something they
            can do with custom fields, we will first compare what they are asking for to the
            results of the GetColumnsCore. In this way we can strip out custom columns before
            calling other Core methods which are only responsible for returning data in the
            FeatureSource. For more information on custom fields you can see the documentation on
            the OnCustomFieldsFetch.
            </remarks>
            <returns>This method returns the columns available for the FeatureSource.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.InMemoryFeatureSource.InternalFeatures">
            <summary>This property returns the underlying InternalFeatures stored in memory.</summary>
            <decimalDegreesValue>This property returns the underlying InternalFeatures stored in memory.</decimalDegreesValue>
            <remarks>
            This property allows you to modify and inspect the InternalFeatures held by this
            FeatureSource in memory. You can use this as a quick way to add, update or remove
            InternalFeatures.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.InMemoryFeatureSource.IsEditable">
            <summary>This property returns if the FeatureSource allows edits or is read only.</summary>
            <decimalDegreesValue>
            This property returns if the FeatureSource allows edits or is read only. The
            property returns true if the FeatureSource allows edits and false if the FeatureSource
            is read only.
            </decimalDegreesValue>
            <remarks>
            	<para>This property is useful to check if a specific FeatureSource accepts editing.
                If you call the BeginTransaction and this property is false then an exception will
                be raised.<br/>
            		<br/>
                For developers who are creating or extending a FeatureSource it is expected that
                you override this virtual method if the new FeatureSource you are creating allows
                edits. By default the decimalDegreesValue if false meaning that if you want to allow edits you
                must override this method and return true.</para>
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.EcwRasterLayer">
            <summary>This class represents an ECW image to be drawn on the map.</summary>
            <remarks>
            The EcwRasterLayer represents an ECW file for drawing on the map. Simply provide
            the path and filename of the ECW file, add the layer to the MapEngine class and
            start drawing. You can also draw the layer manually outside of the MapEngine.<br/>
            	<br/>
            ECW:<br/>
            	<br/>
            ECW is a wavelet image compression system developed by ER Mapper. It allows you to
            combine and compress large sets of satellite images into a single file. The images can
            be accessed very quickly at a variety of scales. It is very popular in the GIS
            community.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RasterLayer">
            <summary>This abstract class is the basis for all image-based layers in the system.</summary>
            <remarks>
            This abstract class is the basis for all image-based layers in the system. Its
            methods and properties deal with image manipulation. Currently, some classes that
            inherit from this are EcwRasterLayer, MrSidRasterLayer, GridRasterLayer and so on.<br/>
            	<br/>
            When creating your own RasterLayer, you need only to set a RasterSource and create a
            useful constructor; the class will take care of the rest. There are no required
            abstract members. It may be helpful for you to add additional properties specific to
            your ImageSource.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterLayer.#ctor">
            <summary>
            This is a constructor for the class. If you use this constructor, you should set
            the properties you need manually.
            </summary>
            <returns>None</returns>
            <remarks>
            If you use this constructor, you should set the properties you need
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterLayer.GetProjectionText">
            <summary>This method returns the projection parameters of the current layer.</summary>
            <returns>This method returns the projection parameters of the current layer.</returns>
            <remarks>This method returns the projection parameters of the current layer.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterLayer.GetHorizontalResolution">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image layer which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the horizontal resolution of the image.</summary>
            <returns>This method returns the horizontal resolution of the image.</returns>
            <remarks>
            This method returns the horizontal resolution of the image.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterLayer.GetVerticalResolution">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image layer which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the vertical resolution of the image.</summary>
            <returns>This method returns the vertical resolution of the image.</returns>
            <remarks>
            This method returns the vertical resolution of the image.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterLayer.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image layer which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the RasterLayer.</summary>
            <returns>This method returns the bounding box of the RasterLayer.</returns>
            <remarks>This method returns the bounding box of the RasterLayer.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterLayer.OpenCore">
            <summary>
            This method opens the RasterLayer so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            The open method plays an important rol,e as it is responsible for initializing the
            RasterLayer. Most methods on the RasterLayer will throw an exception if the state of
            the RasterLayer is not opened. When the map draws each layer, it will open the
            RasterLayer as one of its first steps; then, after it is finished drawing with that
            layer, it will close it. In this way, we are sure to release all resources used by the
            RasterLayer.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has already been opened, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterLayer.CloseCore">
            <summary>
            This method opens the RasterLayer so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>        
            The close method plays an important role in the life cycle of the RasterLayer. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed RasterLayer is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>
            This method will draw the image from the GeoImage source based on the parameters
            provided.
            </summary>
            <returns>None</returns>
            <remarks>
            The DrawCore method will be called when the layer is being drawn. It will determine if
            the image is within the extent and the threshold defined. If these
            parameters are met, it will query the RasterSource for an image and then apply
            the other various properties (such as transparency, etc.) on the image. Lastly, it will draw
            the image on the GeoImage or native image passed into the method.
            </remarks>
            <param name="canvas">
            This parameter is the GeoCanvas used to Draw the RasterLayer.
            </param>
            <param name="labelsInAllLayers">This parameter is not used for ImageLayers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterLayer.IsExtentWithinThreshold(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,System.Double,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns whether the current extent is within the upper and lower threshold
            properties.
            </summary>
            <returns>
            This method returns whether the current extent is within the upper and lower threshold
            properties.
            </returns>
            <remarks>
            This method is used to determine whether the RasterLayer needs to draw based on the
            current extent and the the threshold parameters provided.
            </remarks>
            <param name="currentExtent">
            This parameter is the current extent that you want determine is within the thresholds
            defined.
            </param>
            <param name="upperThreshold">This parameter is the upper threshold used to test the extent.</param>
            <param name="lowerThreshold">This parameter is the lower threshold used to test the extent.</param>
            <param name="canvasWidth">This parameter is the width of the canvas.</param>
            <param name="mapUnit">This parameter is the unit of the map.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterLayer.IsExtentWithinThreshold(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,System.Double,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit,System.Single)">
            <summary>
            This method returns whether the current extent is within the upper and lower threshold
            properties.
            </summary>
            <returns>
            This method returns whether the current extent is within the upper and lower threshold
            properties.
            </returns>
            <remarks>
            This method is used to determine whether the RasterLayer needs to draw based on the
            current extent and the the threshold parameters provided.
            </remarks>
            <param name="currentExtent">
            This parameter is the current extent that you want determine is within the thresholds
            defined.
            </param>
            <param name="upperThreshold">This parameter is the upper threshold used to test the extent.</param>
            <param name="lowerThreshold">This parameter is the lower threshold used to test the extent.</param>
            <param name="canvasWidth">This parameter is the width of the canvas.</param>
            <param name="mapUnit">This parameter is the unit of the map.</param>
            <param name="dpi">This parameter is the dpi of the current extent.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterLayer.Transparency">
            <summary>
            This property gets and sets the amount of transparency to apply to the
            image.
            </summary>
            <value>This property gets the amount of transparency to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterLayer.BlueTranslation">
            <summary>This property gets and sets the amount of blue to apply to the image.</summary>
            <value>This property gets the amount of blue to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterLayer.RedTranslation">
            <summary>This property gets and sets the amount of red to apply to the image.</summary>
            <value>This property gets the amount of red to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterLayer.GreenTranslation">
            <summary>This property gets and sets the amount of green to apply to the image.</summary>
            <value>This property gets the amount of green to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterLayer.IsNegative">
            <summary>
            This property gets and sets whether the image should be converted to negative (inverse colors).
            </summary>
            <value>This property gets and sets whether the image should be converted to negative (inverse colors).</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterLayer.IsGrayscale">
            <summary>
            This property gets and sets if the image should be converted to grayscale.
            </summary>
            <value>
            This property gets and sets if the image should be converted to grayscale.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterLayer.ImageSource">
            <summary>This property gets and sets the ImageSource used by the RasterLayer.</summary>
            <value>This property gets the ImageSource used by the RasterLayer.</value>
            <remarks>
            The set for this property is protected and only intended to be used by developers
            who are creating their own ImageSources. This is the main property to set for developers who are creating
            their own RasterLayer derivatives.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterLayer.UpperThreshold">
            <summary>
            This property gets and sets the upper threshold in the scale at which to display the
            image.
            </summary>
            <value>This property gets the upper threshold in the scale at which to display the image.</value>
            <remarks>
            Above the upper threshold in scale, the image will not be displayed. This, in
            conjunction with the LowerThreshold property, allows you to create a band in which it is
            suitable to display the image source. By default, the upper threshold is double.max and
            lower threshold is double.min. This means the image should always display.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterLayer.LowerThreshold">
            <remarks>
            Below the lower threshold in scale, the image will not be displayed. This, in
            conjunction with the UpperThreshold property, allows you to create a band in which it is
            suitable to display the image source. By default, the upper threshold is double.max and
            lower threshold is double.min. This means the image should always display.
            </remarks>
            <summary>
            This property gets and sets the lower threshold in the scale at which to display the
            image.
            </summary>
            <value>This property gets the lower threshold in the scale at which to display the image.</value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterLayer.HasProjectionText">
            <summary>
            This property returns true if the RasterLayer contains projection parameters and false if
            it does not contain any projection parameters.
            </summary>
            <value>
            This property returns true if the RasterLayer contains projection parameters and false if
            it does not contain any projection parameters.
            </value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterLayer.KeyColor">
            <summary>
            This property gets or set the key color of the Raster image.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterLayer.KeyColors">
            <summary>
            Gets a value represents a collection of key colors. If HasKeyColor property is false, it will throw exception when you use KeyColors.
            </summary>
            <remarks>It will make these colors transparent when draw image.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterLayer.IsOpenCore">
            <summary>
            This property returns true if the RasterLayer is open and false if it is
            not.
            </summary>
            <value>
            This property returns true if the RasterLayer is open and false if it is
            not.
            </value>
            <remarks>
            Various methods on the RasterLayer require that it be in an open state. If one
            of those methods is called when the state is not open, then the method will throw an
            exception. To enter the open state, you must call the RasterLayer's Open method. The
            method will raise an exception if the current RasterLayer is already open.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterLayer.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the PathFileName property manually before using the layer.
            </overloads>
            <remarks>
            If you use this constructor, then you need to set the PathFileName property
            manually before using the layer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterLayer.#ctor(System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename information for the ECW
            file.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and filename of the ECW file you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterLayer.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename for the ECW file and its associated world
            file.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and filename of the ECW file you want to use.</param>
            <param name="worldfilePathFilename">This parameter is the world file path and filename for the ECW file you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterLayer.#ctor(System.String,ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename for the ECW file and the image extent to use.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and filename of the ECW file you want to use.</param>
            <param name="imageExtent">This parameter is the image extent of ECW file you want to use.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.EcwRasterLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In EcwRasterLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.EcwRasterLayer.PathFilename">
            <summary>
            This property gets and sets the path and filename of the ECW file you want to
            use.
            </summary>
            <value>This property gets the path and filename of the ECW file you want to use.</value>
            <remarks>This should be the complete path and filename for an ECW file.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.SplineType">
            <summary>This enumeration represents the spline type for labeling.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.SplineType.Default">
            <summary>Default SplineType provided in PositionStyle.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.SplineType.None">
            <summary>This SplineType will label the text in a line type without any spling effects, this kinds of type will gain
            better performance compare to StandardSplining.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.SplineType.StandardSplining">
            <summary>This SplineType will label the text in a standard Spline way, it will have much better outlook in some situations
            while it will lose slightly some performance.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.SplineType.ForceSplining">
            <summary>
            This SplineType will force the labe text using Spline way, otherwise the label won't display.Usually it is just used for Asian languages
            like Chinese or Japanese.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.AdornmentLayerDrawnEventArgs">
            <summary>
            This is the event arguments class for the AdornmentLayerDrawn event. It is raised
            after the AdornmentLayer is drawn.
            </summary>
            <remarks>
            This is the event arguments class for the AdornmentLayerDrawn event. It is raised
            after the AdornmentLayer is drawn. This event allows you to manipulate the AdornmentLayer,
            or draw something with the canvas after the AdornmentLayer has been drawn.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AdornmentLayerDrawnEventArgs.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AdornmentLayerDrawnEventArgs.#ctor(ThinkGeo.MapSuite.Core.AdornmentLayer)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="adornmentLayer">This parameter is the AdornmentLayer that has been drawn.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AdornmentLayerDrawnEventArgs.AdornmentLayer">
            <summary>This property gets and sets the AdornmentLayer that has been drawn.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.HueFamilyAreaStyle">
            <summary>This class is used to draw area features.</summary>
            <remarks>
            You should use this class to draw area features. You can specify a base color and the number of 
            colors you want based on that color to draw the interior, and you can specify an outline pen
            with which to draw the border. You can optionally choose to
            use only the outline pen or the fill brush to generate different effects.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HueFamilyAreaStyle.#ctor">
            <summary>This is the constructor for the class. If you use this constructor, then you need to set
            the required properties manually.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HueFamilyAreaStyle.#ctor(ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoColor,System.Int32)">
            <summary>This is the constructor the for the class.</summary>
            <overloads>This is the constructor for this class.</overloads>
            <returns>None</returns>
            <remarks>None.</remarks>
            <param name="outlinePen">This parameter represents the outline pen that will be used on the style.</param>
            <param name="baseColor">This parameter represents the base color that will be used in the class.</param>
            <param name="numberOfColors">
            This prameter represents how many colors will be used in the style, based on the
            base color.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HueFamilyAreaStyle.#ctor(ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoColor,System.Int32,ThinkGeo.MapSuite.Core.PenBrushDrawingOrder)">
            <summary>This is the constructor the for the class.</summary>
            <overloads>This is the constructor for this class.</overloads>
            <returns>None</returns>
            <remarks>None.</remarks>
            <param name="outlinePen">This parameter represents the outline pen that will be used on the style.</param>
            <param name="baseColor">This parameter represents the base color that will be used in the class.</param>
            <param name="numberOfColors">
            This prameter represents how many colors will be used in the style, based on the
            base color.
            </param>
            <param name="penBrushDrawingOrder">This parameter describes the PenBrushDrawingOrder that will be used when drawing the area type feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HueFamilyAreaStyle.ClearCache">
            <summary>This method clears the cached style in the cache.</summary>
            <returns>None.</returns>
            <remarks>This method clears the cached style in the cache.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HueFamilyAreaStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If OutlinePen is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If FillSolidBrush is null, we will throw an ArgumentNullException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.HueFamilyAreaStyle.NumberOfColors">
            <summary>This gets or sets the number of colors in the style.</summary>
            <value>This gets or sets the number of colors in the style.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.HueFamilyAreaStyle.Cache">
            <summary>This gets the cached style in the class.</summary>
            <value>This gets the cached style in the class.</value>
            <remarks>
            This gets the cached style in the class. The key of the style in the cache is
            feature.Id &amp; feature.GetHashCode().
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.HueFamilyAreaStyle.BaseColor">
            <summary>This gets or sets the base color of the style.</summary>
            <value>This gets or sets the base color of the style.</value>
            <remarks>None.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.HeatStyle">
            <summary>
            HeatStyle allows you to better visualize data by making areas of high concentration "hotter" using warmer colors and low density areas visually cooler. 
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatStyle.#ctor">
            <summary>This is the default constructor of the class.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatStyle.#ctor(System.Int32)">
            <summary>This is a constructor for the class.</summary>
            <param name="pointIntensity">The parameter represents the point intensity, the default value is 10.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatStyle.#ctor(System.Int32,System.Int32)">
            <summary>This is a constructor for the class.</summary>
            <param name="pointIntensity">The parameter represents the point intensity, the default value is 10.</param>
            <param name="alpha">The parameter represents the alpha value of color, the default value is 255.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatStyle.#ctor(System.Int32,System.Double,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This is a constructor for the class.</summary>
            <param name="pointIntensity">The parameter represents the point intensity, the default value is 10.</param>
            <param name="pointRadius">The parameter represents the point radius, the default value is 50 kilometers.</param>
            <param name="pointRadiusUnit">The parameter represents the unit of point radius, the default value is kilometer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatStyle.#ctor(System.Int32,System.Int32,System.Double,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This is a constructor for the class.</summary>
            <param name="pointIntensity">The parameter represents the point intensity, the default value is 10.</param>
            <param name="alpha">The parameter represents the alpha value of color, the default value is 255.</param>
            <param name="pointRadius">The parameter represents the point radius, the default value is 50 kilometers.</param>
            <param name="pointRadiusUnit">The parameter represents the unit of point radius, the default value is kilometer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatStyle.#ctor(System.String,System.Double,System.Int32)">
            <summary>This is a constructor for the class.</summary>
            <param name="intensityColumnName">The parameter represents the intensity column name, the default value is empty string.</param>
            <param name="intensityRangeStart">The parameter represents the range start of intensity, the default value is 0.</param>
            <param name="intensityRangeEnd">The parameter represents the range end of intensity, the default value is 0.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatStyle.#ctor(System.Int32,System.String,System.Double,System.Int32)">
            <summary>This is a constructor for the class.</summary>
            <param name="alpha">The parameter represents the alpha value of color, the default value is 255.</param>
            <param name="intensityColumnName">The parameter represents the intensity column name, the default value is empty string.</param>
            <param name="intensityRangeStart">The parameter represents the range start of intensity, the default value is 0.</param>
            <param name="intensityRangeEnd">The parameter represents the range end of intensity, the default value is 0.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatStyle.#ctor(System.String,System.Double,System.Int32,System.Double,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This is a constructor for the class.</summary>
            <param name="intensityColumnName">The parameter represents the intensity column name, the default value is empty string.</param>
            <param name="intensityRangeStart">The parameter represents the range start of intensity, the default value is 0.</param>
            <param name="intensityRangeEnd">The parameter represents the range end of intensity, the default value is 0.</param>
            <param name="pointRadius">The parameter represents the point radius, the default value is 50 kilometers.</param>
            <param name="pointRadiusUnit">The parameter represents the unit of point radius, the default value is kilometer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatStyle.#ctor(System.Int32,System.String,System.Double,System.Int32,System.Double,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This is a constructor for the class.</summary>
            <param name="alpha">The parameter represents the alpha value of color, the default value is 255.</param>
            <param name="intensityColumnName">The parameter represents the intensity column name, the default value is empty string.</param>
            <param name="intensityRangeStart">The parameter represents the range start of intensity, the default value is 0.</param>
            <param name="intensityRangeEnd">The parameter represents the range end of intensity, the default value is 0.</param>
            <param name="pointRadius">The parameter represents the point radius, the default value is 50 kilometers.</param>
            <param name="pointRadiusUnit">The parameter represents the unit of point radius, the default value is kilometer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatStyle.#ctor(System.Int32,System.Int32,System.String,System.Double,System.Int32,System.Double,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This is a constructor for the class.</summary>
            <param name="pointIntensity">The parameter represents the point intensity, the default value is 10.</param>
            <param name="alpha">The parameter represents the alpha value of color, the default value is 255.</param>
            <param name="intensityColumnName">The parameter represents the intensity column name, the default value is empty string.</param>
            <param name="intensityRangeStart">The parameter represents the range start of intensity, the default value is 0.</param>
            <param name="intensityRangeEnd">The parameter represents the range end of intensity, the default value is 0.</param>
            <param name="pointRadius">The parameter represents the point radius, the default value is 50 kilometers.</param>
            <param name="pointRadiusUnit">The parameter represents the unit of point radius, the default value is kilometer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This abstract method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties to
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatStyle.GetRequiredColumnNamesCore">
            <remarks>
            This abstract method is called from the concrete public method
            GetRequiredFieldNames. In this method, we return the column names that are required for
            the style to draw the feature properly. For example, if you have a style that colors
            areas blue when a certain column value is over 100, then you need to be sure you include
            that column name. This will ensure that the column data is returned to you in the
            feature when it is ready to draw.<br/>
            	<br/>
            In many of the styles, we add properties to allow the user to specify which field they
            need; then, in the GetRequiredColumnNamesCore we read that property and add it to the
            collection.
            </remarks>
            <summary>
            This method returns the column data for each feature that is required for the
            style to properly draw.
            </summary>
            <returns>This method returns a collection of column names that the style needs.</returns>pal
        </member>
        <!-- Badly formed XML comment ignored for member "P:ThinkGeo.MapSuite.Core.HeatStyle.PointIntensity" -->
        <!-- Badly formed XML comment ignored for member "P:ThinkGeo.MapSuite.Core.HeatStyle.Alpha" -->
        <!-- Badly formed XML comment ignored for member "P:ThinkGeo.MapSuite.Core.HeatStyle.IntensityRangeStart" -->
        <!-- Badly formed XML comment ignored for member "P:ThinkGeo.MapSuite.Core.HeatStyle.IntensityRangeEnd" -->
        <!-- Badly formed XML comment ignored for member "P:ThinkGeo.MapSuite.Core.HeatStyle.IntensityColumnName" -->
        <!-- Badly formed XML comment ignored for member "P:ThinkGeo.MapSuite.Core.HeatStyle.PointRadius" -->
        <!-- Badly formed XML comment ignored for member "P:ThinkGeo.MapSuite.Core.HeatStyle.PointRadiusUnit" -->
        <!-- Badly formed XML comment ignored for member "P:ThinkGeo.MapSuite.Core.HeatStyle.ColorPalette" -->
        <member name="T:ThinkGeo.MapSuite.Core.RestrictionLayer">
            <summary>
            This layer can show or hide one or many zones that you want to restrict from being displayed. You can
            use the specified style to decorate the zones and set the lower/upper scale to control
            at which zoom levels you want to show or hide the zones. The default decoration style is a hatch pattern.
            You can change this to a circle with slash image, or, if you want a different look, you can use
            custom styles.
            </summary>
            <example>
            	<code lang="CS" title="C# sample" description="The example below shows how to use RestrictionLayer.">
            RestrictionLayer restrictionLayer = new RestrictionLayer();
            RectangleShape africaZone = new RectangleShape(-17.67, 37.01, 60.02, -34.68)
            restrictionLayer.Zones.Add(africaZone);
            restrictionLayer.RestrictionMode = RestrictionMode.ShowZones;
            restrictionLayer.UpperScale = 250000000;
            restrictionLayer.LowerScale = double.MinValue;
             
            ...
            // You can see only Africa because we have added a RestrictionLayer and its mode is ShowZones.
            restrictionLayer.RestrictionMode = RestrictionMode.ShowZones;
             
            ...
            // You can not see Africa because we have added a RestrictionLayer and its mode is HideZones.
            restrictionLayer.RestrictionMode = RestrictionMode.HideZones;
            </code>
            	<code lang="VB" title="VB sample" description="The example below shows how to use RestrictionLayer">
            Dim restrictionLayer As RestrictionLayer =  New RestrictionLayer() 
            RectangleShape africaZone = New RectangleShape(-17.67, 37.01, 60.02, -34.68) 
            restrictionLayer.Zones.Add(africaZone) 
            restrictionLayer.RestrictionMode = RestrictionMode.ShowZones 
            restrictionLayer.UpperScale = 250000000 
            restrictionLayer.LowerScale = Double.MinValue 
             
            ... 
            ' You can see only Africa because we have added a RestrictionLayer and its mode is ShowZones. 
            restrictionLayer.RestrictionMode = RestrictionMode.ShowZones 
             
            ... 
            ' You can not see Africa because we have added a RestrictionLayer and its mode is HideZones. 
            restrictionLayer.RestrictionMode = RestrictionMode.HideZones
            </code>
            </example>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RestrictionLayer.#ctor">
            <summary>Initializes a new instance of the <strong>RestictionLayer</strong> class.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RestrictionLayer.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.AreaBaseShape})">
            <summary>Initializes a new instance of the <strong>RestictionLayer</strong> class for the specified zones.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RestrictionLayer.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.AreaBaseShape},ThinkGeo.MapSuite.Core.RestrictionMode)">
            <summary>Initializes a new instance of the <strong>RestictionLayer</strong> class for the specified zones and restriction mode.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RestrictionLayer.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.AreaBaseShape},ThinkGeo.MapSuite.Core.RestrictionMode,System.Double,System.Double)">
            <summary>Initializes a new instance of the <strong>RestictionLayer</strong> class for the specified zones, restriction mode, upper scale and lower scale.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RestrictionLayer.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a layer which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the zones.</summary>
            <returns>This method returns the bounding box of the zones.</returns>
            <remarks>This method returns the bounding box of the zones.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RestrictionLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the Layer.</summary>
            <remarks>
            This abstract method is called from the concrete public method Draw. This
            method draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties to
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter represents the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RestrictionLayer.UpperScale">
            <summary>Specifies the upper threshold of the layer.</summary>
            <remarks>
            	<para><strong>If Restriction mode is ShowZones:</strong></para>
            	<para>If currentScale is greater than <strong>UpperScale</strong>, it will hide the
                whole map; otherwise, it will show the specified zones.</para>
            	<para></para>
            	<para></para>
            	<para><strong>If Restriction mode is HideZones:</strong></para>
            	<para>If currentScale is less than or equal to <strong>UpperScale</strong> and
                greater than or equal to LowerScale, it will hide the specified zones; otherwise, it
                will do nothing.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RestrictionLayer.LowerScale">
            <summary>Specifies the lower threshold of the layer.</summary>
            <remarks>
            	<para>If Restriction mode is ShowZones:</para>
            	<para>If currentScale is less than <strong>LowerScale</strong>, it will hide the
                whole map; otherwise, it will show the specified zones.</para>
            	<para></para>
            	<para></para>
            	<para>If Restriction mode is HideZones:</para>
            	<para>if currentScale is less than or equal to UpperScale and greater than or equal
                to <strong>LowerScale</strong>, it will hide the specified zones; otherwise it will
                do nothing.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RestrictionLayer.CustomStyles">
            <summary>Allows you to add custom styles to decorate restriction zones.  In this case, you must set RestrictionStyle to UseCustomStyles as well.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RestrictionLayer.RestrictionMode">
            <summary>Specifies whether you want to show or hide zones.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RestrictionLayer.Zones">
            <summary>Specifies the areas you want to restrict.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RestrictionLayer.RestrictionStyle">
            <summary>Specifies the display style of the restriction zones.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MapShapeLayer">
            <summary>
            Ideally I would want to make this inherit from the FeatureLayer
            so you could do spatial queries.  In the interests of time I 
            inherited from the Layer to make things simple and show the point
            of how easy it is to extend Map Suite.  When we roll this into
            the main product we may create a FeatureSource and FeatureLayer.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapShapeLayer.#ctor">
            <summary>This is the default constructor for the MapShapeLayer.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapShapeLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the MapShapeLayer.</summary>
            <remarks>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties that
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter represents the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MapShapeLayer.MapShapes">
            <summary>
            Get all the map shapes with the keys.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RasterSource">
            <summary>
            The abstract class from which all raster sources inherit. Raster sources
            represent raster data that can be integrated into Map Suite.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.#ctor">
            <summary>This is the default new constructor for the RasterSource.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.OnOpeningRasterSource(ThinkGeo.MapSuite.Core.OpeningRasterSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the OpeningRasterSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            OpeningRasterSource event. This may be useful if you plan to extend the RasterSource and
            you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called before the opening of the RasterSource. Technically, this event is
            called after the calling of the Open method on the RasterSource, but before the protected
            OpenCore method.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments that define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.OnOpenedRasterSource(ThinkGeo.MapSuite.Core.OpenedRasterSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the OpenedRasterSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            OpenedRasterSource event. This may be useful if you plan to extend the RasterSource and
            you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called after the opening of the RasterSource. Technically, this event is
            called after the calling of the Open method on the RasterSource and after the protected
            OpenCore method is called.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments that define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.OnClosingRasterSource(ThinkGeo.MapSuite.Core.ClosingRasterSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the ClosingRasterSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            ClosingRasterSource event. This may be useful if you plan to extend the RasterSource and
            you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called before the closing of the RasterSource. Technically, this event is
            called after the calling of the Close method on the RasterSource, but before the
            protected CloseCore method.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments that define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.OnClosedRasterSource(ThinkGeo.MapSuite.Core.ClosedRasterSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the ClosedRasterSource event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            ClosedRasterSource event. This may be useful if you plan to extend the RasterSource and
            you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called after the closing of the RasterSource. Technically, this event is
            called after the calling of the Close method on the RasterSource and after the protected
            CloseCore method.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
            <param name="e">
            This parameter is the event arguments that define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.CloneDeep">
            <summary>Create a copy of RasterSource using the deep clone process.</summary>
            <returns>A cloned RasterSource.</returns>
            <remarks>
            The difference between deep clone and shallow clone is: when shallow cloned,
            only the object is copied, but the contained objects are not; while in deep clone it
            does copy the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.CloneDeepCore">
            <summary>Create a copy of RasterSource using the deep clone process. The default implementation uses serialization.</summary>
            <returns>A cloned RasterSource.</returns>
            <remarks>
            The difference between deep clone and shallow clone is: when shallow cloned,
            only the object is copied, but the contained objects are not; while in deep clone it
            does copy the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.GetWorldFileText">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns a string that represents the image's world file.</summary>
            <returns>This method returns a string that represents the image's world file.</returns>
            <remarks>
            This method wraps the Core version of this method and returns a string that
            represents the image's world file. The world file is a file type that can accompany
            image files. It contains information about the image's position, resolution and other
            spatial-related items. It is common to have this kind of file associated with generic
            image types such as JPG, BMP, and normal TIFF because they do not have a mechanism to
            store this data internally. Modern GIS image types such as JPEG2000, ECW, and MrSid
            typically have this information stored internally. We provide this method in the event
            that you want to create your own world file from any image that either already has one
            or has its data stored internally.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.GenerateWorldFileText(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass in a worldExtent that is Null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a worldExtent that is invalid, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image width that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image height that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <summary>
            This method returns a string that represents the image's world file based on the
            parameters passed in.
            </summary>
            <returns>
            This method returns a string that represents the image's world file based on the
            parameters passed in.
            </returns>
            <remarks>
            This method returns a string that represents the image's world file. The world file
            is a file type that can accompany image files. It contains information about the image's
            position, resolution and other spatial-related items. It is common to have this kind of
            file associated with generic image types such as JPG, BMP, and normal TIFF because they
            do not have a mechanism to store this data internally. Modern GIS image types such as
            JPEG2000, ECW, and MrSid typically have this information stored internally. We provide
            this method in the event that you want to create your own world file from any image that
            either already has one or has its data stored internally.
            </remarks>
            <param name="worldExtent">This parameter represents the worldExtent of the image in world coordinates.</param>
            <param name="imageWidth">This parameter is the width of the image in screen coordinates.</param>
            <param name="imageHeight">This parameter is the height of the image in screen coordinates.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.GetImageWidth">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the width of the image in screen coordinates.</summary>
            <remarks>
            This method returns the width of the image in screen coordinates.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <returns>This method returns the width of the image in screen coordinates.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.GetImageWidthCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the width of the image in screen coordinates.</summary>
            <returns>This method returns the width of the image in screen coordinates.</returns>
            <remarks>This abstract method is called from the concrete method GetImageWidth.
            You need to override it if you inherit from the RasterSource to return the width of your image.
            It returns the width of the image in screen coordinates.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.GetImageHeight">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the height of the image in screen coordinates.</summary>
            <returns>This method returns the height of the image in screen coordinates.</returns>
            <remarks>
            This method returns the height of the image in screen coordinates.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.GetImageHeightCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the height of the image in screen coordinates.</summary>
            <returns>This method returns the height of the image in screen coordinates.</returns>
            <remarks>This abstract method is called from the concrete method GetImageHeight.
            You need to override it if you inherit from the RasterSource to return the height of your image.
            It returns the height of the image in screen coordinates.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.GetHorizontalResolution">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the horizontal resolution of the image.</summary>
            <returns>This method returns the horizontal resolution of the image.</returns>
            <remarks>
            This method returns the horizontal resolution of the image.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.GetVerticalResolution">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the vertical resolution of the image.</summary>
            <returns>This method returns the vertical resolution of the image.</returns>
            <remarks>
            This method returns the vertical resolution of the image.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.GetBoundingBox">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the RasterSource.</summary>
            <returns>This method returns the bounding box of the RasterSource.</returns>
            <remarks>
            This method returns the bounding box of the RasterSource.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the RasterSource.</summary>
            <returns>This method returns the bounding box of the RasterSource.</returns>
            <remarks>This method returns the bounding box of the RasterSource.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.GetProjectionText">
            <summary>This method returns the projection text in proj4 format.</summary>
            <returns>This method returns the projection text in proj4 format.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.GetProjectionTextCore">
            <summary>
            This method returns the projection text in proj4 format.
            </summary>
            <returns>Projection text string.</returns>
            <remarks>
            	<para>This protected virtual method is called from the concrete public method
                GetProjectionText.</para>
            	<para>The default implementation of this core method is to throw an exception. So you
                need to overwrite this method to return the RasterSource projection text.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.Open">
            <summary>
            This method opens the RasterSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method OpenCore. The
                Open method plays an important role, as it is responsible for initializing the
                RasterSource. Most methods on the RasterSource will throw an exception if the state
                of the RasterSource is not opened. When the map draws each layer, it will open the
                RasterSource as one of its first steps; then, after it is finished drawing with that
                layer, it will close it. In this way, we are sure to release all resources used by
                the RasterSource.<br/>
            		<br/>
                When implementing the abstract method, consider opening files for file-based sources,
                connecting to databases in the database-based sources and so on. You will get a chance
                to close these in the Close method of the RasterSource.
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.OpenCore">
            <summary>
            This method opens the RasterSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concrete public method Open.
            The Open method plays an important role, as it is responsible for initializing the
            RasterSource. Most methods on the RasterSource will throw an exception if the state of
            the RasterSource is not opened. When the map draws each layer, it will open the
            RasterSource as one of its first steps; then, after it is finished drawing with that
            layer, it will close it. In this way, we are sure to release all resources used by the
            RasterSource.<br/>
            	<br/>
            When implementing this abstract method, consider opening files for file-based sources,
            connecting to databases in the database-based sources and so on. You will get a chance
            to close these in the Close method of the RasterSource.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has already been opened, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.Close">
            <remarks>
            This method is the concrete wrapper for the abstract method CloseCore. The Close
            method plays an important role in the life cycle of the RasterSource. It may be called
            after drawing to release any memory and other resources that were allocated since the
            Open method was called.<br/>
            	<br/>
            If you override the Core version of this method, it is recommended that you take
            the following things into account: This method may be called multiple times, so we
            suggest you write the method so that that a call to a closed RasterSource is ignored and does
            not generate an error. We also suggest that in the Close you free all resources that
            have been opened. Remember that the object will not be destroyed, but will be re-opened
            possibly in the near future.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>
            This method closes the RasterSource and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.CloseCore">
            <summary>
            This method opens the RasterSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concrete public method Close.
            The Close method plays an important role in the life cycle of the RasterSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed RasterSource is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.GetImage(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass in a worldExtent that is invalid, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a worldExtent that is invalid, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image width that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image height that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method is responsible for returning the image based on the parameters passed
            in. As the core version of this method is abstract, you will need to override it when
            creating your own RasterSource.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>
            This method returns an image based on the worldExtent and image width and
            height.
            </summary>
            <returns>
            This method returns an image based on the worldExtent and image width and
            height.
            </returns>
            <param name="worldExtent">This parameter represents the worldExtent you want to draw.</param>
            <param name="canvasWidth">This parameter represents the width of the image you want to draw.</param>
            <param name="canvasHeight">This parameter represents the height of the image you want to draw.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RasterSource.GetImageCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass in a worldExtent that is invalid, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a worldExtent that is invalid, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image width that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image height that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source that has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method is responsible for returning the image based on the parameters passed
            in. As the core version of this method is abstract, you will need to override it when
            creating our own RasterSource.
            </remarks>
            <summary>
            This method returns an image based on the worldExtent and image width and
            height.
            </summary>
            <returns>
            This method returns an image based on the worldExtent and image width and
            height.
            </returns>
            <param name="worldExtent">This parameter represents the worldExtent you want to draw.</param>
            <param name="canvasWidth">This parameter represents the width of the image you want to draw.</param>
            <param name="canvasHeight">This parameter represents the height of the image you want to draw.</param>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.RasterSource.OpeningRasterSource">
            <summary>This event is called before the opening of the RasterSource.</summary>
            <remarks>
            This event is called before the opening of the RasterSource. Technically, this
            event is called after the calling of the Open method on the RasterSource, but before the
            protected OpenCore method.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.RasterSource.OpenedRasterSource">
            <summary>This event is called after the opening of the RasterSource.</summary>
            <remarks>
            This event is called after the opening of the RasterSource. Technically, this event
            is called after the calling of the Open method on the RasterSource and after the
            protected OpenCore method is called.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.RasterSource.ClosingRasterSource">
            <summary>This event is called before the closing of the RasterSource.</summary>
            <remarks>
            This event is called before the closing of the RasterSource. Technically, this
            event is called after the calling of the Close method on the RasterSource, but before the
            protected CloseCore method.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.RasterSource.ClosedRasterSource">
            <summary>This event is called after the closing of the RasterSource.</summary>
            <remarks>
            This event is called after the closing of the RasterSource. Technically, this event
            is called after the calling of the Close method on the RasterSource and after the
            protected CloseCore method.<br/>
            	<br/>
            It is typical that the RasterSource may be opened and closed may times during the life
            cycle of your application. The type of control the MapEngine is embedded in will dictate
            how often this happens. For example, in the case of the Web Edition, each time
            a RasterSource is in the Ajax or Post Back part of the page cycle, it will close the
            RasterSource before returning back to the client. This is to conserve resources, as
            the web is a connection-less environment. In the case of the Desktop Edition, we can
            keep the RasterSource open, knowing that we can maintain a persistent connection.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterSource.Transparency">
            <summary>
            This property gets and sets the amount of transparency to apply to the
            image.
            </summary>
            <value>This property gets the amount of transparency to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterSource.BlueTranslation">
            <summary>This property gets and sets the amount of blue to apply to the image.</summary>
            <value>This property gets the amount of blue to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterSource.RedTranslation">
            <summary>This property gets and sets the amount of red to apply to the image.</summary>
            <value>This property gets the amount of red to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterSource.GreenTranslation">
            <summary>This property gets and sets the amount of green to apply to the image.</summary>
            <value>This property gets the amount of green to apply to the image.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterSource.IsNegative">
            <summary>
            This property gets and sets whether the image should be converted to negative (inverse colors).
            </summary>
            <value>This property gets and sets whether the image should be converted to negative (inverse colors).</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterSource.IsGrayscale">
            <summary>
            This property gets and sets if the image should be converted to grayscale.
            </summary>
            <value>
            This property gets and sets if the image should be converted to grayscale.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterSource.IsOpen">
            <summary>
            This property returns true if the RasterSource is open and false if it is
            not.
            </summary>
            <decimalDegreesValue>
            This property returns true if the RasterSource is open and false if it is
            not.
            </decimalDegreesValue>
            <remarks>
            Various methods on the RasterSource require that it be in an open state. If one
            of those methods is called when the state is not open, the method will throw an
            exception. To enter the open state, you must call the RasterSource's Open method. The
            method will raise an exception if the current RasterSource is already open.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterSource.HasProjectionText">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a RasterSource which is not open, it will throw an InvalidOperationException.</exception>
            <summary>
            This property returns true if the RasterSource has projection text, false if not.
            </summary>
            <remarks>
            Before you call GetProjectionText method, you should check this property to
            ensure that your RasterSource has projection information. It will throw an exception if
            there is no projection information in the RasterSource.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RasterSource.HasProjectionTextCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a RasterSource which is not open, it will throw an InvalidOperationException.</exception>
            <summary>
            This property returns true if the RasterSource has projection text, false if not.
            </summary>
            <remarks>
            	<para>This protected virtual method is called from the concrete public property
                HasProjectionText. The default implementation for this method returns false. So if
                you inherit RasterSource, please ensure that you override this virtual property to return
                the correct projection status of your RasterSource.</para>
            	<para></para>
            	<para>We will check the HasProjectionText status before you call the
                GetProjectionText method. It will throw an exception if the HasProjectionText
                property returns false.</para>
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.#ctor(System.Uri,System.Net.WebProxy)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <remarks>This constructor initializes a new WorldMapKitWmsRasterSource and downloads and parses the service description.</remarks>
            <param name="uri">URI of the WMS server.</param>
            <param name="proxy">Proxy to use for the current WMS layer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.GetServerLayerNames">
            <summary>This method returns the names of all layers at the server side.</summary>
            <returns>The names of all layers at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.GetServerStyleNames">
            <summary>This method returns the names of all styles at the server side.</summary>
            <returns>The names of all styles at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.GetServerOutputFormats">
            <summary>This method returns the output format at the server side.</summary>
            <returns>The output format at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.GetServerCrss">
            <summary>
            This method returns the projected or geographic coordinate reference systems to be used.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.GetServerExceptionFormats">
            <summary>This method returns the exception format at the server side.</summary>
            <returns>The exception format at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.GetServiceVersion">
            <summary>
            This API gets the WMS server version of the service.
            </summary>
            <returns>Returns a string reflecting the version of the service in WMS.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.GetRequestUrl(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <summary>
            Get the request URLs from the client to the WMS servers.
            </summary>
            <param name="worldExtent">The world extent requested by the client to get the map.</param>
            <param name="canvasWidth">The returning map width, as well as the drawing canvas width.</param>
            <param name="canvasHeight">The returning map height, as well as the drawing canvas height.</param>
            <returns>The request URLs from the client to the WMS servers.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.GetImageCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <remarks>
            This method is responsible for returning the image based on the parameters passed
            in.
            </remarks>
            <summary>
            This method returns an image based on the worldExtent and image width and
            height.
            </summary>
            <returns>
            This method returns an image based on the worldExtent and image width and
            height.
            </returns>
            <param name="worldExtent">This parameter represents the worldExtent you want to draw.</param>
            <param name="canvasWidth">This parameter represents the width of the image you want to draw.</param>
            <param name="canvasHeight">This parameter represents the height of the image you want to draw.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.ClientId">
            <summary>
            Gets or sets a value that is unique to your client ID, please keep your key secure.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.PrivateKey">
            <summary>
            Gets or sets a value that is unique to your client ID, please keep your key secure.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.ActiveLayerNames">
            <summary>
            This property allows the active layers requested from the client to be shown on the map.
            </summary>
            <remarks>When requesting a map, a client may specify the layers to be shown on the map.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.ActiveStyleNames">
            <summary>
            This property allows the active styles requested from the client to be shown on the map.
            </summary>
            <remarks>When requesting a map, a client may specify the styles to be shown on the map.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.TimeoutInSecond">
            <summary>
            This property specifies the timeout of the web request in seconds.  The default timeout value is 20 seconds.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.Crs">
            <summary>
            This property gets or sets the projected or geographic coordinate reference system to be used.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.Parameters">
            <summary>
            This property specifies a dictionary used to update the request sent from the client to
            the WMS server.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitWmsRasterSource.Proxy">
            <summary>
            This property gets or sets the proxy used for requesting a Web Response.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServiceDescription.Title">
            <summary> 
            Title of this requesting WMS layer. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServiceDescription.OnlineResource">
            <summary> 
            Web address of WMS Service. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServiceDescription.KeyWords">
            <summary> 
            Catalog searching help keywords. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServiceDescription.Abstract">
            <summary> 
            Providing additional information. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServiceDescription.Fees">
            <summary> 
            Fees element. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServiceDescription.AccessConstraints">
            <summary> 
            AccessConstraints element. 
            </summary> 
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.SentRequestWmsRasterSourceEventArgs">
            <summary>
            The event args containing the event data used by SecuredTiledWmsRasterSource.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.SentRequestWmsRasterSourceEventArgs.#ctor(System.Net.HttpWebResponse)">
            <summary>
            Create an instance of SentRequestWmsRasterSourceEventArgs
            </summary>
            <param name="response"></param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SentRequestWmsRasterSourceEventArgs.HttpWebResponse">
            <summary>
            Gets or sets a value indicating the response from Server.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ExecutingSqlStatementMsSql2008FeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the ExecutingSqlStatement event in MsSql2008FeatureSource.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExecutingSqlStatementMsSql2008FeatureSourceEventArgs.#ctor(System.String)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="sqlStatement">This parameter is the sqlStatement that will be passed in to excute.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExecutingSqlStatementMsSql2008FeatureSourceEventArgs.#ctor(System.String,ThinkGeo.MapSuite.Core.ExecutingSqlStatementType)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="sqlStatement">This parameter is the sqlStatement that will be passed in to excute.</param>
            <param name="sqlStatementType">This parameter is the sqlStatementType for this sqlStatement to be excuted.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExecutingSqlStatementMsSql2008FeatureSourceEventArgs.SqlStatement">
            <summary>This property gets and sets the SqlStatement that will be excuted.</summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExecutingSqlStatementMsSql2008FeatureSourceEventArgs.ExecutingSqlStatementType">
            <summary>This property gets and sets the SqlStatementType of the SqlStatement that will be excuted.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Pj_Aea">
            <summary>
            definition of Class Pj_Aea
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.FileNativeImageTileCache">
            <summary>
            This class is a concrete class inherits from NativeImageTileCache.
            In this class, the tiles will be saved in disk and can be viewed very
            conveniently.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.NativeImageTileCache">
            <summary>
            This is the base class for NativeTileCache system which inherits from TileCache class.
            </summary>
            <remarks>TileCahce system is very efficient in improving the performance of
            application, especially when large data or remote server images are included.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.NativeImageTileCache.#ctor(System.String,ThinkGeo.MapSuite.Core.TileImageFormat,ThinkGeo.MapSuite.Core.TileMatrix)">
            <summary>
            This is the constructor of the class.
            </summary>
            <param name="cacheId">This is the cache identifier which marks its difference with other TileCache.</param>
            <param name="imageFormat">This is the imageFormate showing what kind of image we are trying to save.</param>
            <param name="tileMatrix">This is the tile matrix system which is used for caculating tiles.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.NativeImageTileCache.GetTile(ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>
            This method returns the NativeImageTile corresponding to the tile bounding box passed in.
            </summary>
            <param name="tileBoundingBox">The target boundingBox for the tile to fetch.</param>
            <returns>Returns the NativeImageTile corresponding to the passed in boundingBox.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape is not a valid rectangle, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.NativeImageTileCache.GetTile(System.Int64,System.Int64)">
            <summary>
            This method returns the NativeImageTile corresponding to passed in row and column.
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the NativeImageTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.NativeImageTileCache.GetTiles(ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>
            This method returns all the NativeImageTiles within the passed in world extent.
            </summary>
            <param name="extent">The target worldExtent will be used to fetch all the NativeImageTiles from.</param>
            <returns>Returns a collection of NativeImageTiles within the passed in worldExtent.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape is not a valid rectangle, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.NativeImageTileCache.GetTileCore(System.Int64,System.Int64)">
            <summary>
            This abstract method returns the NativeImageTile corresponding to passed in row and column. 
            Each concrete TileCache need to implement this logic to get tile from a row and column.
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the NativeImageTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileNativeImageTileCache.#ctor">
            <summary>
            This is the default constructor.
            </summary>
            <remarks>If you use this constructor, you have to set the properties manually.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileNativeImageTileCache.#ctor(System.String,System.String,ThinkGeo.MapSuite.Core.TileImageFormat,ThinkGeo.MapSuite.Core.TileMatrix)">
            <summary>
            This is the constructor with all the parameters needed passed in.
            </summary>
            <param name="cacheDirectory">This parameter specifies the cache directory of the tile cache.</param>
            <param name="cacheId">This parameter specifies the cache id of the tile cache.</param>
            <param name="imageFormat">This parameter specifies the image format of the tile cahce.</param>
            <param name="tileMatrix">This parameter specifies the tile matrix of the tile cache.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileNativeImageTileCache.GetTileCore(System.Int64,System.Int64)">
            <summary>
            This method returns the NativeImageTile corresponding to passed in row and column. 
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the NativeImageTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileNativeImageTileCache.SaveTileCore(ThinkGeo.MapSuite.Core.Tile)">
            <summary>
            This method will save the target tile passed in, you could override this API to create your own logic.
            </summary>
            <param name="tile">The target tile to be saved.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileNativeImageTileCache.DeleteTileCore(ThinkGeo.MapSuite.Core.Tile)">
            <summary>
            This method will delete the target tile passed in.
            </summary>
            <param name="tile">The target tile to be deleted.</param>
            <remarks>This method will not take effect when the ReadOnly is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FileNativeImageTileCache.ClearCacheCore">
            <summary>
            This method will clear all the tiles in the tileCache.
            </summary>
            <remarks>This method will not take effect when the ReadOnly is set to true.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FileNativeImageTileCache.CacheDirectory">
            <summary>
            Gets or sets the cache direcory.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PointStyles">
            <summary>
            This class provides commonly-used <strong>GeoPointStyles</strong> and some methods to
            create various kinds of GeoPointstyles. A <strong>GeoStyle</strong> is a kind of
            sheet used to render the map.
            </summary>
            <remarks>
            The <strong>GeoStyle</strong> is a very important concept. MapSuite provides three
            kinds of styles: <strong>GeoAreaStyle</strong>,
            <strong>GeoLineStyle</strong>, and <strong>GeoPointStyle</strong>.
            <strong>GeoAreaStyle</strong> is used to render area-type data on the map,
            <strong>GeoLineStyle</strong> is used to render line-type data on the map,
            <strong>GeoPointStyle</strong> is used to render point-type data on the map.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimplePointStyle(ThinkGeo.MapSuite.Core.PointSymbolType,ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>
            Static API to create a point style.
            </summary>
            <param name="pointStyle">This parameter determines the PointStyle symbol type.</param>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimplePointStyle(ThinkGeo.MapSuite.Core.PointSymbolType,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single,System.Single)">
            <summary>
            Static API to create a point style.
            </summary>
            <param name="pointStyle">This parameter determines the PointStyle symbol type.</param>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <param name="outlineWidth">This parameter determines the PointStyle outline width.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimplePointStyle(ThinkGeo.MapSuite.Core.PointSymbolType,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>
            Static API to create a point style.
            </summary>
            <param name="pointStyle">This parameter determines the PointStyle symbol type.</param>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimpleCircleStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>
            Static API to create a circle point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimpleCircleStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>
            Static API to create a circle point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <param name="outlineWidth">This parameter determines the PointStyle outline width.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimpleCircleStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>
            Static API to create a circle point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimpleSquareStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>
            Static API to create a square point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimpleSquareStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>
            Static API to create a square point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimpleSquareStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>
            Static API to create a square point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <param name="outlineWidth">This parameter determines the PointStyle outline width.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimpleStarStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>
            Static API to create a star point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimpleStarStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>
            Static API to create a star point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimpleStarStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>
            Static API to create a star point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <param name="outlineWidth">This parameter determines the PointStyle outline width.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimpleTriangleStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>
            Static API to create a triangle point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimpleTriangleStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>
            Static API to create a triangle point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateSimpleTriangleStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>
            Static API to create a triangle point style.
            </summary>
            <param name="fillColor">This parameter determines the PointStyle fill color.</param>
            <param name="size">This parameter determines the PointStyle size.</param>
            <param name="outlineColor">This parameter determines the PointStyle outline color.</param>
            <param name="outlineWidth">This parameter determines the PointStyle outline width.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateCompoundCircleStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>
            Static API to create a compound circle point style.
            </summary>
            <param name="fillColor1">This parameter determines the outer circle's PointStyle fill color.</param>
            <param name="size1">This parameter determines the outer circle's PointStyle size.</param>
            <param name="outlineColor1">This parameter determines the outer circle's PointStyle outline color.</param>
            <param name="outlineWidth1">This parameter determines the outer circle's PointStyle outline width.</param>
            <param name="fillColor2">This parameter determines the inner circle's PointStyle fill color.</param>
            <param name="size2">This parameter determines the inner circle's PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateCompoundCircleStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>
            Static API to create a compound circle point style.
            </summary>
            <param name="fillColor1">This parameter determines the outer circle's PointStyle fill color.</param>
            <param name="size1">This parameter determines the outer circle's PointStyle size.</param>
            <param name="outlineColor1">This parameter determines the outer circle's PointStyle outline color.</param>
            <param name="outlineWidth1">This parameter determines the outer circle's PointStyle outline width.</param>
            <param name="fillColor2">This parameter determines the inner circle's PointStyle fill color.</param>
            <param name="outlineColor2">This parameter determines the inner circle's PointStyle outline color.</param>
            <param name="outlineWidth2">This parameter determines the inner circle's PointStyle outline width.</param>
            <param name="size2">This parameter determines the inner circle's PointStyle size.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyles.CreateCompoundPointStyle(ThinkGeo.MapSuite.Core.PointSymbolType,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single,System.Single,ThinkGeo.MapSuite.Core.PointSymbolType,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single,System.Single)">
            <summary>
            Static API to create a compound circle point style.
            </summary>
            <param name="pointStyle1">This parameter determines the outer circle's pointstyle symbol type.</param>
            <param name="fillColor1">This parameter determines the outer circle's PointStyle fill color.</param>
            <param name="size1">This parameter determines the outer circle's PointStyle size.</param>
            <param name="outlineColor1">This parameter determines the outer circle's PointStyle outline color.</param>
            <param name="outlineWidth1">This parameter determines the outer circle's PointStyle outline width.</param>
            <param name="pointStyle2">This parameter determines the inner circle's pointstyle symbol type.</param>
            <param name="fillColor2">This parameter determines the inner circle's PointStyle fill color.</param>
            <param name="size2">This parameter determines the inner circle PointStyle size.</param>
            <param name="outlineColor2">This parameter determines the inner circle's PointStyle outline color.</param>
            <param name="outlineWidth2">This parameter determines the inner circle's PointStyle outline width.</param>
            <returns>The created point style.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyles.City1">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a city.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyles.City2">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a city.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyles.City3">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a city.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyles.City4">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a city.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyles.City5">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a city.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyles.City6">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a city.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyles.City7">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a city.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyles.Capital1">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a capital.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyles.Capital2">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a capital.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyles.Capital3">
            <summary> Get the commonly-used <strong>PointStyle</strong> to render a capital.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ShapeFileReadWriteMode">
            <summary>This enumeration represent read only or read-write nature of a Shape File.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileReadWriteMode.ReadOnly">
            <summary>Read only.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeFileReadWriteMode.ReadWrite">
            <summary>Read and write.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ClosingRasterSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the ClosingRasterSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClosingRasterSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
            <remarks>None</remarks>
            <returns>None</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LabelDuplicateRule">
            <summary>This enumeration defines the different labeling duplicate rules.</summary>
            <remarks>
            Duplicate refers to the condition where a label's text is exactly the same as another label.
            An example case where this is common is a road where each intersection is its own segment.
            In such a case, you do not want to label each segment as it would be highly redundant.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.LabelDuplicateRule.OneDuplicateLabelPerQuadrant">
            <summary>There may be only one label in each of the four quadrants.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.LabelDuplicateRule.NoDuplicateLabels">
            <summary>There may be no duplicate labels.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.LabelDuplicateRule.UnlimitedDuplicateLabels">
            <summary>There may be an unlimited number of duplicate labels.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DbfColumnInfo.op_Addition(ThinkGeo.MapSuite.Core.DbfColumnInfo,ThinkGeo.MapSuite.Core.DbfColumnInfo)">
            <summary>This method is an override of the + functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DbfColumnInfo.op_Equality(ThinkGeo.MapSuite.Core.DbfColumnInfo,ThinkGeo.MapSuite.Core.DbfColumnInfo)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DbfColumnInfo.op_Inequality(ThinkGeo.MapSuite.Core.DbfColumnInfo,ThinkGeo.MapSuite.Core.DbfColumnInfo)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.YahooMapZoomLevelSet">
            <summary>This class represents the zoom levels used by Yahoo Maps.</summary>
            <returns>None</returns>
            <remarks>
            If you want to create some layers that match up with Yahoo Maps layers, you
            should use this ZoomSet.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.YahooMapZoomLevelSet.#ctor">
            <summary>This class represents the zoom levels used by Yahoo Maps.</summary>
            <returns>None</returns>
            <remarks>
            If you want to create some layers that match up with Yahoo Maps layers, you
            should use this ZoomSet.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer">
            <summary>
            The <strong>ScaleBarAdornmentLayer</strong> class allows you show a bar graphic on
            the map that displays the distance scale for the current map extent.
            </summary>
            <remarks>
            Use the <strong>ScaleBarAdornmentLayer</strong> class as a quick way to implement
            a <strong>ScaleBar</strong>. When using the <strong>ScaleBarAdornmentLayer</strong>,
            you also need to add a ScaleLineAdornmentLayer to the map control. One thing we should pay attention to is that the
            ScaleBar will not be drawn when the CurrentExtent is outside of
            Range(-90,180,90,-180).
            </remarks>
            <example>
            	<code lang="CS" title="C# Sample" description="The example below will display a ScaleBarAdornmentLayer on the Map.">
            		<![CDATA[
            ScaleBarAdornmentLayer scaleLineAdornmentLayer = new ScaleBarAdornmentLayer();
            mapEngine.AdornmentLayers.Add("ScaleLineAdornmentLayer", scaleLineAdornmentLayer);]]>
            	</code>
            	<code lang="VB" title="VB Sample" description="The example below will display a ScaleBarAdornmentLayer on the Map.">
            		<![CDATA[
            Dim scaleLineAdornmentLayer As New ScaleBarAdornmentLayer() 
            mapEngine.AdornmentLayers.Add("ScaleLineAdornmentLayer", scaleLineAdornmentLayer) ]]>
            	</code>
            </example>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer.#ctor">
            <summary>
            Creates a new instance of the <strong>ScaleBarAdornmentLayer</strong>
            class.
            </summary>
            <remarks>
            When displaying a <strong>ScaleBarAdornmentLayer</strong>, we need to instance a
            ScaleLineAdornmentLayer and add it to MapEngine. The ScaleBar will not be drawn when the
            <strong>CurrentExtent</strong> is outside of the world Extent(-90,180-,90,-180).
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the Layer.</summary>
            <remarks>
            This abstract method is called from the concrete public method Draw. This
            method draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties to
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter represents the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer.ConvertGeographyUnitToDistanceUnit(ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns a DistanceUnit that has been converted from a GeographyUnit.
            </summary>
            <returns>This method returns a DistanceUnit that has been converted from a GeographyUnit.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a GeographyUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <remarks>None</remarks>
            <param name="unit">The GeographyUnit you want to convert.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer.DisplayUnitString">
            <summary>
            This propery is a dictionary that exposes what text will be drawn to represent the ScaleLine
            Unit.
            </summary>
            <remarks>
            We will display different letters for different units of measure; for example: "m"
            for meters, "ft" for feet, etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer.UnitFamily">
             <summary>
             Gets or sets the <strong>UnitSystem</strong> (Imperial/Metric) to be used for the ScaleBar.
             </summary>
            <remarks>
             By setting this property, you can control whether to use a metric or imperial
             measurement system for the ScaleBar.
             </remarks>
            <example>
            The example below sets the <strong>ScaleBar</strong> to use the metric system of measurement.
                 <code lang="VB" title="UnitFamily">
            Dim adornment As New ScaleBarAdornmentLayer() 
            adornment.UnitFamily = UnitSystem.Metric 
                 </code>
                 <code lang="CS" title="UnitFamily">
            ScaleBarAdornmentLayer adornment = new ScaleBarAdornmentLayer();
            adornment.UnitFamily = UnitSystem.Metric;
                 </code>
            </example>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer.NumberFormat">
            <summary>The format of the numbers shown in the ScaleBar.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer.Font">
            <summary>
            This property specifies the <strong>GeoFont</strong> that will be used to draw the text of
            the ScaleBar.
            </summary>
            <example>
            	<code lang="VB" title="C# Sample" description="The example shows how to set the Font of the AdormentLayer.">
            		<![CDATA[
            scaleLineAdornmentLayer.Font = new GeoFont("Arial", 12, DrawingFontStyles.Italic);]]>
            	</code>
            	<code lang="VB" title="VB Sample" description="The example shows how to set the Font of AdormentLayer.">
            		<![CDATA[
            scaleLineAdornmentLayer.Font = New GeoFont("Arial", 12, DrawingFontStyles.Italic)]]>
            	</code>
            </example>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer.TextColor">
            <summary>
            This property specifies the <strong>TextColor</strong> that will be used to draw the text of the ScaleBar.
            </summary>
            <example>
            	<code lang="VB" title="C# Sample" description="The example shows how to set the Font of the AdormentLayer.">
            		<![CDATA[
            scaleLineAdornmentLayer.TextColor = GeoColor.SimpleColors.Red;]]>
            	</code>
            	<code lang="VB" title="VB Sample" description="The example shows how to set the Font of AdormentLayer.">
            		<![CDATA[
            scaleLineAdornmentLayer.TextColor = GeoColor.SimpleColors.Red ]]>
            	</code>
            </example>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer.Thickness">
            <summary>
            Gets or sets the thickness of the ScaleBar. It is an integer value representing the height
            of the ScaleBar in screen units.
            </summary>
            <requirements>
            You can set this property to control the height (or thickness) of the ScaleBar.
            A large number would make the ScaleBar thicker, while a smaller number would make it
            thinner.
            </requirements>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer.MaxWidth">
            <summary>
            Gets or Sets the <strong>MaxWidth</strong> of the ScaleBar.
            </summary>
            <remarks>
            You can use this property to set the maximum width that you want the ScaleBar to
            occupy on the map. The <strong>ScaleBarAdornmentLayer</strong> will automatically adjust its
            size based upon the current extent of the map. By setting this property, you can control
            the maximum width the ScaleBar will occupy on the map.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer.BarBrush">
            <summary>
            The property is the <strong>GeoBrush</strong> that will be used to draw the ScaleBar.
            </summary>
            <remarks>
            This <strong>BarBrush</strong> property will give you full control over the
            appearance of the <strong>ScaleBarAdornmentLayer</strong>.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer.MaskBrush">
            <summary>
            Gets or sets the color for the <strong>ScaleBarAdornmentLayer</strong>'s mask, if
            the <strong>HasMask</strong> property is set to true.
            </summary>
            <requirements>
            Setting the <strong>MaskBrush</strong> gives you control over how the mask of the
            <strong>ScaleBarAdornmentLayer</strong> will look. For example, if you have set the map's
            <strong>CanvasBrush</strong> to a TextureBrush, you might want to set the ScaleBar mask
            to the same brush to keep the two looking similar.
            </requirements>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer.HasMask">
            <summary>
            Gets or sets whether the ScaleBar will have a mask or not. A boolean value representing
            whether or not a mask is shown.
            </summary>
            <remarks>
            Depending upon the look of your map and your requirements, you may or may not want
            a mask on the ScaleBar. You can control whether or not the ScaleBar has a mask by
            setting this property. If you set the <strong>HasMask</strong> property to true, be
            sure to specify a mask color (or texture) by using the <strong>MaskBrush</strong> property.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ScaleBarAdornmentLayer.MaskContour">
            <summary>Gets or sets the pen for the outline of the ScaleBar mask.</summary>
            <remarks>
            By using this property you can control the border of the mask, if the
            <strong>HasMask</strong> property is set to true. If you do not want a contour or
            border to show, you should set the pen to transparent.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GoogleMapsPictureFormat">
            <summary>This enumeration specifies the picture formats when getting images back to client from Google Maps.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GoogleMapsPictureFormat.Jpeg">
            <summary>This format will specify the returing images from GoogleMaps in Jpeg format.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GoogleMapsPictureFormat.Gif">
            <summary>This format will specify the returing images from GoogleMaps in Gif format.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GoogleMapsPictureFormat.Png8">
            <summary>This format will specify the returing images from GoogleMaps in Png8 format.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GoogleMapsPictureFormat.Png32">
            <summary>This format will specify the returing images from GoogleMaps in Png32 format.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ExecutingSqlStatementOracleFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the ExecutingSqlStatement event in OracleFeatureSource.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExecutingSqlStatementOracleFeatureSourceEventArgs.#ctor(System.String)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="sqlStatement">This parameter is the sqlStatement that will be passed in to excute.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExecutingSqlStatementOracleFeatureSourceEventArgs.#ctor(System.String,ThinkGeo.MapSuite.Core.ExecutingSqlStatementType)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="sqlStatement">This parameter is the sqlStatement that will be passed in to excute.</param>
            <param name="sqlStatementType">This parameter is the sqlStatementType for this sqlStatement to be excuted.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExecutingSqlStatementOracleFeatureSourceEventArgs.SqlStatement">
            <summary>This property gets and sets the SqlStatement that will be excuted.</summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExecutingSqlStatementOracleFeatureSourceEventArgs.ExecutingSqlStatementType">
            <summary>This property gets and sets the SqlStatementType of the SqlStatement that will be excuted.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.FeatureLayer">
            <summary>This class represents a layer that is comprised of feature data.</summary>
            <remarks>
            This abstract class is the basis for all feature-based layers in the system. Its
            methods and properties deal with feature data manipulation. Some of the classes that
            currently inherit from this are ShapeFileFeatureLayer, OracleFeatureLayer and so on.<br/>
            	<br/>
            When creating your own FeatureLayer, you need only to set a FeatureSource and create a
            useful constructor; the class will take care of the rest. There are no required
            abstract members. It may be helpful for you to add additional properties specific to
            your FeatureSource.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureLayer.#ctor">
            <summary>This is a constructor for this class.</summary>
            <returns>None</returns>
            <remarks>This is a constructor for this class.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureLayer.OnDrawingFeatures(ThinkGeo.MapSuite.Core.DrawingFeaturesEventArgs)">
            <summary>This method raises the DrawingFeatures event.</summary>
            <returns>None</returns>
            <remarks>
            	<list type="bullet">
            		<item>You can call this method from a derived class to enable it to raise the
                    event. This may be useful if you plan to extend the FeatureLayer and you need
                    access to the event.<br/>
            			<br/>
                    This event is meant to allow you to add or remove the features to be drawn.</item>
            	</list>
            </remarks>
            <param name="e">This parameter represents the event arguments for the event.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureLayer.SetupTools">
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method SetupToolsCore.
                The SetupTools method allows you to create the QueryTool, EditTools and other tools
                you may need on your object. We created this method so that if you want to extend
                one of the tool classes, you can override the SetupToolsCore and create any class you
                want.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <summary>This method sets up the EditTools and QueryTools objects.</summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureLayer.SetupToolsCore">
            <remarks>
            <para>This method is the concrete wrapper for the abstract method SetupTools.
            The SetupTools method allows you to create the QueryTool, EditTools and other tools
            you may need on your object. We created this method so that if you want to extend
            one of the tool classes, you can override the SetupToolsCore and create any class you
            want.</para>
            </remarks>
            <summary>This method sets up the EditTools and QueryTools objects.</summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureLayer.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method opens the FeatureLayer so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This abstract method is called from the concrete public method Open. The Open
            method plays an important role, as it is responsible for initializing the FeatureLayer.
            Most methods on the FeatureLayer will throw an exception if the state of the FeatureLayer
            is not opened. When the map draws each FeatureLayer, it will open the layer as one of its first
            steps, then after it is finished drawing with that FeatureLayer it will close it. In
            this way we are sure to release all resources used by the FeatureLayer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureLayer.CloseCore">
            <summary>
            This method closes the FeatureSource and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concrete public method Close.
            The close method plays an important role in the life cycle of the FeatureLayer. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed FeatureLayer is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureLayer.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the FeatureLayer.</summary>
            <returns>This method returns the bounding box of the FeatureLayer.</returns>
            <remarks>
            This method is called from the concrete public method GetBoundingBox. It returns
            the bounding box of the FeatureLayer.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>
            This method will draw the FeatureLayer source based on the parameters
            provided.
            </summary>
            <returns>None</returns>
            <remarks>
            The DrawCore will be called when the layer is being drawn. It will check if the InternalFeatures are
            within the extent and whether it is within a defined zoom level. If these parameters
            are met, then it will apply the styles of the proper zoom level to the InternalFeatures for
            drawing. Lastly, it will draw InternalFeatures on the GeoImage or native image passed in to the
            method.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer is not opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the labeledInLayers, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the worldExtent, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <param name="canvas">
            This parameter is the GeoCanvas used to Draw the layer.
            </param>
            <param name="labelsInAllLayers">This parameter is not used for ImageLayers.</param>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.FeatureLayer.DrawingFeatures">
            <summary>This event is raised when features are about to be drawn in the layer.</summary>
            <remarks>
            This event is raised when features are about to be drawn in the layer. In the event
            arguments, there is a collection of features to be drawn. You can easily add or remove
            items from this collection so that extra items will draw or not draw.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureLayer.EditTools">
            <summary>
            This property gets the EditTools that allow you to easily edit InternalFeatures in the
            Feature Layer.
            </summary>
            <value>
            This property gets the EditTools that allow you to easily edit InternalFeatures in the
            Feature Layer.
            </value>
            <remarks>
            The EditTools are supplied as an easily accessible wrapper for the editing
            methods of the FeatureSource.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureLayer.FeatureIdsToExclude">
            <summary>
            A collection of strings representing record id of features not to get in the Layer. 
            </summary>
            <remarks>
            This string collection is a handy place to specify what records not to get from the source. 
            Suppose you have a shape file of roads and you want to hide the roads within a particular 
            rectangle, simply execute GetFeaturesInsideBoundingBox() and add the id of the return 
            features to the collection and forget about them. Since you can set this by Layer it 
            makes is easy to determine what to and what not to. 
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureLayer.QueryTools">
            <summary>
            This property gets the QueryTools that allow you to easily query Features from the
            Feature Layer.
            </summary>
            <value>
            This property gets the QueryTools that allow you to easily query Features from the
            Feature Layer.
            </value>
            <remarks>
            This property gets the QueryTools that allow you to easily query Features from the
            Feature Layer. The QueryTools are supplied as an easily accessible wrapper for the
            query methods of the FeatureSource.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureLayer.FeatureSource">
            <summary>This property gets the FeatureSource for the FeatureLayer.</summary>
            <value>This property gets the FeatureSource for the FeatureLayer.</value>
            <remarks>
            The FeatureSource is the provider of data to the FeatureLayer. There are different
            FeatureSource classes to match the various ways that feature data is stored. It is
            important that, when you inherit from the FeatureLayer, in the constructor you set
            the FeatureSource you want to use.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureLayer.DrawingQuality">
            <summary>
            This property gets and sets the general drawing quality for the FeatureLayer's
            canvas.
            </summary>
            <value>
            This property gets the general drawing quality for the FeatureLayer's
            canvas.
            </value>
            <remarks>
            The DrawingQuality enumeration allows you to control, in a macro sense, the drawing
            quality that will be used in the GeoCanvas. Each GeoCanvas, which is responsible for
            drawing of the features, may have its own specialized drawing quality properties. What the
            DrawingQuality enumeration does is define some general guidelines for each GeoCanvas.
            For example, if you set the DrawingQuality to HighSpeed, then inside of the
            GdiPlusGeoCanvas there is a profile for HighSpeed. This profile sets specific
            properties, such as the smoothing mode and composing drawing mode of the
            GdiPlusGeoCanvas. As each GeoCanvas may have different drawing quality properties, this
            offers a general way to control drawing quality and speed.<br/>
            	<br/>
            If you need complete control over how a specific GeoCanvas will draw, then you can
            set the DrawingQuality to Custom. This will tell the specific GeoCanvas to use the
            properties on its own object instead of one of the pre-defined profiles. If one of the
            profiles -- such as HighSpeed or HighQuality -- is set, then the specific GeoCanvas ignores its
            own properties for drawing quality.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureLayer.ZoomLevelSet">
            <summary>
            This property gets and sets the ZoomLevelSet, which contains the specific zoom
            levels for the FeatureLayer.
            </summary>
            <value>
            This property gets the ZoomLevelSet, which contains the specific zoom levels for
            the FeatureLayer.
            </value>
            <remarks>
            The ZoomLevelSet is a class that contains all of the ZoomLevels for the
            FeatureLayer. Each ZoomLevel contains the styles that are used to determine how to draw the
            InternalFeatures.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureLayer.DrawingMarginPercentage">
            <summary>
            This property gets and sets the extra drawing margin as a percentage around the
            map that draw to ensure that labeling is correct.
            </summary>
            <value>
            This property gets the extra drawing margin as a percentage around the map that
            draws to ensure that labeling is correct.
            </value>
            <remarks>
            This extra margin that we draw exists so that labels match up if they are partially
            cut off.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureLayer.IsOpenCore">
            <summary>
            This property returns true if the FeatureLayer is open and false if it is
            not.
            </summary>
            <value>
            This property returns true if the FeatureLayer is open and false if it is
            not.
            </value>
            <remarks>
            Various methods on the FeatureLayer require that it be in an open state. If one of
            those methods is called when the state is not open, then the method will throw an
            exception. To enter the open state, you must call the FeatureLayer Open method. The
            method will raise an exception if the current FeatureLayer is already open.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.CustomColumnFetchEventArgs">
            <summary>This class represents the parameters passed in through the CustomFieldFetch event.</summary>
            <remarks>
            CustomColumnFetch Event Background<br/>
            	<br/>
            This event is used primarily when you have data relating to a particular feature or set of
            features that is not within source of the data. For example, you may have a shape file
            of the world whose .dbf component describes the area and population of each country.
            Additionally, in an outside SQL Server table, you may also have data about the countries,
            and it is this data that you wish to use for determining how you want to color
            each country.<br/>
            	<br/>
            To integrate this SQL data, you simply create a file name that does not exist in the
            .dbf file.  Whenever Map Suite is queried to return records that specifically require
            this field, the FeatureSource will raise this event and allow you the developer to
            supply the data. In this way, you can query the SQL table and store the
            data in some sort of collection, and then when the event is raised, simply supply that
            data.<br/>
            	<br/>
            As this is an event, it will raise for each feature and field combination requested.
            This means that the event can be raised quite often, and we suggest that you cache the
            data you wish to supply in memory. We recommend against sending out a new SQL query
            each time this event is raised. Image that you are supplementing two columns and your query
            returns 2,000 rows. This means that if you requested those fields, the event would be raised
            4,000 times.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.CustomColumnFetchEventArgs.#ctor(System.String,System.String)">
            <summary>This is the constructor that allows you to create the event arguments.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="columnName">The column name you need data for.</param>
            <param name="id">The Id of the feature you need data for.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.CustomColumnFetchEventArgs.ColumnName">
            <summary>This property returns the column name that you need to return data for.</summary>
            <decimalDegreesValue>This property returns the column name that you need to return data for.</decimalDegreesValue>
            <remarks>
            	<para>You will need to look up the Id in your external data source and find this
                column's data.<br/>
            		<br/>
            		<br/>
                CustomColumnFetch Event Background<br/>
            		<br/>
                This event is used primarily when you have data relating to a particular feature or set of
                features that is not within source of the data. For example, you may have a shape file
                of the world whose .dbf component describes the area and population of each country.
                Additionally, in an outside SQL Server table, you may also have data about the countries,
                and it is this data that you wish to use for determining how you want to color
                each country.<br/>
            	<br/>
                To integrate this SQL data, you simply create a file name that does not exist in the
                .dbf file.  Whenever Map Suite is queried to return records that specifically require
                this field, the FeatureSource will raise this event and allow you the developer to
                supply the data. In this way, you can query the SQL table and store the
                data in some sort of collection, and then when the event is raised, simply supply that
                data.<br/>
            	<br/>
                As this is an event, it will raise for each feature and field combination requested.
                This means that the event can be raised quite often, and we suggest that you cache the
                data you wish to supply in memory. We recommend against sending out a new SQL query
                each time this event is raised. Image that you are supplementing two columns and your query
                returns 2,000 rows. This means that if you requested those fields, the event would be raised
                4,000 times.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.CustomColumnFetchEventArgs.Id">
            <summary>This property returns the Id that you need to return data for.</summary>
            <decimalDegreesValue>This property returns the Id that you need to return data for.</decimalDegreesValue>
            <remarks>
            You will need to look up the Id in your external data source and find this
            field's data.<br/>
            	<br/>
            CustomColumnFetch Event Background<br/>
            	<br/>
            It is used primarily when you have data relating to a particular feature or set of
            features that is not within source of the data. For example, you may have a shape file
            of the world whose .dbf component describes the area and population of each country.
            Additionally, in an outside SQL Server table, you may also have data about the countries,
            and it is this data that you wish to use for determining how you want to color
            each country.<br/>
            	<br/>
            To integrate this SQL data, you simply create a file name that does not exist in the
            .dbf file.  Whenever Map Suite is queried to return records that specifically require
            this field, the FeatureSource will raise this event and allow you the developer to
            supply the data. In this way, you can query the SQL table and store the
            data in some sort of collection, and then when the event is raised, simply supply that
            data.<br/>
            	<br/>
            As this is an event, it will raise for each feature and field combination requested.
            This means that the event can be raised quite often, and we suggest that you cache the
            data you wish to supply in memory. We recommend against sending out a new SQL query
            each time this event is raised. Image that you are supplementing two columns and your query
            returns 2,000 rows. This means that if you requested those fields, the event would be raised
            4,000 times.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.CustomColumnFetchEventArgs.ColumnValue">
            <summary>
            This parameter returns the field decimalDegreesValue that the event is seeking. It is intended
            to be set in the event.
            </summary>
            <decimalDegreesValue>
            This parameter returns the field decimalDegreesValue that the event is seeking. It is intended
            to be set in the event.
            </decimalDegreesValue>
            <remarks>
            When you lookup the Id and FieldName, you should set this property with the data
            from your external data source.<br/>
            	<br/>
            CustomColumnFetch Event Background<br/>
            	<br/>
            It is used primarily when you have data relating to a particular feature or set of
            features that is not within source of the data. For example, you may have a shape file
            of the world whose .dbf component describes the area and population of each country.
            Additionally, in an outside SQL Server table, you may also have data about the countries,
            and it is this data that you wish to use for determining how you want to color
            each country.<br/>
            	<br/>
            To integrate this SQL data, you simply create a file name that does not exist in the
            .dbf file.  Whenever Map Suite is queried to return records that specifically require
            this field, the FeatureSource will raise this event and allow you the developer to
            supply the data. In this way, you can query the SQL table and store the
            data in some sort of collection, and then when the event is raised, simply supply that
            data.<br/>
            	<br/>
            As this is an event, it will raise for each feature and field combination requested.
            This means that the event can be raised quite often, and we suggest that you cache the
            data you wish to supply in memory. We recommend against sending out a new SQL query
            each time this event is raised. Image that you are supplementing two columns and your query
            returns 2,000 rows. This means that if you requested those fields, the event would be raised
            4,000 times.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RtreeFile">
            <summary>
            	The RtreeFile class handles all file read and write operations of Rtree.
            	Each file has a file header and one or more pages. 
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeFile.#ctor">
            <summary>
            DefauLb constructor
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeFile.Create(System.String,ThinkGeo.MapSuite.Core.Gist_Ext_Id,ThinkGeo.MapSuite.Core.RtreeSpatialIndex.OpenStreamLoadingDelegate,System.Boolean)">
            <summary>
            Create point type index file.
            </summary>
            <param name="fileName"> Index file name	</param>
            <param name="extId">	File type id	</param>
            <param name="openStreamLoadingDelegate">The delegate to open the stream.</param>
            <param name="isFloat">True to mark it as single or float.</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeFile.InitFileHeader(ThinkGeo.MapSuite.Core.Gist_Ext_Id,System.Boolean)">
            <summary>
            Init file header according to extId.
            </summary>
            <param name="extId"> File type Id</param>
            <param name="isFloat">True to mark it as float or single.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeFile.Open(System.String,System.Boolean,ThinkGeo.MapSuite.Core.RtreeSpatialIndex.OpenStreamLoadingDelegate)">
            <summary>
            Open an index file.
            </summary>
            <param name="fileName">		Index file name				</param>
            <param name="isReadOnly">	If file is open as read only</param>
            <param name="openStreamLoadingEvent">The openstream to open the current RTree.</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeFile.Close">
            <summary>
            Close a previously opened index file.
            </summary>
            <returns>
            	true for opened
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeFile.Flush">
            <summary>
            Flush contents to disk.
            </summary>
            <returns>
            true for succeed
            false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeFile.IsReadOnly">
            <summary>
            Test if file is read only.
            </summary>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeFile.ReadFileHeader">
            <summary>
            Read the file header from the file.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeFile.WriteFileHeader">
            <summary>
            Write the file header to the file.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeFile.GetFileStream">
            <summary>
            Get current file stream.
            </summary>
            <returns> FileStream object</returns> 
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeFile.GetFileType">
            <summary>
            Get file type.
            </summary>
            <returns> file type Id</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeFile.GetRootNodePage">
            <summary>
            Get root node's page (its page number is 1).
            </summary>
            <returns>DataPage object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeFile.GetPageCount">
            <summary>
            Get the page count of this file.
            </summary>
            <returns>page count</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PAGE_HEADER">
            <summary>
             Page header.
             Its size must be 16 bytes.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PAGE_HEADER.Init">
            <summary>
            Init PAGE_HEADER
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PAGE_HEADER.GetSize">
            <summary>
            Return the size of this struct.
            </summary>
            <returns> size of PAGE_HEADER</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PAGE_HEADER.Read(System.IO.BinaryReader)">
            <summary>
            Read contents from BinaryReader r.
            </summary>
            <param name="r">BinaryReader object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PAGE_HEADER.Write(System.IO.BinaryWriter)">
            <summary>
            Write contents to BinaryWriter w.
            </summary>
            <param name="w"> BinaryWriter object</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PAGE_HEADER.ToString">
            <summary>
            For debugging.
            </summary>
            <returns> dumped string</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeFileHeader.FileLength">
            <summary>
            This variable is in 16-bit decimalDegreesValue.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeometryCollectionShape.#ctor">
            <overloads>This overload creates the GeometryCollectionShape without any shapes.</overloads>
            <summary>This constructor creates the GeometryCollectionShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeometryCollectionShape.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.BaseShape})">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in any baseShapes which are invalid, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the baseShapes, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeometryCollectionShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the GeometryCollectionShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeometryCollectionShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates the GeometryCollectionShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.YahooMapsPictureFormat">
            <summary>This enumeration specifies the picture formats when getting images back to client from Yahoo Maps.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.YahooMapsPictureFormat.Png">
            <summary>This format will specify the returing images from YahooMaps in Jpeg format.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.YahooMapsPictureFormat.Gif">
            <summary>This format will specify the returing images from YahooMaps in Gif format.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RestrictionMode">
            <summary>This enumeration specifies the restriction mode.</summary>
            <seealso cref="T:ThinkGeo.MapSuite.Core.RestrictionLayer">RestrictionLayer Class</seealso>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.RestrictionMode.HideZones">
            <summary>Represents "hide zones".</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.RestrictionMode.ShowZones">
            <summary>Represents "show zones".</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Jpeg2000RasterLayer">
            <summary>
            This class represents a .JP2 (JPEG2000) image type to be drawn on the map.
            </summary>
            <remarks>
            JPEG2000 files are fairly common in the GIS community.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Jpeg2000RasterLayer.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the PathFileName property manually before using the layer.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, then you need to set the PathFileName property
            manually before using the layer.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Jpeg2000RasterLayer.#ctor(System.String)">
            <overloads>
            This constructor allows you to provide the path and filename information for the JP2
            file.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <summary>This is a constructor for the class.</summary>
            <param name="imagePathFilename">This parameter is the path and filename of the JP2 file you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Jpeg2000RasterLayer.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename information for both the JP2 image and its world file.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and filename of the JP2 image file you want to use.</param>
            <param name="worldFilePathFilename">This parameter is the world file path and filename for the JP2 image you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Jpeg2000RasterLayer.#ctor(System.String,ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename for the JP2 image file and the
            image extent to use.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and filename of the JP2 image file you want to use.</param>
            <param name="imageExtent">This parameter is the image extent of JP2 image file you want to use.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.BackgroundLayer">
            <summary>This class draws the background of the map.</summary>
            <remarks>This class draws the background of the map.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BackgroundLayer.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BackgroundLayer.#ctor(ThinkGeo.MapSuite.Core.GeoBrush)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="backgroundBrush">This parameter is the brush that will be used draw the background layer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BackgroundLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>
            This method will draw the background layer based on the parameters
            provided.
            </summary>
            <returns>None</returns>
            <remarks>
            None
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer that is not opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the labeledInLayers, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the worldExtent, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the image, we will throw an ArgumentNullException.</exception>
            <param name="canvas">
            This parameter is the GeoCanvas used to Draw the layer.
            </param>
            <param name="labelsInAllLayers">This parameter is not used for BackgroundLayers.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.BackgroundLayer.BackgroundBrush">
            <summary>This property gets and sets the brush for this background layer.</summary>
            <decimalDegreesValue>This property gets the brush for this background layer.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the Brush, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WmsStyleLegend">
            <summary> 
            Structure for storing WMS legend information.
            </summary> 
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WmsOnlineResource">
            <summary> 
            Structure for Online Resource. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsOnlineResource.Type">
            <summary> 
            Size of legend.
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsOnlineResource.OnlineResource">
            <summary> 
            Size of legend.
            </summary> 
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WmsRasterSource">
            <remarks>
            	<para>A Web Map Service (WMS) produces maps of spatially referenced data dynamically
                from geographic information. This international standand defines a "map" as a
                portrayal of geographic information as a digital image file suitable for display on
                a computer screen.</para>
            	<para>A map is not the the data itself. WMS-produced maps are generally rendered in
                a pictorial format such as PNG or JPEG, or occasionally as vector-based graphical
                elements in Scalable Vector Graphics (SVG) or Web Computer Graphics
                Metafile (WebCGM) formats.</para>
            </remarks>
            <summary>Represents an object that encapsulates a Web Map Service (WMS) source.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.#ctor">
            <summary>This is the constructor for the class. If you use this constructor, then you need to set
            the required properties manually.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.#ctor(System.Uri)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <remarks>This constructor initializes a new WmsRasterSource and downloads and parses the service description.
            In an ASP.NET application, the service description is automatically cached for 24 hours when it is not specified.</remarks>
            <param name="uri">URI of the WMS server.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.#ctor(System.Uri,System.Net.WebProxy)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <remarks>This constructor initializes a new WmsRasterSource and downloads and parses the service description
            In an ASP.NET application, the service description is automatically cached for 24 hours when it is not specified.</remarks>
            <param name="uri">URI of the WMS server.</param>
            <param name="proxy">Proxy to use for the current WMS layer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.GetServerLayerNames">
            <summary>This method returns the names of all layers at the server side.</summary>
            <returns>The names of all layers at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.GetServerStyleNames">
            <summary>This method returns the names of all styles at the server side.</summary>
            <returns>The names of all styles at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.GetServerOutputFormats">
            <summary>This method returns the output format at the server side.</summary>
            <returns>The output format at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.GetServerCrss">
            <summary>
            This method returns the projected or geographic coordinate reference systems to be used.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.GetServerExceptionFormats">
            <summary>This method returns the exception format at the server side.</summary>
            <returns>The exception format at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.GetServiceVersion">
            <summary>
            This API gets the WMS server version of the service.
            </summary>
            <returns>Returns a string reflecting the version of the service in WMS.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.GetRequestUrl(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <summary>
            Get the request URL from the client to the WMS.
            </summary>
            <param name="worldExtent">The world extent requested by the client to get the map.</param>
            <param name="canvasWidth">The returning map width, as well as the drawing canvas width.</param>
            <param name="canvasHeight">The returning map height, as well as the drawing canvas height.</param>
            <returns>The request URL from the client to the WMS.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.GetImageWidthCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the width of the image in screen coordinates.</summary>
            <returns>The width of the image in screen coordinates.</returns>
            <remarks>This virtual method is called from the concrete method GetImageWidth.
            It returns the width of the image in screen coordinates.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.GetImageHeightCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the height of the image in screen coordinates.</summary>
            <returns>The height of the image in screen coordinates.</returns>
            <remarks>This virtual method is called from the concrete method GetImageHeight.
            It returns the height of the image in screen coordinates.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.OpenCore">
            <summary>
            This method opens the RasterSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concrete public method Open.
            The Open method plays an important role, as it is responsible for initializing the
            RasterSource. Most methods on the RasterSource will throw an exception if the state of
            the RasterSource is not opened. When the map draws each layer, it will open the
            RasterSource as one of its first steps; then, after it is finished drawing with that
            layer, it will close it. In this way, we are sure to release all resources used by the
            RasterSource.<br/>
            	<br/>
            When implementing this abstract method, consider opening files for file-based sources,
            connecting to databases in the database-based sources and so on. You will get a chance
            to close these in the Close method of the RasterSource.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has already been opened, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the RasterSource.</summary>
            <returns>The bounding box of the RasterSource.</returns>
            <remarks>This method returns the bounding box of the RasterSource.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.GetImageCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass in a worldExtent that is invalid, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a worldExtent that is invalid, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image width that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image height that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method is responsible for returning the image based on the parameters passed
            in. As the core version of this method is abstract, you will need to override it when
            creating our own RasterSource.
            </remarks>
            <summary>
            This method returns an image based on the worldExtent and image width and
            height.
            </summary>
            <returns>
            This method returns an image based on the worldExtent and image width and
            height.
            </returns>
            <param name="worldExtent">This parameter represents the worldExtent you want to draw.</param>
            <param name="canvasWidth">This parameter represents the width of the image you want to draw.</param>
            <param name="canvasHeight">This parameter represents the height of the image you want to draw.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterSource.GetRemoteXml(System.String,System.Net.WebProxy,System.Net.ICredentials)">
            <remarks>
                <para>
                      We only support application/vnd.ogc.wms_xml type.
                      We don't support UPDATESEQUENCE property.     
                </para>
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.WmsRasterSource.SendingRequest">
            <summary>
            This event is called before sending the reqeust for raster image.
            </summary>
            <remarks>
            This event is called before sending the reqeust for raster image.<br/>
            It is typical that user want to get the url of reqeust and modify it according to their requirements. 
            For example, user could create a signiture for it, and verify it on the server side.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.WmsRasterSource.SentRequest">
            <summary>
            This event is called after sent the request for raster image and the HttpWebResponse has come back.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterSource.ActiveLayerNames">
            <summary>
            This property allows the active layers requested from the client to be shown on the map.
            </summary>
            <remarks>When requesting a map, a client may specify the layers to be shown on the map.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterSource.ActiveStyleNames">
            <summary>
            This property allows the active styles requested from the client to be shown on the map.
            </summary>
            <remarks>When requesting a map, a client may specify the styles to be shown on the map.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterSource.Uri">
            <summary>
            This property specifies the URI of the WMS server.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterSource.IsTransparent">
            <summary>
            This property gets or sets whether the response map image's background color is transparent or not.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterSource.OutputFormat">
            <summary>
            This property gets or sets the desired output format for the map being requested from the WMS.
            </summary>
            <remarks>When requesting a map, a client may specify the output format in which to show the map.
            Formats are specified as MIME types such as "image/gif" or "image/png".
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterSource.Proxy">
            <summary>
            This property gets or sets the proxy used for requesting a Web Response.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterSource.TimeoutInSecond">
            <summary>
            This property specifies the timeout of the web request in seconds.  The default timeout value is 20 seconds.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterSource.Crs">
            <summary>
            This property gets or sets the projected or geographic coordinate reference system to be used.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterSource.Credentials">
            <summary>
            This property gets or sets the base authentication interface for retrieving credentials for Web Client authentication.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterSource.Exceptions">
            <summary>
            This property indicates the format in which the client wishes to be notified of
            service exceptions.
            </summary>
            <remarks>
            Upon receiving a request that is invalid according to the OGC standard, the
            server shall issue a service exception report. The service report is meant to describe
            to the client application or its human user the reason(s) that the request is
            invalid.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterSource.Parameters">
            <summary>
            This property specifies a dictionary used to update the request sent from the client to
            the WMS server.
            </summary>
            <example>
            	<code lang="CS" title="C# sample" description="This example shows how to add a customized parameter to update the request URI sent from the client to the WMS server.">
            		<![CDATA[
            WmsRasterSource target = new WmsRasterSource(new Uri(localWmsServer));
            target.Parameters.Add("ParameterKey", "ParameterValue");]]>
            	</code>
            	<code lang="VB" title="VB sample" description="This example shows how to update the request URI sent from the client to the WMS server by adding a customized parameter.">
            		<![CDATA[
            Dim target As New WmsRasterSource(New Uri(localWmsServer)) 
            target.Parameters.Add("ParameterKey", "ParameterValue")]]>
            	</code>
            </example>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.#ctor(System.Uri,System.Net.WebProxy)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <remarks>This constructor initializes a new WorldMapKitWmsRasterSource and downloads and parses the service description.</remarks>
            <param name="uri">URI of the WMS server.</param>
            <param name="webProxy">Proxy to use for the current WMS layer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.GetServerLayerNames">
            <summary>This method returns the names of all layers at the server side.</summary>
            <returns>The names of all layers at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.GetServerStyleNames">
            <summary>This method returns the names of all styles at the server side.</summary>
            <returns>The names of all styles at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.GetServerOutputFormats">
            <summary>This method returns the output format at the server side.</summary>
            <returns>The output format at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.GetServerCrss">
            <summary>
            This method returns the projected or geographic coordinate reference systems to be used.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.GetServerExceptionFormats">
            <summary>This method returns the exception format at the server side.</summary>
            <returns>The exception format at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.GetServiceVersion">
            <summary>
            This API gets the WMS server version of the service.
            </summary>
            <returns>Returns a string reflecting the version of the service in WMS.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.GetRequestUrl(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <summary>
            Get the request URLs from the client to the WMS servers.
            </summary>
            <param name="worldExtent">The world extent requested by the client to get the map.</param>
            <param name="canvasWidth">The returning map width, as well as the drawing canvas width.</param>
            <param name="canvasHeight">The returning map height, as well as the drawing canvas height.</param>
            <returns>The request URLs from the client to the WMS servers.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.GetImageCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <remarks>
            This method is responsible for returning the image based on the parameters passed
            in.
            </remarks>
            <summary>
            This method returns an image based on the worldExtent and image width and
            height.
            </summary>
            <returns>
            This method returns an image based on the worldExtent and image width and
            height.
            </returns>
            <param name="worldExtent">This parameter represents the worldExtent you want to draw.</param>
            <param name="canvasWidth">This parameter represents the width of the image you want to draw.</param>
            <param name="canvasHeight">This parameter represents the height of the image you want to draw.</param>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.SendingTile">
            <summary>
            This event is called before sending the reqeust for tile image.
            </summary>
            <remarks>
            This event is called before sending the reqeust for tile image.<br/>
            It is typical that user want to get the url of reqeust and modify it according to their requirements. 
            For example, user could create a signiture for it, and verify it on the server side.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.SentTile">
            <summary>
            This event is called after sent the request for the tile image and the HttpWebResponse has come back.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.ServerUri">
            <summary>
            This property specifies the URI of the Tiled WMS server.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.ClientId">
            <summary>
            Gets or sets a value that is unique to your client ID, please keep your key secure.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.PrivateKey">
            <summary>
            Gets or sets a value that is unique to your client ID, please keep your key secure.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.Proxy">
            <summary>
            This property gets or sets the proxy used for requesting a Web Response.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.ActiveLayerNames">
            <summary>
            This property allows the active layers requested from the client to be shown on the map.
            </summary>
            <remarks>When requesting a map, a client may specify the layers to be shown on the map.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.ActiveStyleNames">
            <summary>
            This property allows the active styles requested from the client to be shown on the map.
            </summary>
            <remarks>When requesting a map, a client may specify the styles to be shown on the map.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.TimeoutInSeconds">
            <summary>
            This property specifies the timeout of the web request in seconds.  The default timeout value is 20 seconds.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.OutputFormat">
            <summary>
            This property gets or sets the desired output format for the map being requested from the WMS.
            </summary>
            <remarks>When requesting a map, a client may specify the output format in which to show the map.
            Formats are specified as MIME types such as "image/gif" or "image/png".
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.Exceptions">
            <summary>
            This property indicates the format in which the client wishes to be notified of
            service exceptions.
            </summary>
            <remarks>
            Upon receiving a request that is invalid according to the OGC standard, the
            server shall issue a service exception report. The service report is meant to describe
            to the client application or its human user the reason(s) that the request is
            invalid.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.Crs">
            <summary>
            This property gets or sets the projected or geographic coordinate reference system to be used.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.WebProxy">
            <summary>
            This property gets or sets the proxy used for requesting a Web Response.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsRasterSource.Parameters">
            <summary>
            This property specifies a dictionary used to update the request sent from the client to
            the WMS server.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ReturningColumnsType">
            <summary>This enumeration provides some options when querying a feature.</summary>
            <remarks>
                Three options are provided in the query system that can cover all possible
                cases. Option 1 is to use the ReturningColumnsType.NoColumns, which will return no columns at 
                all. Option 2 is to use the ReturningColumnsType.AllColumns, which will return all columns. Option 3
                is used when you want to return parts of the columns in the feature; in this case you should pass in an 
                (IEnumerable[string] returningColumnNames) instead of using this enumeration directly.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ReturningColumnsType.NoColumns">
            <summary>
            Return no column option.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ReturningColumnsType.AllColumns">
            <summary>
            Return all columns option.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RequestingDataWfsFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the RequestingData event in WfsFeatureSource.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RequestingDataWfsFeatureSourceEventArgs.#ctor">
            <summary>This is a default constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RequestingDataWfsFeatureSourceEventArgs.#ctor(System.String,System.Boolean,System.String)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="serviceUrl">This parameter specified the serviceUrl for the WfsFeatureSource.</param>
            <param name="overrideResponse">This parameter specified if we need to override Response if we changed the response string.</param>
            <param name="xmlResponse">This parameter specified the xmlResponse string get back from the service Url.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RequestingDataWfsFeatureSourceEventArgs.ServiceUrl">
            <summary>
            This property gets or sets the serviceUrl for the WfsFeatureSource.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RequestingDataWfsFeatureSourceEventArgs.OverrideResponse">
            <summary>
            This property gets or sets the override mode. If set it ture, we will replace the response with new 
            XmlResponse String passed in.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RequestingDataWfsFeatureSourceEventArgs.XmlResponse">
            <summary>
            This property gets or sets the xml response string back from for the WfsFeatureSource service url.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Proj._InitProj(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            According to Proj list set the value of Proj
            </summary>
            <param name="projID">ID value of proj object</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Proj.ProjObj">
            <summary>
            Obtain Proj object of corresponding ID
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PjEllp">
            <summary>
            set ellipsoid
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PjEllp._InitEllps(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Int32@)">
            <summary>
            According to the ellps list to1986520wyq
            198set the value of ellps
            </summary>
            <param name="ellpsID">ID value of ellps object</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DataConst">
            <summary>
            definition of DataConst static class
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ManagedProj4Projection">
            <summary>
            This projection class uses the Proj4 engine to project data from one Srid to
            another.
            </summary>
            <remarks>
            This projection class uses the Proj4 engine to project data from one Srid to
            another. Proj4 is a very popular projection library the support thousands for
            projections. It uses a special text format to feed in parameters about the to and from
            projection. Though it uses its own format many organizations have recognized it and
            provide their projection definition in this format. Within this class we support the
            latest EPSG (European Petroleum Survey Group) SRID (Spatial Reference System
            Identifiers) list. You can find more information about these on the web. The SRID list
            is very popular and we include a text version with in our install.<br/>
            	<br/>
            Note that one thing that confuses people is that when they go to or from latitude and
            longitude they do not know what SRID to use. The proper SRID is 4326 for WGS84 pair
            coordinates in degrees with Greenwich as the central meridian.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.#ctor">
            <summary>
            This is the default constructor for this class.
            </summary>
            <remarks>This conctructor pass nothing. After this cconstructor , you should 
            set the InternalProjectionParametersString property and ExternalProjectionParametersString 
            property before open to use.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in Proj4 text parameters for the to and from
            projection. The parameters typically look like "+proj=longlat +ellps=WGS84 +datum=WGS84
            +no_defs"
            </overloads>
            <returns>None</returns>
            <remarks>
            This constructor allows you to pass in Proj4 text parameters for the to and from
            projection. The parameters typically look like "+proj=longlat +ellps=WGS84 +datum=WGS84
            +no_defs" You should use this constructor when you know the parameters. If you know the
            SRID directly you can use the other constructor that takes the SRID.
            </remarks>
            <param name="internalProjectionParametersString">This parameter is the projection parameters describing the data.</param>
            <param name="externalProjectionParametersString">
            This parameter is the projection parameters describing the projection you want to
            go to.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.OpenCore">
            <returns>None</returns>
            <remarks>
            As this is the core version of the Open method it is intended to be overridden in
            inherited version of the class. When overriding you will be responsible for getting the
            projection classes state ready for doing projections.<br/>
            	<br/>
            In this override we call the Proj4 methods get it ready for projection.
            </remarks>
            <summary>This method open the projection and gets it ready to use.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.CloseCore">
            <summary>
            This method closes the projection and gets it ready to serialization if
            necessary.
            </summary>
            <returns>None</returns>
            <remarks>
            As this is the core version of the Close method it is intended to be overridden
            in inherited version of the class. When overriding you will be responsible freeing any
            state you have maintained and getting the class ready to serialization if necessary.
            Note that the object may be opened again so you want to make sure you can open and
            close the object multiple tiles without any ill effects.<br/>
            	<br/>
            In this override we call the Proj4 methods get release the handles and memory.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.ConvertToExternalProjectionCore(System.Double[],System.Double[])">
            <summary>This method returns a projected vertex based on the coordinates passed in.</summary>
            <returns>
            This method returns a projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically you can call the
            projection utility library that has interfaces for dozens of different types of
            projections.
            </remarks>
            <param name="x">This parameter is the X values of the points that will be projected.</param>
            <param name="y">This parameter is the Y values of the points that will be projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.ConvertToInternalProjectionCore(System.Double[],System.Double[])">
            <summary>
            This method returns a de-projected vertex based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns a de-projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a de-projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically you can call the
            projection utility library that has interfaces for dozens of different types of
            projections. The de-projection is important because inside of the FeatureSource you
            will in many cases to to and from various projections.
            </remarks>
            <param name="x">This parameter is the X values of the points that will be de-projected.</param>
            <param name="y">This parameter is the Y values of the points that will be de-projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.GetEpsgParameters(System.Int32)">
            <summary>
            This method is a static API to get a projection text from EPSG(European Petroleum Survey Group).
            </summary>
            <remarks>More information about it can reference to EPSG.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.GetEsriParameters(System.Int32)">
            <summary>
            This method is a static API to get a projection text from ERSI.
            </summary>
            <remarks>More information about it can reference to ERSI.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.GetEsriExtraParameters(System.Int32)">
            <summary>
            This method is a static API to get a projection text from ERSI Extra projections.
            </summary>
            <remarks>More information about it can reference to ESRI.extra.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.GetGL27Parameters(System.Int32)">
            <summary>
            This method is a static API to get a projection text from GL27 Extra projections.
            </summary>
            <remarks>More information about it can reference to GL27.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.GetNad27Parameters(System.Int32)">
            <summary>
            This method is a static API to get a projection text from Nad27 Extra projections.
            </summary>
            <remarks>More information about it can reference to Nad27.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.GetNad83Parameters(System.Int32)">
            <summary>
            This method is a static API to get a projection text from Nad83 Extra projections.
            </summary>
            <remarks>More information about it can reference to Nad83.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.GetOtherExtraParameters(System.Int32)">
            <summary>
            This method is a static API to get a projection text from other projections except EPSG
            ,ERSI, ERSIExtra,GL27,NAD27,NAD83,World.
            </summary>
            <remarks>More information about it can reference to Other.extra.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.GetWorldParameters(System.Int32)">
            <summary>
            This method is a static API to get a projection text from World projections.
            </summary>
            <remarks>More information about it can reference to World.rtf in the documentation.</remarks>
            <param name="srid">The target Srid infromation to get the projection text from.</param>
            <returns>The project text corresponding to the srid.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.GetGoogleMapParameters">
            <summary>
            This method is a static API to get a projection used by GoogleMap.
            </summary>
            <returns>A text for a projection used by GoogleMap , it should like this "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.GetBingMapParameter">
            <summary>
            This method is a static API to get a projection used by BingMaps.
            </summary>
            <returns>A text for a projection used by BingMaps , it should like this "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.GetSphericalMercatorParameter">
            <summary>
            This method is a static API to get a projection of SphericalMercator.
            </summary>
            <returns>A text for a SphericalMercator projection, it should like this "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ManagedProj4Projection.GetVirtualEarthParameters">
            <summary>
            This method is a static API to get a projection used by Virtual Earth.
            </summary>
            <returns>A text for a projection used by Virtual Earth , it should like this "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ManagedProj4Projection.DecimalDegreeBoundary">
            <summary>This property specifies the Boundary for decimaldegree values.</summary>
            <remarks>
            	<para>The default boundary is(-179.9, 89.9, 179.9, -89.9). That means when I want
                to project a PointShape(-179,91,89.91) out, in fact what it projects is
                (-179.9,89.9) because of its out of boundary.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ManagedProj4Projection.InternalProjectionParameters">
            <summary>
            Gets or sets the Proj4 text parameter for the from projection. This parameter
            typically look like "+Proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs".
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ManagedProj4Projection.ExternalProjectionParameters">
            <summary>
            Gets or sets the Proj4 text parameter for the to projection. This parameter
            typically look like "+proj=utm +zone=33 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs".
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ManagedProj4Projection.CanReproject">
            <summary>
            This property indicates whether this projection should be used.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Tile">
            <summary>
            	<para>This is the base class which describle the Tile class. Tile concept is used
                as a rectangle image which will be saved in Memory or Hard disk to enhance the
                performance.</para>
            	<para></para>
            	<para>The Tile cache system is very popular in many GIS products including the
                GoogleMaps, VE Maps etc, the Tile can be considered a small subset used in the
                TileCache system.</para>
            </summary>
            <remarks>
            The Tile is the lowest level Tile in the Tile hierarchy. Directly
            inherited from Tile are BitmapTile, NativeImageTile. The methods and
            properties on Tile are the lowest common denominator for all the various kinds of
            Tiles. It marked abstract and is designed only to be inherited from.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Tile.#ctor">
            <summary>
            This is the default constructor for Tile.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Tile.#ctor(ThinkGeo.MapSuite.Core.RectangleShape,System.Double)">
            <summary>
            This is the  constructor for Tile by passing the boundingBox and scale.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Tile.CloneDeep">
            <summary>This method shows the way to deep clone a Tile object.</summary>
            <returns>This method returns the cloned Tile object.</returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, In this way, we
            leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about
            this,please contact our support team as we would be happy to work with you on extending
            our framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Tile.CloneDeepCore">
            <summary>This method shows the way to override deep clone a Tile object.</summary>
            <returns>This method returns the cloned Tile object.</returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, In this way, we
            leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about
            this,please contact our support team as we would be happy to work with you on extending
            our framework.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Tile.Scale">
            <summary>The scale to describe the Tile.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Tile.BoundingBox">
            <summary>The Bounding box to describe the Tile.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.TextStyle">
            <summary>This class is used to label features on the map.</summary>
            <remarks>
            The text style is used for labeling things on the map. There are a great number
            of properties that give you a lot of control over how things are labeled. At the core,
            you need to set the font you want to use to label, the TextSolidBrush to define the
            color and look of the text, and the TextColumnName you want to use for the text to
            draw. Each of the additional properties can be reviewed in the help or samples.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyle.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor for the class. If you use this constructor, you
            should set the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, you should set the required properties
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyle.#ctor(System.String,ThinkGeo.MapSuite.Core.GeoFont,ThinkGeo.MapSuite.Core.GeoSolidBrush)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <overloads>
            This constructor allows you to pass in the minimum required fields for labeling.
            You may want to explore the other properties to control how your labels look.
            </overloads>
            <remarks>
            This constructor allows you to pass in the minimum required fields for labeling.
            You may want to explore the other properties to control how your labels look.
            </remarks>
            <param name="textColumnName">This parameter is the name of the column that contains the text you want to draw.</param>
            <param name="textFont">This parameter is the font used to draw the text.</param>
            <param name="textSolidBrush">This parameter is the TextSolidBrush used to draw the text.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyle.DrawSampleCore(ThinkGeo.MapSuite.Core.GeoCanvas)">
            <summary>This method draws a sample feature on the canvas you provided.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. In this
            method, we draw a sample style on the canvas you provided. This is typically used to
            display a legend or other sample area.<br/>
            	<br/>
            	<br/>
            	<br/>
            When implementing this virtual method, consider the canvas size and draw the sample
            image appropriately. You should keep in mind that the sample typically shows up on a
            legend.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.XOffsetInPixel">
            <summary>This property gets and sets the X pixel offset for drawing each feature.</summary>
            <value>This property gets the X pixel offset for drawing each feature.</value>
            <remarks>
            This property allows you to specify an X offset. When combined with a Y offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.YOffsetInPixel">
            <summary>This property gets and sets the Y pixel offset for drawing each feature.</summary>
            <value>This property gets the Y pixel offset for drawing each feature.</value>
            <remarks>
            This property allows you to specify a Y offset. When combined with an X offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.GridSize">
            <summary>
            This property gets and sets the grid size used for deterministic
            labeling.
            </summary>
            <value>This property gets the grid size used for deterministic labeling.</value>
            <remarks>
            The grid size determines how many labels will be considered as candidates for drawing. The
            smaller the grid size, the higher the density of candidates. Making the grid size too small
            may have a performance impact.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.FittingLineInScreen">
            <summary>
            This property gets and sets whether the labeler will try to fit the label as best as it
            can on the visible part of a line on the screen.
            </summary>
            <value>
            This property gets whether the labeler will try to fit the label as best as it can on
            the visible part of a line on the screen.         
            </value>
            <remarks>
            A label will normally be displayed in the center of a line. If only a small piece
            of the line is visible on the screen, we cannot see it's label by default. If we set this
            property to ture though, the label will be displayed in the center of that piece in screen.
             </remarks> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.CustomTextStyles">
            <summary>
            This property returns a collection of area styles allowing you to stack multiple
            area styles on top of each other.
            </summary>
            <value>This property returns a collection of area styles.</value>
            <remarks>
            Using this collection, you can stack multiple area styles on top of each other.
            When we draw the features, we will draw them in order that they exist in the collection. You can use
            these stacks to create drop shadow effects, multiple colored outlines,
            etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.RotationAngle">
            <summary>
            This property gets and sets the rotation angle of the item being
            positioned.
            </summary>
            <value>This property gets the rotation angle of the item being positioned.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.Format">
            <summary>This property gets and sets the format that will be applied to the text.</summary>
            <value>This property gets the format that will be applied to the text.</value>
            <remarks>
            With this property, you can apply formats to the text that is retrieved from the
            feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.TextFormat">
            <summary>This property gets and sets the format that will be applied to the text.</summary>
            <value>This property gets the format that will be applied to the text.</value>
            <remarks>
            With this property, you can apply formats to the text that is retrieved from the
            feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.NumericFormat">
            <summary>This property gets and sets the format that will be applied to the text which can be parsed to double type.</summary>
            <value>This property gets the format that will be applied to the text which can be parsed to double type..</value>
            <remarks>
            With this property, you can apply formats to the text that is retrieved from the
            feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.DateFormat">
            <summary>This property gets and sets the format that will be applied to the text which can be parsed to DateTime type.</summary>
            <value>This property gets the format that will be applied to the text which can be parsed to DateTime type..</value>
            <remarks>
            With this property, you can apply formats to the text that is retrieved from the
            feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.TextSolidBrush">
            <summary>
            This property gets and sets the SolidBrush that will be used to draw the
            text.
            </summary>
            <value>This property gets the SolidBrush that will be used to draw the text.</value>
            <remarks>
            You can use this property to draw a solid color; however, if you need to use other
            brushes, you can access them through the Advanced property of this class.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.Font">
            <summary>This property gets and sets the font that will be used to draw the text.</summary>
            <value>This property gets the font that will be used to draw the text.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.HaloPen">
            <summary>
            This property gets and sets the halo pen you may use to draw a halo around the
            text.
            </summary>
            <value>
            This property gets the halo pen you may use to draw a halo around the
            text.
            </value>
            <remarks>
            The halo pen allows you to draw a halo effect around the text, making it stand out
            more on a busy background.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.TextColumnName">
            <summary>
            This property gets and sets the column name in the data that you want to get the text from.
            </summary>
            <value>
            This property gets the column name in the data that you want to get the text from.
            </value>
            <remarks>
            This property is used when retrieving text from a feature. You will want to
            specify the name of the column that contains the text you want to draw.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.Mask">
            <summary>
            This property gets and sets the AreaStyle used to draw a mask behind the
            text.
            </summary>
            <value>This property gets the AreaStyle used to draw a mask behind the text.</value>
            <remarks>
            A mask is a plate behind the text that is rectangular and slightly larger than
            the width and height of the text. It allows the label to stand out well on a busy
            background. You can also try the HaloPen property instead of the mask, if the mask effect is
            too pronounced.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.MaskMargin">
            <summary>This property gets and sets the margin around the text that will be used for the mask.</summary>
            <value>This property gets the margin around the text that will be used for the mask.</value>
            <remarks>This determines how much larger the mask is than the text, in pixels.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.Advanced">
            <summary>This property gets the advanced properties of the class.</summary>
            <value>This property gets the advanced properties of the class.</value>
            <remarks>
            The advanced properties have been consolidated in the Advanced property. This way,
            the standard options are more easily visible and the advanced options are hidden
            away.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.DuplicateRule">
            <summary>
            This property gets and sets the rule that determines how duplicate labels are
            handled.
            </summary>
            <value>
            This property gets the rule that determines how duplicate labels are
            handled.
            </value>
            <remarks>
            There are three ways to handle duplicate label names. The first is to suppress
            all duplicates, which means if there are two street segments with the same name then
            only one will be drawn. The second way is to suppress duplicate labels only if they are
            in one quarter of the screen. In this way, the screen will be divided into four
            quadrants, and if the two duplicate labels are in different quadrants, then they will both
            draw. The last way is to draw all duplicates.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.OverlappingRule">
            <summary>
            This property gets and sets the rule that determines how overlapping labels are
            handled.
            </summary>
            <value>This property gets the rule that determines overlapping labels are handled.</value>
            <remarks>
            This defines the rules for label overlapping. Currently, either we allow overlapping or we
            do not. In the future, we may extend this to allow some percentage of partial
            overlapping.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.AllowSpline">
            <summary>
            This property gets and sets whether line labels are allowed to spline around curved
            lines.
            </summary>
            <value>
            This property gets whether line labels are allowed to spline around curved
            lines.
            </value>
            <remarks>
            This property will allow the labeler to spline the label around curved lines.
            This is useful for curved streets that need to be labeled. This can have a considerable
            performance impact, so we suggest you experiment with it to ensure it can meet your
            needs.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.AllowLineCarriage">
            <summary>
            This property gets and sets whether the labeler will allow carriage returns to be
            inserted.
            </summary>
            <value>
            This property gets whether the labeler will allow carriage returns to be
            inserted.
            </value>
            <remarks>
            This property enables the labeler to split long labels into multiple lines if need be.
            For instance, if you have a lake whose name is "Southern Homestead Lake," then the labeler
            may try and break the name onto multiple lines in order to better label the feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.ForceLineCarriage">
            <remarks>
            This property forces the labeler to split long labels into multiple lines. For instance,
            if you have a lake whose name is "Southern Homestead Lake," then the labeler will break
            the name onto multiple lines in order to better label the feature.
            </remarks>
            <summary>
            This property gets and sets whether the labeler will force carriage returns to be
            inserted.
            </summary>
            <value>
            This property gets whether the labeler will force carriage returns to be
            inserted.
            </value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.FittingPolygon">
            <summary>
            This property gets and sets whether the labeler will try to fit the label as best as
            it can within the boundary of a polygon.
            </summary>
            <value>
            This property gets whether the labeler will try to fit the label as best as
            it can within the boundary of a polygon.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.LabelAllPolygonParts">
            <summary>
            This property gets and sets whether the labeler will label every part of a multi-part
            polygon.
            </summary>
            <value>
            This property gets whether the labeler will label every part of a multi-part
            polygon.
            </value>
            <remarks>
            In some cases, you may want to label all of the parts of a multi-part polygon, while in
            other cases you may not. For example, you may have a series of lakes where you do want to
            label each polygon. In another case, you may have a country with many small islands and
            in this case you only want to label the largest polygon.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.ForceHorizontalLabelForLine">
            <summary>This property gets and sets whether we should force horizontal labeling for lines.</summary>
            <value>This property gets whether we should force horizontal labeling for lines.</value>
            <remarks>
            Normally, lines are labeled in the direction of the line. There may be some cases,
            however, when you want to have the line labeled horizontally regardless of the line's direction.
            In such a case, you can set this property to force the lines to be labeled horizontally.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.FittingPolygonFactor">
            <summary>
            This property gets and sets the factor to which it will keep the label inside of
            the polygon.
            </summary>
            <value>
            This property gets the factor to which it will keep the label inside of the
            polygon.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.SuppressPartialLabels">
            <summary>
            This property gets and sets whether a partial label in the current extent will be drawn or not.
            </summary>
            <remarks>This property provides a solution to the "cut off" label issue in Map Suite Web Edition and Desktop Edition, which occurs when multiple
            tiles exist. When you set this property to true, any labels outside of the current extent will not be drawn.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.TextLineSegmentRatio">
            <summary>
            This property gets and sets the ratio required for the label length to match the
            line length.
            </summary>
            <value>
            This property gets the ratio required for the label length to match the line
            length.
            </value>
            <remarks>
            This allows you to suppress labels where the label length would greatly exceed
            the line length. For example, if you set the ratio to 1, then the label will be
            suppressed if it is longer than the line. If the ratio is lower, then the label would
            need to be shorter than the line. If higher, then the label is allowed to run past the
            length of the line. This allows you to control the look of things like road labeling.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.BestPlacement">
            <summary>
            This property gets and sets whether the labeler will attempt to change the label
            position to avoid overlapping for point-based features.
            </summary>
            <value>
            This property gets whether the labeler will attempt to change the label position to
            avoid overlapping for point-based features.
            </value>
            <remarks>
            The positioning of point labels is mainly determined by the PointPlacement
            property. This allows you place the text to the right, top, bottom, etc. of the point. In
            some cases, placing the text in a certain place will cause many labels to be suppressed
            when the points are dense. This property allows you to override the PointPlacement
            property and allow the labeler to try other locations, if the default location would
            cause the label to be suppressed.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.PointPlacement">
            <summary>
            This property gets and sets the location of the label for point features relative
            to the point.
            </summary>
            <value>
            This property gets the location of the label for point features relative to the
            point.
            </value>
            <remarks>
            This property allows you to choose where the labels are created relative to the
            point. For example, you can set the property to RightCenter, which would ensure that all
            labels are placed to the right of and vertically centered with the point. Different kinds of point layers
            can be positioned differently. If the point layer is dense and position is not a main
            concern, then you can try the BestPlacement property. That property overrides this
            property and tries to fit the label in the best location so that the minimum number of
            labels are suppressed due to overlapping issues.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.SplineType">
            <summary>
            Gets or sets the SplineType for labeling.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.DrawingLevel">
            <summary>
            Gets or sets the DrawingLavel for this style.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyle.LabelPositions">
            <summary>
            Gets a value represents a keyValuepair which is a feature id and label position of the feature
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.BreakValueInclusion">
            <summary>
            In a class break style, this enumeration determines whether the break includes
            or excludes the value entered in the break.
            </summary>
            <remarks>
            In a class break style, this enumeration determines whether the break includes
            or excludes the value entered in the break. For example, you might have two class breaks,
            one at 100 and the second at 200. If you specify to include the value, then the first break
            includes the number 100 and the second break would include the number 200. If you set
            to exclude, then 100 would belong to the second break and 200 would not be included in
            the second break at all.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.BreakValueInclusion.IncludeValue">
            <summary>The break value is included in the break.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.BreakValueInclusion.ExcludeValue">
            <summary>The break value is not included in the break.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MultilineShape">
            <summary>
            This class represents a MultilineShape, which is defined as one or more lines, each with two or
            more points.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.#ctor">
            <overloads>This overload creates the MultilineShape without any points.</overloads>
            <summary>This constructor creates the MultilineShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.LineShape})">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in any lineShapes which are invalid, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the lineShapes, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the MultilineShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates the MultilineShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and the copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.Reorder(ThinkGeo.MapSuite.Core.PointShape,System.Double)">
            <summary>This API is used to make the lines within the Multiline ordered.</summary>
            <remarks>
            An ordered Multiline means that we can walk though the MultiLine from the first
            point to the last point without any branches, and that each line's end points should be
            within the given tolerance. If using this overload, the unit of the Multiline and the
            tolerance are both defaulted to meters.  Please use the other overload if you want to
            specify the units yourself.
            </remarks>
            <returns>Returns a re-ordered MultilineShape.</returns>
            <param name="startPoint">
            This parameter specifies the start point of the resulting re-ordered
            MultilineShape.
            </param>
            <param name="tolerance">
            This parameter specifies the tolerance between each line among the lines in the
            Multiline. This parameter is very critial.  If it is too large or too samll, the
            re-order cannot suceed.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.Reorder(ThinkGeo.MapSuite.Core.PointShape,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This API is used to make the lines within the Multiline ordered.</summary>
            <remarks>
            An ordered Multiline means that we can walk though the MultiLine from the first
            point to the last point without any branches, and that each line's end points should be
            within the given tolerance. When using this overload, you can specify the unit for the
            Multiline as well as the unit for the tolerance.
            </remarks>
            <returns>Returns a re-ordered MultilineShape.</returns>
            <param name="startPoint">
            This parameter specifies the start point of the resulting re-ordered
            MultilineShape.
            </param>
            <param name="tolerance">
            This parameter specifies the tolerance between each line among the lines in the
            Multiline. This parameter is very critial.  If it is too large or too samll, the
            re-order cannot suceed.
            </param>
            <param name="shapeUnit">This parameter specifies the GeographicUnit for the Multineline.</param>
            <param name="unitOfTolerance">This parameter specifies the distance unit used when considering the tolerance.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.ReorderCore(ThinkGeo.MapSuite.Core.PointShape,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This API is used to make the lines within the Multiline ordered.</summary>
            <remarks>
            An ordered Multiline means that we can walk though the MultiLine from the first
            point to the last point without any branches, and that each line's end points should be
            within the given tolerance. When using this overload, you can specify the unit for the
            Multiline as well as the unit for the tolerance.
            </remarks>
            <returns>Returns a re-ordered MultilineShape.</returns>
            <param name="startPoint">
            This parameter specifies the start point of the resulting re-ordered
            MultilineShape.
            </param>
            <param name="tolerance">
            This parameter specifies the tolerance between each line among the lines in the
            Multiline. This parameter is very critial.  If it is too large or too samll, the
            re-order cannot suceed.
            </param>
            <param name="shapeUnit">This parameter specifies the GeographicUnit for the Multineline.</param>
            <param name="unitOfTolerance">This parameter specifies the distance unit used when considering the tolerance.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetLengthCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This method returns the length of the LineShape.</summary>
            <overloads>This overload returns the length in the GeographyUnit of the shape.</overloads>
            <returns>The returned length is in the GeographyUnit of the shape.</returns>
            <remarks>
            This method is useful when you want to know the total length of a line-based
            shape. If the shape is a MultilineShape, then the length is the sum of all of its lines.
            There is also an overload which allows you to specify the returning length in the unit
            of your choice.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your returningUnit, then the distance will be
            returned in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetPointOnALine(ThinkGeo.MapSuite.Core.StartingPoint,System.Single)">
            <summary>
            	<para>This method returns a PointShape on the line, based on a percentage of the
                length of the line from either its first or last vertex (as defined by the startingPoint
                parameter).</para>
            </summary>
            <returns>
            	<para>This method returns a PointShape on the line, based on a percentage of the
                length of the line from either its first or last vertex (as defined by the startingPoint
                parameter).</para>
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<para>If you pass 100 or 0 as the percentage of the line, it will return either the
                first or last vertex, depending on the value of the startingPoint argument.</para>
            </remarks>
            <overloads>
            This overload allows you to pass a percentage determining how far you want to
            move along the line, as well as whether to start from the beginning or the end
            of the line.
            </overloads>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="percentageOfLine">
            This parameter defines the percentage into the line. Valid values are between 0
            and 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetPointOnALineCore(ThinkGeo.MapSuite.Core.StartingPoint,System.Single)">
            <summary>
            	<para>This method returns a PointShape on the line, based on a percentage of the
                length of the line from the first or last vertex (as defined by the startingPoint
                parameter).</para>
            </summary>
            <returns>
            	<para>This method returns a PointShape on the line, based on a percentage of the
                length of the line from the first or last vertex (as defined by the startingPoint
                parameter).</para>
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<para>If you pass 100 or 0 as the percentage of the line, it will return either the
                first or last vertex, depending on the value of the startingPoint argument.</para>
            </remarks>
            <overloads>
            This overload allows you to pass a percentage determining how far you want to
            move along the line, as well as whether to start from the beginning or the end
            of the line.
            </overloads>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="percentageOfLine">
            This parameter defines the percentage into the line. Valid values are between 0
            and 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetPointOnALine(ThinkGeo.MapSuite.Core.StartingPoint,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex (as defined by the startingPoint parameter).</para>
            </summary>
            <overloads>
            This overload allows you to pass in a distance, which determines how far you want to move
            along the line.  You can also choose whether to start from the beginning or the end of
            the line.
            </overloads>
            <returns>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex (as defined by the startingPoint parameter).</para>
            </returns>
            <remarks>
            	<para>Passing in a distance of 0 will return either the first or last point on the
                line, depending on the value of the startingPoint parameter.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="distance">
            This parameter specifies the distance into the line you wish to move, in the unit
            of the shape itself. Valid values must be greater than or equal to 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetPointOnALineCore(ThinkGeo.MapSuite.Core.StartingPoint,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex (as defined by the startingPoint parameter).</para>
            </summary>
            <overloads>
            This overload allows you to pass in a distance, which determines how far you want to move
            along the line.  You can also choose whether to start from the beginning or the end of
            the line.
            </overloads>
            <returns>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex (as defined by the startingPoint parameter).</para>
            </returns>
            <remarks>
            	<para>Passing in a distance of 0 will return either the first or last point on the
                line, depending on the value of the startingPoint parameter.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="distance">
            This parameter specifies the distance into the line you wish to move, in the unit
            of the shape itself. Valid values must be greater than or equal to 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetLineOnALine(ThinkGeo.MapSuite.Core.StartingPoint,System.Single,System.Single)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass the starting point, starting percentage of the
            line and percentage of the line.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not greater than 0 and less than or equal to 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="startingPercentageOfTheLine">
            This parameter defines the starting percentage into the line. Valid values must be greater
            than 0 and less than or equal to 100.
            </param>
            <param name="percentageOfTheLine">
            This parameter defines the percentage into the line. Valid values must be greater
            than 0 and less than or equal to 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetLineOnALine(ThinkGeo.MapSuite.Core.StartingPoint,System.Single)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass the starting point and percentage of the
            line.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not greater than 0 and less than or equal to 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="percentageOfLine">
            This parameter defines the percentage into the line. Valid values must be greater
            than 0 and less than or equal to 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetLineOnALineCore(ThinkGeo.MapSuite.Core.StartingPoint,System.Single)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass the starting point and percentage of the
            line.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not greater than 0 and less than or equal to 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="percentageOfLine">
            This parameter defines the percentage into the line. Valid values must be greater
            than 0 and less than or equal to 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetLineOnALine(ThinkGeo.MapSuite.Core.StartingPoint,System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to specify the starting point along with the starting
            distance. This allows you to get a certain distance of the line after the starting
            distance.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid startingDistance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="startingDistance">
            The starting distance from where you will start getting the line. For example, if
            the line is 3 units long and you have a starting distance of 1 unit, the result will
            be the last two units of the line. Valid values must be greater than 0. The starting
            distance will be in the GeographyUnit of the shape.
            </param>
            <param name="distance">
            The amount of the line you want to get after the startingDistance. Valid values
            must be greater than 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetLineOnALineCore(ThinkGeo.MapSuite.Core.StartingPoint,System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to specify the starting point along with the starting
            distance. This allows you to get a certain distance of the line after the starting
            distance.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid startingDistance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="startingDistance">
            The starting distance from where you will start getting the line. For example, if
            the line is 3 units long and you have a starting distance of 1 unit, the result will
            be the last two units of the line. Valid values must be greater than 0. The starting
            distance will be in the GeographyUnit of the shape.
            </param>
            <param name="distance">
            The amount of the line you want to get after the startingDistance. Valid values
            must be greater than 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetLineOnALine(ThinkGeo.MapSuite.Core.StartingPoint,ThinkGeo.MapSuite.Core.PointShape)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to specify the starting point and another point.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null endPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="endPointShape">
            The BaseLineShape returned will be between the startingPoint and the endPointShape
            specified in this parameter.
            </param>       
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetLineOnALine(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass in two points to get a BaseLineShape from the original MultilineShape.
            </overloads>
            <returns>
            This method returns a BaseLineShape based on a start PointShape and an end PointShape.        
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null startPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null endPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="startPointShape">
            The startPointShape defines where you will start to get the line. If it does not stand on this 
            MultilineShape, the closest point on the MultilineShape will be the start PointShape.
            </param>
            <param name="endPointShape">
            The endPointShape defines where you will stop getting the line. If it does not stand on this 
            MultilineShape, the closest point on the MultilineShape will be the end PointShape.
            </param>       
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetLineOnALineCore(ThinkGeo.MapSuite.Core.StartingPoint,ThinkGeo.MapSuite.Core.PointShape)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to specify the starting point and another point.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null endPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="endPointShape">
            The BaseLineShape returned will be between the startingPoint and the endPointShape
            specified in this parameter.
            </param>       
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetLineOnALineCore(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass in two points to get a BaseLineShape from the original MultilineShape.
            </overloads>
            <returns>
            This method returns a BaseLineShape based on a start PointShape and an end PointShape.        
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null startPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null endPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="startPointShape">
            The startPointShape defines where you will start to get the line. If it does not stand on this 
            MultilineShape, the closest point on the MultilineShape will be the start PointShape.
            </param>
            <param name="endPointShape">
            The endPointShape defines where you will stop getting the line. If it does not stand on this 
            MultilineShape, the closest point on the MultilineShape will be the end PointShape.
            </param>       
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.RegisterCore(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass the starting point and percentage of the
            line.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not greater than 0 and less than or equal to 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified
            in the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of vertical units of movement in the DistanceUnit specified
            in the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on a
            distance and a direction in degrees.
            </summary>
            <overloads>In this overload, the distance is in the same GeographicUnit as the shape.</overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an
                angleInDegrees and distance parameter. With this overload, it is important to note
                that the distance units are the same GeographicUnit as the shape. For example,
                if your shape is in decimal degrees and you call this method with a distance of 1,
                you're going to move this shape 1 decimal degree in direction of the
                angleInDegrees. In many cases it is more useful to specify the DistanceUnit of movement,
                such as in miles or yards, so for these scenarios there is another overload you may
                want to use instead.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="distance">
            The distance is the number of units to move the shape in the angle specified. The
            distance unit will be the same as the GeographyUnit for the shape. The distance must be
            greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.RotateCore(ThinkGeo.MapSuite.Core.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape by a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetClosestPointToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetDistanceToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <returns>
            This method returns the distance between the current shape and the
            targetShape.
            </returns>
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <remarks>None</remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetWellKnownTextCore">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric shapes.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Core.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe a geometry as a binary array. Well-known
            binary is useful when you want to save a geometry in an efficient format using as little
            space as possible. An alternative to well-known binary is well-known text, which is a
            textual representation of a geometry object. We have methods that work with well-known
            text as well.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies whether the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.ValidateCore(ThinkGeo.MapSuite.Core.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.GetCrossingCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.RemoveVertex(ThinkGeo.MapSuite.Core.Vertex,ThinkGeo.MapSuite.Core.MultilineShape)">
            <summary>
            This method removes the selected vertex from multiline shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of multiline shape, otherwise it will return false and multiline shape will keep the same.</param>
            <param name="multilineShape">The multiline shape will be removed one vertex.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultilineShape.RemoveVertex(ThinkGeo.MapSuite.Core.Vertex)">
            <summary>
            This method removes the selected vertex from multiline shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of multiline shape, otherwise it will return false and multiline shape will keep the same.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultilineShape.Lines">
            <summary>This property is the collection of lines that make up the MultilineShape.</summary>
            <decimalDegreesValue>This property is the collection of lines that make up the MultilineShape.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultilineShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <decimalDegreesValue>This property specifies whether the shape can be rotated.</decimalDegreesValue>
            <remarks>
            If this property returns false and you attempt call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PointType">
            <summary>This enumeration defines how a PointSymbol will be drawn.</summary>
            <remarks>
            Depending on which of the members you choose, there are different properties that
            need to be set on the PointStyle.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointType.Symbol">
            <summary>The point will be drawn using a symbol.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointType.Bitmap">
            <summary>The point will be drawn using a bitmap.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointType.Character">
            <summary>The point will be drawn using a font character.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Conversion">
            <summary>
            This static class provides a conversion method to go to and from different
            units.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Conversion.ConvertMeasureUnits(System.Double,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This method converts from one unit of measure to another.</summary>
            <returns>The return length size, represented in the unit specified in the toUnit parameter.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <overloads>This overload handles length units.</overloads>
            <remarks>None</remarks>
            <param name="amount">The total length size, represented in the unit specified in the fromUnit parameter.</param>
            <param name="fromUnit">The unit of measure for the length in the Amount parameter.</param>
            <param name="toUnit">The unit of measure for the result.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Conversion.ConvertMeasureUnits(System.Double,ThinkGeo.MapSuite.Core.AreaUnit,ThinkGeo.MapSuite.Core.AreaUnit)">
            <summary>This method converts from one unit of measure to another.</summary>
            <returns>The return area size, represented in the unit specified in the toUnit parameter.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <overloads>This overload handles area units.</overloads>
            <remarks>None</remarks>
            <param name="amount">The total area size, represented in the unit specified in the fromUnit parameter.</param>
            <param name="fromUnit">The unit of measure for the area in the Amount parameter.</param>
            <param name="toUnit">The unit of measure for the result.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Conversion.ConvertGeographyUnitToDistanceUnit(ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns a DistanceUnit that has been converted from a GeographyUnit.
            </summary>
            <returns>This method returns a DistanceUnit that has been converted from a GeographyUnit.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a GeographyUnit that is not defined in the enumeration, it will throw an ArgumentOutOfRangeException. </exception>
            <remarks>None</remarks>
            <param name="unit">The GeographyUnit you want to convert.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel">
            <summary>
            This enumeration is used on a ZoomLevel to allow its styles to be applied to
            other zoom levels.
            </summary>
            <remarks>
            This enumeration is used on a ZoomLevel to allow its styles to be applied to
            other zoom levels.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.None">
            <summary>Default; the apply-until-zoom-level feature will not be enabled.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level01">
            <summary>The zoom level's styles will be applied to zoom level 1.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level02">
            <summary>The zoom level's styles will be applied to zoom level 2.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level03">
            <summary>The zoom level's styles will be applied to zoom level 3.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level04">
            <summary>The zoom level's styles will be applied to zoom level 4.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level05">
            <summary>The zoom level's styles will be applied to zoom level 5.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level06">
            <summary>The zoom level's styles will be applied to zoom level 6.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level07">
            <summary>The zoom level's styles will be applied to zoom level 7.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level08">
            <summary>The zoom level's styles will be applied to zoom level 8.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level09">
            <summary>The zoom level's styles will be applied to zoom level 9.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level10">
            <summary>The zoom level's styles will be applied to zoom level 10.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level11">
            <summary>The zoom level's styles will be applied to zoom level 11.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level12">
            <summary>The zoom level's styles will be applied to zoom level 12.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level13">
            <summary>The zoom level's styles will be applied to zoom level 13.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level14">
            <summary>The zoom level's styles will be applied to zoom level 14.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level15">
            <summary>The zoom level's styles will be applied to zoom level 15.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level16">
            <summary>The zoom level's styles will be applied to zoom level 16.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level17">
            <summary>The zoom level's styles will be applied to zoom level 17.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level18">
            <summary>The zoom level's styles will be applied to zoom level 18.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level19">
            <summary>The zoom level's styles will be applied to zoom level 19.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ApplyUntilZoomLevel.Level20">
            <summary>The zoom level's styles will be applied to zoom level 20.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ScreenPointF">
            <summary>This structure represents a single point in screen coordinates.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ScreenPointF.#ctor(System.Single,System.Single)">
            <summary>
            This constructor allows you to create a screen point by passing in an X &amp;
            Y.
            </summary>
            <remarks>None</remarks>
            <param name="x">This parameter represents the horizontal value of a screen point.</param>
            <param name="y">This parameter represents the vertical value of a screen point.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ScreenPointF.op_Equality(ThinkGeo.MapSuite.Core.ScreenPointF,ThinkGeo.MapSuite.Core.ScreenPointF)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the sourceScreenPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetScreenPoint, we will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <param name="screenPointF1">This parameter is the first screenPoint to compare with.</param>
            <param name="screenPointF2">This parameter is the second screenPoint to compare width.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ScreenPointF.op_Inequality(ThinkGeo.MapSuite.Core.ScreenPointF,ThinkGeo.MapSuite.Core.ScreenPointF)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <param name="screenPointF1">This parameter represents the first GeoColor to compare.</param>
            <param name="screenPointF2">This parameter represents the second GeoColor to compare.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the sourceScreenPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetScreenPoint, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ScreenPointF.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <returns>This method returns the Equals functionality.</returns>
            <remarks>None</remarks>
            <param name="obj">
            This parameter is the object you want to check to see if it is equal to the current
            instance.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the obj, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ScreenPointF.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <returns>This method returns the hash code.</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ScreenPointF.X">
            <summary>This property returns the X, or horizontal, value of the screen point.</summary>
            <value>This property returns the X, or horizontal, value of the screen point.</value>
            <example>
            None
            </example>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ScreenPointF.Y">
            <summary>This property returns the Y, or vertical, value of the screen point.</summary>
            <value>This property returns the Y, or vertical, value of the screen point.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LineDashStyle">
            <summary>
            	<para>This enumeration specifies the style of dashed lines drawn with a GeoPen
                object.</para>
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.LineDashStyle.Solid">
            <summary>Specifies a solid line.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.LineDashStyle.Custom">
            <summary>Specifies a user-defined custom dash style.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.LineDashStyle.DashDot">
            <summary>Specifies a line consisting of a repeating pattern of dash-dot.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.LineDashStyle.DashDotDot">
            <summary>Specifies a line consisting of a repeating pattern of dash-dot-dot.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.LineDashStyle.Dot">
            <summary>Specifies a line consisting of dots.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.LineDashStyle.Dash">
            <summary>Specifies a line consisting of dashes.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PointPlacement">
            <summary>
            This enumeration determines the label placement when labeling point
            features.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointPlacement.UpperLeft">
            <summary>The label will be placed in the upper left, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointPlacement.UpperCenter">
            <summary>The label will be placed in the upper center, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointPlacement.UpperRight">
            <summary>The label will be placed in the upper right, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointPlacement.CenterRight">
            <summary>The label will be placed in the center right, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointPlacement.Center">
            <summary>The label will be placed in the center, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointPlacement.CenterLeft">
            <summary>The label will be placed in the center left, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointPlacement.LowerLeft">
            <summary>The label will be placed in the lower left, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointPlacement.LowerCenter">
            <summary>The label will be placed in the lower center, in relation to the point.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointPlacement.LowerRight">
            <summary>The label will be placed in the lower right, in relation to the point.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LabelOverlappingRule">
            <summary>This enumeration defines the rules for overlapping.</summary>
            <remarks>
            This defines the rules for label overlapping. Currently, either we allow overlapping or we
            do not. In the future, we may extend this to allow some percentage of partial
            overlapping.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.LabelOverlappingRule.NoOverlapping">
            <summary>No overlapping is allowed.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.LabelOverlappingRule.AllowOverlapping">
            <summary>Overlapping is allowed.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer">
            <summary>This layer represents multiple Shape Files of the same type.</summary>
            <remarks>
            This layer represents multiple Shape Files of the same type. Many times, you will have
            multiple Shape Files that represent the same type and you want to draw all of the
            InternalFeatures in each Shape Files the same way. For example, you may have Shape Files that contain roads separated
            by state (TXRoads.shp, FLRoads.shp, etc.) but want them to seem like one layer, draw
            the same way and let you spatially query seamlessly between them. The MultipleShapeFileFeatureLayer
            accomplishes that goal. When you create the layer, you enter a pattern matching criterion -- such as
            C:\Roads\??Roads.shp" -- and the layer will automatically include all of the Shape Files that
            match that pattern.<br/>
            	<br/>
            In addition to this, you can also generate single large indexes that index the multiple
            Shape Files. This means you can have one large road index for all of the road Shape Files,
            instead of having individual indexes for each layer. Not only is this faster to query, but
            it also allows you to minimize the number of files you need.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            to required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, then you need to set to required properties
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.#ctor(System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the path and filename pattern to match for the
            Shape Files.
            </overloads>
            <remarks>This constructor allows you to pass in the path and filename pattern to match.</remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">
            This parameter is the matching pattern to determine which Shape Files are
            loaded.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the path and filename patterns to match for the
            Shape Files and their index files.
            </overloads>
            <returns>None</returns>
            <remarks>
            With this constructor you can specify differently-named indexes for the layer. If you have one large
            index, specify its path and filename here. If you have smaller single indexes, use wildcards to specify a
            pattern to match instead.<br/>
            	<br/>
            For example, if you had 50 road Shape Files named C:\Roads\??Roads.shp (where ?? is the two-character state
            abbreviation), but only one large index, then you would specify
            a string like "C:\Roads\Roads.idx". If you instead had 50 individual indexes whose names
            matched the Shape Files, then you would use "C:\Roads\??Roads.idx".
            </remarks>
            <param name="multipleShapeFilePattern">
            This parameter is the path and filename matching pattern that determines which Shape Files are
            loaded.
            </param>
            <param name="indexFilePattern">
            This parameter is the path and filename matching pattern that determines which index files are
            loaded.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.#ctor(System.String[],System.String[])">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This is the  constructor for this class. 
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the constructor for this class. You can pass in a group of shapes and its corresponding indexs 
            like string[] shapeFiles = new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" };
                 string[] indexFiles = new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" };
            In this way, the MultipleShapeFileFeatureLayer will construct from the passing 2 shapes.
            </remarks>
            <param name="multipleShapeFiles">
            This parameter represents the shape files to construct the MultipleShapeFileFeatureLayer. The format of it should be
            new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" }.
            </param>
            <param name="multipleShapeFileIndexes">
            This parameter represents the shape files to construct the ShapeFileFeatureLayer. The format of it should be
             new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" }.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.BuildIndex(System.String)">
            <summary>This method builds a spatial index for the layer.</summary>
            <overloads>
            This overload allows you to pass in a Shape File path and filename pattern. It will generate
            indexes for each Shape File it finds, matching the index file names to the Shape File names.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a Shape File path and filename pattern. It will generate
            indexes for each Shape File it finds, matching the index file names to the Shape File names.
            </remarks>
            <param name="multipleShapeFilePattern">This parameter is the matching pattern that defines which Shape Files to include.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.BuildIndex(System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>This method builds a spatial index for the layer.</summary>
            <overloads>
            This overload allows you to pass in a Shape File path and filename pattern and determines if we
            rebuild index files that already exist. It will generate indexes for each Shape File
            it finds, matching the index file names to the Shape File names.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a Shape File path and filename pattern and determines if we
            re-build index files that already exist. It will generate indexes for each Shape File
            it finds, matching the index file names to the Shape File names.
            </remarks>
            <param name="multipleShapeFilePattern">This parameter is the matching pattern that defines which Shape Files to include.</param>
            <param name="buildIndexMode">
            This parameter determines whether an index file will be rebuilt if it already
            exists.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.BuildIndex(System.String,System.String)">
            <summary>This method builds a spatial index for the layer.</summary>
            <overloads>
            This overload allows you to pass in a path and filename pattern for Shapes Files and index files.
            If you use a pattern for the index file name, it will generate indexes for each Shape File
            it finds, matching the index file names to the Shape File names. Alternatively, if you use a concrete
            index file name, it will generate one large index instead.
            </overloads>
            <remarks>
            	<para>This overload allows you to pass in a path and filename pattern for Shapes Files and index files.
                If you use a pattern for the index file name, it will generate indexes for each Shape File
                it finds, matching the index file names to the Shape File names. Alternatively, if you use a concrete
                index file name, it will generate one large index instead.<br/>
            		<br/>
                If you enter an indexFilePattern like "C:\Roads\??Roads.idx",
                it will build individual indexes for each Shape File and name them according to the pattern.
                If you enter an absolute name, like "C:\Roads\Roads.idx", it will create one large index for all of the Shape
                Files.</para>
            </remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">This parameter is the matching pattern that defines which Shape Files to include.</param>
            <param name="indexFilePattern">
            This parameter is the matching pattern of how to name the index (or
            indexes).
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.BuildIndex(System.String,System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>This method builds a spatial index for the layer.</summary>
            <remarks>
            	<para>This overload allows you to pass in a path and filename pattern for Shapes Files and index files.
                If you use a pattern for the index file name, it will generate indexes for each Shape File
                it finds, matching the index file names to the Shape File names. Alternatively, if you use a concrete
                index file name, it will generate one large index instead.<br/>
            		<br/>
                If you enter an indexFilePattern like "C:\Roads\??Roads.idx",
                it will build individual indexes for each Shape File and name them according to the pattern.
                If you enter an absolute name, like "C:\Roads\Roads.idx", it will create one large index for all of the Shape
                Files.</para>
            </remarks>
            <returns>None</returns>
            <overloads>
            This overload allows you to pass in a path and filename pattern for Shapes Files and index files.
            If you use a pattern for the index file name, it will generate indexes for each Shape File
            it finds, matching the index file names to the Shape File names. Alternatively, if you use a concrete
            index file name, it will generate one large index instead. It also allows you to specify what to do
            if an index file already exists.
            </overloads>
            <param name="multipleShapeFilePattern">This parameter is the matching pattern that defines which Shape Files to include.</param>
            <param name="indexFilePattern">
            This parameter is the matching pattern of how to name the index (or
            indexes).
            </param>
            <param name="buildIndexMode">
            This parameter determines whether an index file will be rebuilt if it already
            exists.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.BuildIndex(System.String,System.String,System.String,System.String)">
            <summary>This method builds a spatial index for the layer.</summary>
            <overloads>
            This method builds a single large index file encompassing many Shape Files and allows you to
            select only certain features to include, based on regular expression matching on a column.
            </overloads>
            <returns>None</returns>
            <remarks>
            This index-building method is very useful when you have a large number of Shape
            Files that contain only certain records you want. For example, you may have an individual Shape File
            for the states of Texas and Florida that contains only those states' roads. They are named TXRoads.shp for Texas
            and FLRoads.shp for Florida. Inside of these Shape Files there is a column that determines
            whether the roads are normal streets or highways. You, of course, want to draw highways
            differently. You could use a ValueStyle, but that would be slow because you'd have to look though
            all of the records at runtime to determine which are the highways. A better solution is to
            build a custom index that only has highways in it. In this way, you generate the index
            once and then runtime performance is fast.<br/>
            <br/>
            In our scenario, we would create an index to include all of
            the road Shape Files by using the pattern "*Roads.shp".  This will make sure we get both the Texas and Florida roads.
            Next, we specify the RoadType column as the column parameter. Then we provide a regular
            expression match that picks out all of the highways, and name the resulting index
            "Highways.idx".  We can then build another, separate index just for the normal streets. In this way, we can
            quickly sort the roads from the highways -- and we didn't have to cut up our Shape
            Files to do it.
            </remarks>
            <param name="multipleShapeFilePattern">This parameter is the matching pattern that defines which Shape Files to include.</param>
            <param name="columnName">
            This parameter is the column name you want to apply the regular
            expression towards.
            </param>
            <param name="regularExpression">
            This parameter is the regular expression you want to use to select certain
            features for your index.
            </param>
            <param name="indexFilename">
            This parameter is the name of the index file you want to generate for the features that match
            the regular expression.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.BuildIndex(System.String,System.String,System.String,System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>This method builds a spatial index for the layer.</summary>
            <remarks>
            This index-building method is very useful when you have a large number of Shape
            Files that contain only certain records you want. For example, you may have an individual Shape File
            for the states of Texas and Florida that contains only those states' roads. They are named TXRoads.shp for Texas
            and FLRoads.shp for Florida. Inside of these Shape Files there is a column that determines
            whether the roads are normal streets or highways. You, of course, want to draw highways
            differently. You could use a ValueStyle, but that would be slow because you'd have to look though
            all of the records at runtime to determine which are the highways. A better solution is to
            build a custom index that only has highways in it. In this way, you generate the index
            once and then runtime performance is fast.<br/>
            <br/>
            In our scenario, we would create an index to include all of
            the road Shape Files by using the pattern "*Roads.shp".  This will make sure we get both the Texas and Florida roads.
            Next, we specify the RoadType column as the column parameter. Then we provide a regular
            expression match that picks out all of the highways, and name the resulting index
            "Highways.idx".  We can then build another, separate index just for the normal streets. In this way, we can
            quickly sort the roads from the highways -- and we didn't have to cut up our Shape
            Files to do it.
            </remarks>
            <overloads>
            This method builds a single large index file encompassing many Shape Files and allows you to
            select only certain features to include, based on regular expression matching on a column.
            It also allows you to specify what to do if an index file already exists.
            </overloads>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">This parameter is the matching pattern that defines which Shape Files to include.</param>
            <param name="columnName">
            This parameter is the column name you want to apply the regular
            expression towards.
            </param>
            <param name="regularExpression">
            This parameter is the regular expression you want to use to select certain
            features for your index.
            </param>
            <param name="indexFilename">
            This parameter is the name of the index file you want to generate for the features that match
            the regular expression.
            </param>
            <param name="buildIndexMode">
            This parameter determines whether the index file will be rebuilt if it already
            exists.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.BuildIndex(System.String[],System.String[])">
            <summary>
            This method builds a spatial index for the layer.
            </summary>
            <param name="multipleShapeFiles">
            This parameter represents the shape files to construct the MultipleShapeFileFeatureLayer. The format of it should be
            new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" }.
            </param>
            <param name="multipleShapeFileIndexes">
            This parameter represents the shape files to construct the ShapeFileFeatureLayer. The format of it should be
             new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" }.
            </param>
            <param name="buildIndexMode">
            This parameter determines whether the index file will be rebuilt if it already
            exists.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.BuildIndex(System.String[],System.String[],ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>
            This method builds a spatial index for the layer.
            </summary>
            <param name="multipleShapeFiles">
            This parameter represents the shape files to construct the MultipleShapeFileFeatureLayer. The format of it should be
            new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" }.
            </param>
            <param name="multipleShapeFileIndexes">
            This parameter represents the shape files to construct the ShapeFileFeatureLayer. The format of it should be
             new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" }.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.GetShapePathFileNames">
            <summary>
            This method returns a collection of the Shape Files and their paths that make up the
            layer.
            </summary>
            <returns>
            This method returns a collection of the Shape Files and their paths that make up the
            layer.
            </returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.GetIndexPathFileNames">
            <summary>
            This method returns a collection of the index files and their paths that make up the
            layer.
            </summary>
            <returns>
            This method returns a collection of the index files and their paths that make up the
            layer.
            </returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.MultipleShapeFilePattern">
            <summary>
            This property gets and sets the Shape File pattern that makes up this
            layer.
            </summary>
            <value>This property gets the Shape File pattern that makes up this layer.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.IndexFilePattern">
            <summary>
            This property gets and sets the index file pattern that makes up this
            layer.
            </summary>
            <value>This property gets the index file pattern that makes up this layer.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In MultipleShapeFeatureLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GdiPlusRasterLayer">
            <summary>
            This class represents general image types to be drawn on the map, such as .BMP,
            .JPG, .PNG, etc.
            </summary>
            <remarks>
            This type of layer is used to draw standard image types on the map.
            These include .BMP, .JPG, .PNG, .TIFF, and all other image types that are
            supported by the .NET Framework to be loaded as a Bitmap.<br/>
            	<br/>
            Each of these images will need a world file associated with it. The world file contains
            the geospatial information pertaining to the image. Using the world file, we know its
            spatial position and other required information to draw it on the map relative to other
            images or spatial features. World files are small text files with an extension that
            matches the original image's extension, but with the middle character of the extension
            changed to a "w". If you have images that you want to use but do not have their world files,
            please contact the source of the image so that they can provide one for you. world files are
            fairly common in the GIS community.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterLayer.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the PathFileName property manually before using the layer.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, then you need to set the PathFileName property
            manually before using the layer.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterLayer.#ctor(System.String)">
            <overloads>
            This constructor allows you to provide the path and filename information for the GDI+ image
            file.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <summary>This is a constructor for the class.</summary>
            <param name="pathFilename">This parameter is the path and filename of the GDI+ image file you want to use.
            If you want to load a Tiff(.tif or .tiff) files, please use the GeoTiffRasterLayer instead for better performance.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterLayer.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename information for both the GDI+ image file and its world file.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="pathFilename">This parameter is the path and filename of the GDI+ image file you want to use.
            If you want to load a Tiff(.tif or .tiff) files, please use the GeoTiffRasterLayer instead for better performance.</param>
            <param name="worldfilePathFilename">This parameter is the world file path and filename for the GDI+ image you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterLayer.#ctor(System.String,ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename for the GDI+ image file and the
            image extent to use.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="pathFilename">This parameter is the path and filename of the GDI+ image file you want to use.
            If you want to load a Tiff(.tif or .tiff) files, please use the GeoTiffRasterLayer instead for better performance.</param>
            <param name="imageExtent">This parameter is the image extent of GDI+ image file you want to use.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusRasterLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In GdiPlusRasterLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusRasterLayer.PathFilename">
            <summary>
            This property gets and sets the path and filename of the image file you want to
            use.
            </summary>
            <value>This property gets the path and filename of the image file you want to use.</value>
            <remarks>This should be a complete path and filename for the image file.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.TransactionBuffer">
            <summary>
            This class represents the holding place for transactions that have not yet been
            committed.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TransactionBuffer.#ctor">
            <summary>This is the class constructor.</summary>
            <overloads>This is the default constructor and is typically not used.</overloads>
            <remarks>This is the default constructor and is typically not used.</remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TransactionBuffer.#ctor(System.Collections.Generic.Dictionary{System.String,ThinkGeo.MapSuite.Core.Feature},System.Collections.ObjectModel.Collection{System.String},System.Collections.Generic.Dictionary{System.String,ThinkGeo.MapSuite.Core.Feature})">
            <summary>This is the class constructor.</summary>
            <overloads>This is the constructor for this class allows you pass in the necessary 
            properties in the class.</overloads>
            <returns>None</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TransactionBuffer.Clear">
            <summary>
            This method will clear all the items in AddBuffer, EditBuffer and
            DeleteBuffer.
            </summary>
            <returns>None.</returns>
            <remarks>
            This method will clear all the items in AddBuffer, EditBuffer and
            DeleteBuffer.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TransactionBuffer.AddFeature(ThinkGeo.MapSuite.Core.Feature)">
            <summary>This method allows you to add InternalFeatures to the transaction buffer.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="feature">
            This parameter represents the Feature you are adding to the transaction
            buffer.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TransactionBuffer.AddFeature(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>This method allows you to add a shape into the buffer.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="baseShape">This parameter represents the shape to be added. </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TransactionBuffer.AddFeature(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>This method allows you to add a shape into the buffer.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="baseShape">This parameter represents the shape to be added. </param>
            <param name="columnValues">This parameter represents the feature value to be added. </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TransactionBuffer.DeleteFeature(System.String)">
            <summary>
            This method allows you to add a placeholder to represent a Feature to be
            deleted.
            </summary>
            <returns>None</returns>
            <remarks>
            This does not remove a feature from the TransactionBuffer but rather it add a "to
            be deleted record". In this way when the TransactionBuffer if processed we know what
            records need to be deleted.
            </remarks>
            <param name="featureId">
            This parameter represents the unique Id for the specific Feature being passed
            in.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TransactionBuffer.EditFeature(ThinkGeo.MapSuite.Core.Feature)">
            <summary>This method allows you to add a Feature to be updated.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="feature">This parameter represents the Feature to be updated.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TransactionBuffer.EditFeature(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>This method allows you to add a shape to be updated.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="baseShape">This parameter represents the shape to be updated. 
            The shape ID should be the same as the feature you are going to update.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TransactionBuffer.EditFeature(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>This method allows you to add a shape to be updated.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="baseShape">This parameter represents the shape to be updated. 
            The shape ID should be the same as the feature you are going to update.</param>
            <param name="columnValues">This parameter represents the feature value to be updated. 
            The shape ID should be the same as the feature you are going to update.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TransactionBuffer.AddBuffer">
            <summary>This property gets the dictionary buffer that holds InternalFeatures to be added.</summary>
            <decimalDegreesValue>This property gets the dictionary buffer that holds InternalFeatures to be added.</decimalDegreesValue>
            <remarks>
            It is recommended that you use this dictionary for reviewing and not for adding
            new items. The reason is that the Add, Delete and Edit methods to various validation
            checks. For example if you call the DeleteFeature twice it will handle the case that
            you really only want to delete the record once. Another example is if you edit a record
            twice it will replace the existing edit with the new one.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TransactionBuffer.DeleteBuffer">
            <summary>
            This property gets the dictionary buffer that holds InternalFeatures to be
            deleted.
            </summary>
            <decimalDegreesValue>
            This property gets the dictionary buffer that holds InternalFeatures to be
            deleted.
            </decimalDegreesValue>
            <remarks>
            It is recommended that you use this dictionary for reviewing and not for adding
            new items. The reason is that the Add, Delete and Edit methods to various validation
            checks. For example if you call the DeleteFeature twice it will handle the case that
            you really only want to delete the record once. Another example is if you edit a record
            twice it will replace the existing edit with the new one.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TransactionBuffer.EditBuffer">
            <summary>
            This property gets the dictionary buffer that holds InternalFeatures to be
            updated.
            </summary>
            <decimalDegreesValue>
            This property gets the dictionary buffer that holds InternalFeatures to be
            updated.
            </decimalDegreesValue>
            <remarks>
            It is recommended that you use this dictionary for reviewing and not for adding
            new items. The reason is that the Add, Delete and Edit methods to various validation
            checks. For example if you call the DeleteFeature twice it will handle the case that
            you really only want to delete the record once. Another example is if you edit a record
            twice it will replace the existing edit with the new one.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource">
            <summary>This class represents a FeatureSource backed by MS SQL 2008.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>This is the default constructor but it is not typically used.</overloads>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.#ctor(System.String,System.String,System.String)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in all of the data to create the
            FeatureSource.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="connectionString">This parameter represents the connection string to connect to the server.</param>
            <param name="tableName">This parameter represents the table name being accessed.</param>
            <param name="featureIdColumn">
            This parameter represents the name of the column that holds the unique feature
            Id.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.#ctor(System.String,System.String,System.String,System.Int32)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in all of the data to create the
            FeatureSource.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="connectionString">This parameter represents the connection string to connect to the server.</param>
            <param name="tableName">This parameter represents the table name being accessed.</param>
            <param name="featureIdColumn">
            This parameter represents the name of the column that holds the unique feature
            Id.
            </param>
            <param name="srid">Specify what kind srid data to be used.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.OnExecutingSqlStatement(ThinkGeo.MapSuite.Core.ExecutingSqlStatementMsSql2008FeatureSourceEventArgs)">
            <summary>This method allows you to raise the ExecutingSqlStatement event.</summary>
            <returns>None</returns>
            <remarks>
            This method allows you to raise the ExecutingSqlStatement event. Normally events are not
            accessible to derived classes so we exposed a way to raise the event is necessary
            through this protected method.
            </remarks>
            <param name="e">
            This parameter represents the event arguments you want to raise the ExecutingSqlStatement
            event with.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.BuildIndex(ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>
            Build Spatial index
            </summary>
            <param name="buildIndexMode">Build Index Mode</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.Validate">
            <summary>
            Check if all geometry are valid for spatial query.
            </summary>
            <returns>If all geometry are valid, the count of the returning dictionary is 0.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.MakeAllGeometriesValid">
            <summary>
            To make the geometry type data valid, and update the table.
            </summary>
            <remarks>
                This function will check whether the geometry is valid for spatial query,
                if it is not, then the function will make it valid and save it back to the 
                table.
                For example: Here's a invalid LineString LINESTRING(0 2,1 1,1 0,1 1,2 2))
                which is overlaps itself, it's invalid. After use this function, it will be 
                MULTILINESTRING ((0 2, 1 1, 2 2), (1 1, 1 0))
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.GetFirstGeometryType">
            <summary>
            Get The shape type from the first record.
            </summary>
            <returns>The shape type of the first record.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.ExecuteNonQueryCore(System.String)">
            <summary>Executes a SQL statement against a connection object.</summary>
            <returns>The number of rows affected.</returns>
            <remarks>
            	You can use ExecuteNonQuery to perform catalog
                operations (for example, querying the structure of a database or creating database
                objects such as tables), or to change the data in a database by executing UPDATE,
                INSERT, or DELETE statements.
            	Although ExecuteNonQuery does not return any
                rows, any output parameters or return values mapped to parameters are populated
                with data.
            	For UPDATE, INSERT, and DELETE statements, the return value is the number of
                rows affected by the command.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.ExecuteQueryCore(System.String)">
            <summary>
            Executes the query and returns the result returned by the query.
            </summary>
            <returns>The result set in the format of dataTable.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            reaquires less code than use the ExcuteQuery method and performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.ExecuteScalarCore(System.String)">
            <summary>
            Executes the query and returns the first column of the first row in the result
            set returned by the query. All other columns and rows are ignored.
            </summary>
            <returns>The first column of the first row in the result set.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            reaquires less code than use the ExcuteQuery method and performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has already been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concreate public method Open.
            The open method play an important role as it is responsible for initializing the
            FeatureSource. Most methods on the FeatureSource will throw an exception if the state
            of the FeatureSource is not opened. When the map draws each layer it will open the
            FeatureSource as one of its first steps, then after it is finished drawing with that
            layer it will close it. In this way we are sure to release all resources used by the
            FeatureSource.<br/>
            	<br/>
            When implementing this abstract method consider opening files for file based source,
            connecting to databases in the database based sources and so on. You will get a chance
            to close these in the Close method of the FeatureSource.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.CloseCore">
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concreate public method Close.
            The close method plays an important role in the life cycle of the FeatureSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            It is recommended that if you override this method that you take the following things
            into account. This method may be called multiple times so we suggest you write the so
            that that a call to a closed FeatureSource is ignored and does not generate an error.
            We also suggest that in the close you free all resources that have been opened.
            Remember that the object will not be destroyed but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.GetCountCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <summary>
            This method returns the count of the number of records in this
            FeatureSource.
            </summary>
            <returns>
            This method returns the count of the number of records in this
            FeatureSource.
            </returns>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetCount. It does not take into account any transaction activity as this is the
                responsibility of the concreate public method GetCount. In this way as a developer
                if you choose to override this method you do not have to consider transaction at
                all.<br/>
            		<br/>
                The default implementation of GetCountCore uses the GetAllRecordsCore method to
                calculate how many records there are in the FeatureSource. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient<br/>
            		<br/>
                If you do not override this method the means it gets the count is by calling the
                GetAllFeatureCore method and counting each feature. This is a very inefficient way
                to get the count in most data sources. It is highly recommended that you override
                this method and replace it with a highly optimized version. For example in a
                ShapeFile the record count is in the main header of the file. Similarly if you are
                using Oracle Spatial you can execute a simple query to get the count of all of the
                record without returning them. In these ways you can greatly improve the
                performance of this method.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.GetFeaturesInsideBoundingBoxCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box.
            </summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions as this is handled by the concreate version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesInsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding box. We
            strongly recommend that you provide your own implementation for this method that will
            be more efficient. It is especially important for this method as many other default
            virtual methods use this for their calculations. We highly recommend when you override
            this method that you use any spatial indexes you have at your disposal to make this
            method as fast as possible.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.GetFeaturesOutsideBoundingBoxCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </returns>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </summary>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box. If you are in a transaction and that transaction is live then
            it will also take that into consideration.<br/>
            	<br/>
            	<br/>
            The default implementation of GetFeaturesOutsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are outside of the bounding box.
            We strongly recommend that you provide your own implementation for this method that
            will be more efficient
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.CommitTransactionCore(ThinkGeo.MapSuite.Core.TransactionBuffer)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction it will throw an InvalidOperationException.</exception>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
            <remarks>
            	<para>This method will commit the existing transaction to its underlying source of
                data. It will pass back the results of how the commit went to include any error
                received. If you are implementing your own FeatureSource then this is one of the
                crucial methods you must create. It should be fairly straight forward that you will
                loop through the transaction buffer and add, edit or delete the InternalFeatures in your
                underlying data source. Remember to build and pass back the TransactionResult class
                so that users of your FeatureSource can respond to failures you may encounter
                committing the InternalFeatures. We will handle the end of the transaction and also the
                cleanup of the transaction buffer. Your task will be to commit the records and
                produce a TransactionResult return.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited
                implementation of any specific source such as Oracle Spatial or Shape files. In
                this way it functions the same way for every FeatureSource. You start by calling
                the BeginTransaction. This allocates a collection of in memory change buffers that
                are used to store changes until you commit the transaction. So for example when you
                call the Add, Delete or Update method the changes to the feature are stored in
                memory only. If for any reason you choose to abandon the transaction you can call
                RollbackTransaction at any time and the in memory buffer will be deleted and the
                changes will be lost. When you are ready to commit the transaction you call the
                CommitTransaction and the collections of changes are then passed to the
                CommitTransactionCore method and the implementer of the specific FeatureSource is
                responsible for integrating your changes into the underlying FeatureSource. By
                default the IsLiveTransaction property is set to false which means that until you
                commit the changes the FeatureSource API will not reflect any changes that are in
                the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true then things function
                slightly differently. The live transaction concept means that all of the
                modification you perform during a transaction are live from the standpoint of the
                querying methods on the object.</para>
            	<para>To setup an example imagine that you have a FeatureSource that has 10 records
                in it. Next you begin a transaction and then call GetAllFeatures, the result would
                be 10 records. After that you call a delete on one of the records and call the
                GetAllFeatures again, this time you only get nine records. You receive nine records
                even though the transaction has not yet been committed. In the same sense you could
                have added a new record or modified an existing one and those changes are
                considered live though not committed.</para>
            	<para>In the case where you modify records such as expanding the size of a polygon
                those changes as well are reflected. So for example you expand a polygon by
                doubling its size and then do a spatial query that would not normally return the
                smaller record but would return the larger records, in this case the larger record
                is returned. You can set this property to be false as well in which case all of the
                spatial related methods would ignore anything that is currently in the transaction
                buffer waiting to be committed. In this case only after committing the transaction
                would the FeatureSource reflect the changes.</para>
            </remarks>
            <returns>
            The return decimalDegreesValue of this method is a TransactionResult class which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful and any error that were encountered during the
            committing of the transaction.
            </returns>
            <param name="transactions">
            This parameter encapsulates all of the adds, edits and deleted that make up the
            transaction. You will use this data to write the changes to your underlying data
            source.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.GetAllFeaturesCore(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. You will not need
            to consider anything about pending transactions as this will be handled in the non Core
            version of the method.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We wanted as the framework developers to provide you
            the user with as much default virtual implementation as possible. To do this we needed
            a way to get access to all of the features. For example, we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all the records then we can brute force
            the answer. In this way if you inherited form this class and only implemented this one
            method we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource
            it comes with a price. The price is that it is very inefficient. In the case we just
            discussed about finding all of the InternalFeatures in a bounding box we would not want to look
            at every record to fulfil this method. Instead we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be fast. For
            example in Oracle Spatial there is a specific SQL statement to do this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. It will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.
            </remarks>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.GetColumnsCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the columns available for the FeatureSource.</summary>
            <remarks>
            As this is the abstract core version of the Columns method it is intended to
            be overridden in inherited version of the class. When overriding you will be
            responsible for getting a list of all of the columns supported by the FeatureSource. In
            this way the FeatureSource will know what columns are available and will remove any
            extra columns when making calls to other core methods. For example if you have a
            FeatureSource that has three columns of information and the user calls a method and
            requests four columns of information, something they can do with custom fields, we will
            first compare what they are asking for to the results of the GetColumnsCore. In this
            way we can strip out custom columns before calling other Core methods which are only
            responsible for returning data in the FeatureSource. For more information on custom
            fields you can see the documentation on the OnCustomFieldsFetch.
            </remarks>
            <returns>This method returns the columns available for the FeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetBoundingBox. It does not take into account any transaction activity as this is
                the responsibility of the concreate public method GetBoundingBox. In this way as a
                developer if you choose to override this method you do not have to consider
                transaction at all.<br/>
            		<br/>
                The default implementation of GetBoundingBoxCore uses the GetAllRecordsCore method
                to calculate the bounding box of the FeatureSource. We strongly recommend that you
                provide your own implementation for this method that will be more efficient<br/>
            		<br/>
                If you do not override this method the means it gets the BoundingBox is by calling
                the GetAllFeatureCore method and deriving it from each feature. This is a very
                inefficient way to get the BoundingBox in most data sources. It is highly
                recommended that you override this method and replace it with a highly optimized
                version. For example in a ShapeFile the BoundingBox is in the main header of the
                file. Similarly if you are using Oracle Spatial you can execute a simple query to
                get the BoundingBox of all of the record without returning them. In these ways you
                can greatly improve the performance of this method.</para>
            </remarks>
            <summary>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </summary>
            <returns>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.GetFeaturesByIdsCore(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns a collection of InternalFeatures by providing a group of Ids.</summary>
            <returns>This method returns a collection of InternalFeatures by providing a group of Ids.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetAllFeaturesCore. Because of this if you want an
            efficient version of this method then we high suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids which uniquely identified the InternalFeatures
            in the FeatureSource.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.CommandTimeout">
            <summary>This property gets and sets the time maximum for a command to complete.</summary>
            <decimalDegreesValue>This property gets the time maximum for a command to complete.</decimalDegreesValue>
            <remarks>This property allows you to set a timeout of a command.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.CanExecuteSqlQueryCore">
            <summary>
            This property specifies the FeatureSource can excute sql query or not.
            If it is false, then it will throw exception when called the APIs:ExecuteScalar,ExecuteNonQuery,ExecuteQuery
            This orverides will make it true.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.ConnectionString">
            <summary>
            This property gets and sets the connection string used to connect to the
            server.
            </summary>
            <decimalDegreesValue>This property gets the connection string used to connect to the server.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.TableName">
            <summary>This property gets or sets the table name the database will use.</summary>
            <decimalDegreesValue>This property gets the table name the database will use.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.FeatureIdColumn">
            <summary>
            This property gets or sets the name of the column that holds the unique feature
            Id.
            </summary>
            <decimalDegreesValue>
            This property gets the name of the column that holds the unique feature
            Id.
            </decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.IsEditable">
            <summary>This property returns if the FeatureSource allows edits or is read only.</summary>
            <decimalDegreesValue>
            This property returns if the FeatureSource allows edits or is read only. The
            property returns true if the FeatureSource allows edits and false if the FeatureSource
            is read only.
            </decimalDegreesValue>
            <remarks>
            	<para>This property is useful to check if a specific FeatureSource accepts editing.
                If you call the BeginTransaction and this property is false then an exception will
                be raised.<br/>
            		<br/>
                For developers who are creating or extending a FeatureSource it is expected that
                you override this virtual method if the new FeatureSource you are creating allows
                edits. By default the decimalDegreesValue if false meaning that if you want to allow edits you
                must override this method and return true.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.SpatialDataType">
            <summary>This property gets the spatial data type in the MsSql2008FeatureSource.</summary>
            <value>This property gets the spatial data type in the MsSql2008FeatureSource.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.Srid">
            <summary>
            Specify what kind srid data to be used.
            </summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.MsSql2008FeatureSource.ExecutingSqlStatement">
            <summary>
            This event will be fired every time the sql statement is excuted.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WfsFeatureLayer">
            <summary>This class represents the wfs(web feature service) FeauteLayer.</summary>
            <remarks>
            This class allows you to get features from an wfs server. 
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureLayer.#ctor">
            <summary>
            WfsFeatureLayer Constructor.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureLayer.#ctor(System.String,System.String)">
            <summary>
            WfsFeatureSource Constructor
            </summary>
            <remarks>The parameters can not be null.</remarks>
            <param name="serviceLocationUrl">The url of wfs service.</param>
            <param name="typeName">The typename in the specify wfs service.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureLayer.GetCapabilities(System.String)">
             <summary>
             Get capabilities from the specific wfs service url.
             </summary>
             <returns>The xml text represents capabilities of this wfs server.</returns>
             <remarks><para>Every OGC Web Service (OWS), including a Web Feature Service, must have the ability to describe its capabilities by returning service metadata in response to a GetCapabilities request. Specifically, every web feature service must support the KVP encoded form of the GetCapabilities request over HTTP GET so that a client can always know how to obtain a capabilities document.</para>
             <para>
             The capabilities response document contains the following sections:
            1. Service Identification section
            The service identification section provides information about the WFS service itself.
            2. Service Provider section
            The service provider section provides metadata about the organization operating the WFS server.
            3. Operation Metadata section
            The operations metadata section provides metadata about the operations defined in this specification and implemented by a particular WFS server. This metadata includes the DCP, parameters and constraints for each operation.
            4. FeatureType list section
            This section defines the list of feature types (and operations on each feature type) that are available from a web feature service. Additional information, such as the default SRS, any other supported SRSs, or no SRS whatsoever (for non-spatial feature types), for WFS requests is provided for each feature type.
            5. ServesGMLObjectType list section
            This section defines the list of GML Object types, not derived from gml:AbstractFeatureType, that are available from a web feature service that supports the GetGMLObject operation. These types may be defined in a base GML schema, or in an application schema using its own namespace.
            6. SupportsGMLObjectType list section
            The Supports GML Object Type section defines the list of GML Object types that a WFS server would be capable of serving if it was deployed to serve data.
            described by an application schema that either used those GML Object types directly (for non-abstract types), or defined derived types based on those types.
            7. Filter capabilities section
            The schema of the Filter Capabilities Section is defined in the Filter Encoding Implementation Specification [3]. This is an optional section. If it exists, then the WFS should support the operations advertised therein. If the Filter Capabilities Section is not defined, then the client should assume that the server only supports the minimum default set of filter operators.
             </para>
             </remarks>
             <param name="serviceLocationUrl">The url of wfs service.</param>
             <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If serviceLocationUrl is null, we will throw an ArgumentNullException.</exception>        
             <exception cref="T:System.ArgumentException" caption="ArgumentException">If serviceLocationUrl is empty, we will throw an ArgumentException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureLayer.GetCapabilities(System.Uri)">
             <summary>
             Get capabilities from the specific wfs service url.
             </summary>
             <returns>The xml text represents capabilities of this wfs server.</returns>
             <remarks><para>Every OGC Web Service (OWS), including a Web Feature Service, must have the ability to describe its capabilities by returning service metadata in response to a GetCapabilities request. Specifically, every web feature service must support the KVP encoded form of the GetCapabilities request over HTTP GET so that a client can always know how to obtain a capabilities document.</para>
             <para>
             The capabilities response document contains the following sections:
            1. Service Identification section
            The service identification section provides information about the WFS service itself.
            2. Service Provider section
            The service provider section provides metadata about the organization operating the WFS server.
            3. Operation Metadata section
            The operations metadata section provides metadata about the operations defined in this specification and implemented by a particular WFS server. This metadata includes the DCP, parameters and constraints for each operation.
            4. FeatureType list section
            This section defines the list of feature types (and operations on each feature type) that are available from a web feature service. Additional information, such as the default SRS, any other supported SRSs, or no SRS whatsoever (for non-spatial feature types), for WFS requests is provided for each feature type.
            5. ServesGMLObjectType list section
            This section defines the list of GML Object types, not derived from gml:AbstractFeatureType, that are available from a web feature service that supports the GetGMLObject operation. These types may be defined in a base GML schema, or in an application schema using its own namespace.
            6. SupportsGMLObjectType list section
            The Supports GML Object Type section defines the list of GML Object types that a WFS server would be capable of serving if it was deployed to serve data.
            described by an application schema that either used those GML Object types directly (for non-abstract types), or defined derived types based on those types.
            7. Filter capabilities section
            The schema of the Filter Capabilities Section is defined in the Filter Encoding Implementation Specification [3]. This is an optional section. If it exists, then the WFS should support the operations advertised therein. If the Filter Capabilities Section is not defined, then the client should assume that the server only supports the minimum default set of filter operators.
             </para>
             </remarks>
             <param name="serverUri">The url of wfs service.</param>
             <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If serviceLocationUrl is null, we will throw an ArgumentNullException.</exception>        
             <exception cref="T:System.ArgumentException" caption="ArgumentException">If serviceLocationUrl is empty, we will throw an ArgumentException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureLayer.GetCapabilities(System.Uri,System.Net.WebProxy)">
             <summary>
             Get capabilities from the specific wfs service url.
             </summary>
             <returns>The xml text represents capabilities of this wfs server.</returns>
             <remarks><para>Every OGC Web Service (OWS), including a Web Feature Service, must have the ability to describe its capabilities by returning service metadata in response to a GetCapabilities request. Specifically, every web feature service must support the KVP encoded form of the GetCapabilities request over HTTP GET so that a client can always know how to obtain a capabilities document.</para>
             <para>
             The capabilities response document contains the following sections:
            1. Service Identification section
            The service identification section provides information about the WFS service itself.
            2. Service Provider section
            The service provider section provides metadata about the organization operating the WFS server.
            3. Operation Metadata section
            The operations metadata section provides metadata about the operations defined in this specification and implemented by a particular WFS server. This metadata includes the DCP, parameters and constraints for each operation.
            4. FeatureType list section
            This section defines the list of feature types (and operations on each feature type) that are available from a web feature service. Additional information, such as the default SRS, any other supported SRSs, or no SRS whatsoever (for non-spatial feature types), for WFS requests is provided for each feature type.
            5. ServesGMLObjectType list section
            This section defines the list of GML Object types, not derived from gml:AbstractFeatureType, that are available from a web feature service that supports the GetGMLObject operation. These types may be defined in a base GML schema, or in an application schema using its own namespace.
            6. SupportsGMLObjectType list section
            The Supports GML Object Type section defines the list of GML Object types that a WFS server would be capable of serving if it was deployed to serve data.
            described by an application schema that either used those GML Object types directly (for non-abstract types), or defined derived types based on those types.
            7. Filter capabilities section
            The schema of the Filter Capabilities Section is defined in the Filter Encoding Implementation Specification [3]. This is an optional section. If it exists, then the WFS should support the operations advertised therein. If the Filter Capabilities Section is not defined, then the client should assume that the server only supports the minimum default set of filter operators.
             </para>
             </remarks>
             <param name="serverUri">The url of wfs service.</param>
             <param name="webProxy">The proxy of the wfs service.</param>
             <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If serviceLocationUrl is null, we will throw an ArgumentNullException.</exception>        
             <exception cref="T:System.ArgumentException" caption="ArgumentException">If serviceLocationUrl is empty, we will throw an ArgumentException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureLayer.GetLayers(System.String)">
            <summary>
            Get layer names from specific wfs service url.
            </summary>
            <param name="serviceLocationUrl">The url of wfs service.</param>
            <returns>The collection represent layer names.</returns>
            <remarks>Typically, it will call WfsFeatureSource.GetLayers(serviceLocationUrl) internally.</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If serviceLocationUrl is null, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If serviceLocationUrl is empty, we will throw an ArgumentException.</exception> 
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureLayer.GetLayers(System.Uri,System.Net.WebProxy)">
            <summary>
            Get layer names from specific wfs service url.
            </summary>
            <param name="serverUri">The url of wfs service.</param>
            <param name="webProxy">The proxy of the wfs service.</param>
            <returns>The collection represent layer names.</returns>
            <remarks>Typically, it will call WfsFeatureSource.GetLayers(serverUri) internally.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureLayer.GetLayers(System.Uri)">
            <summary>
            Get layer names from specific wfs service url.
            </summary>
            <param name="serverUri">The url of wfs service.</param>
            <returns>The collection represent layer names.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WfsFeatureLayer.LastXmlResponse">
            <summary>
            The xml text represnets last respone, it will pass out by RequestedData event as parameter.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WfsFeatureLayer.ServiceLocationUrl">
            <summary>
            The url of wfs service.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WfsFeatureLayer.TypeName">
            <summary>
            The typename in the specify wfs service.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WfsFeatureLayer.TimeoutInSeconds">
            <summary>
            This property specifies the timeout of the web request in seconds.  The default timeout value is 20 seconds.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WfsFeatureLayer.HasBoundingBox">
            <summary>
            This property indicates whether a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs.
            </summary>
            <remarks>The default value is false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WfsFeatureLayer.WebProxy">
            <summary>
            This property gets or sets the proxy used for requesting a Web Response.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.SentTiledWmsLayerEventArgs">
            <summary>
            The event args containing the event data used by SecuredTiledWmsRasterSource.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.SentTiledWmsLayerEventArgs.#ctor(System.Net.HttpWebResponse)">
            <summary>
            Create an instance of SentTiledWmsLayerEventArgs
            </summary>
            <param name="response"></param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SentTiledWmsLayerEventArgs.HttpWebResponse">
            <summary>
            Gets or sets a value indicating the response from Server.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MapShape">
            <summary>
            This class represent a unit can be drawn on map. Each MapShape composes
            of a feature and a ZoomLevelSet to control its drawing zoomlevels.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapShape.#ctor">
            <summary>This is the default constructor for the MapShape.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapShape.#ctor(ThinkGeo.MapSuite.Core.Feature)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a feature for this MapShape.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="feature">This parameter is the feature for this MapShape.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MapShape.Feature">
            <summary>
            This property returns the feature representing the MapShape.
            </summary>
            <value>
            This property set the feature representing the MapShape
            </value>
            <remarks>
            None
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MapShape.ZoomLevels">
            <summary>
            This property returns the ZoomLevel to control the drawing of the MapShape.
            </summary>
            <value>
            This property sets the ZoomLevel to control the drawing of the MapShape.
            </value>
            <remarks>
            None
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.HeatLayer">
            <summary>
            HeatLayer allows you to better visualize data by making areas of high concentration "hotter" using warmer colors and low density areas visually cooler. 
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatLayer.#ctor">
            <summary>This is the default constructor of the class.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatLayer.#ctor(ThinkGeo.MapSuite.Core.FeatureSource)">
            <summary>This is a constructor for the class.</summary>
            <overloads>This constructor allows you to pass in the FeatureSource.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="featureSource">
            This parameter is the FeatureSource that use to be drawn.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatLayer.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a Layer which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method opens the Layer so that it is initialized and ready to use.</summary>
            <remarks>
            This abstract method is called from the concrete public method Open. The
            open method plays an important role, as it is responsible for initializing the Layer.
            Most methods on the Layer will throw an exception if the state of the Layer is not
            opened. When the map draws each layer, the layer will be opened as one of its first steps;
            then, after it is finished drawing with that layer, it will close it. In this way, we
            are sure to release all resources used by the Layer.<br/>
            <br/>
            When implementing the abstract method, consider opening the FeatureSource or
            RasterSource. You will get a chance to close these in the Close method of the
            Layer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatLayer.CloseCore">
            <summary>
            This method closes the Layer and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This abstract method is called from the concrete public method Close. The close
            method plays an important role in the life cycle of the Layer. It may be called after
            drawing to release any memory and other resources that were allocated since the Open
            method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed Layer is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeatLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the Layer.</summary>
            <remarks>
            This method is the concrete wrapper for the abstract method DrawCore. This
                method draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties that
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter represents the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.HeatLayer.FeatureSource">
            <summary>This property gets the FeatureSource for the HeatLayer.</summary>
            <value>This property gets the FeatureSource for the HeatLayer.</value>
            <remarks>
            The FeatureSource is the provider of data to the HeatLayer. There are different
            FeatureSource classes to match the various ways that feature data is stored. It is
            important that, when you inherit from the HeatLayer, in the constructor you set
            the FeatureSource you want to use.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.HeatLayer.HeatStyle">
            <summary>
            Gets or sets the style of <strong>HeatLayer</strong>.
            </summary>
            <remarks>
            If this property is not set, it will use the default HeatStyle.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.HeatLayer.UpperScale">
            <summary>Specifies the upper threshold of the layer.</summary>
            <remarks>
            	<para>The HeatLayer only displays when the currentScale is less than or equal to UpperScale and greater than or equal
                to <strong>LowerScale</strong>, otherwise it won't show anything.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.HeatLayer.LowerScale">
            <summary>Specifies the lower threshold of the layer.</summary>
            <remarks>
            	<para>The HeatLayer only displays when the currentScale is less than or equal to UpperScale and greater than or equal
                to <strong>LowerScale</strong>, otherwise it won't show anything.</para>
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Jpeg2000RasterSource">
            <summary>This class represents the JPEG2000 raster source.</summary>
            <remarks>
            This class allows you to access pictures form an JPEG2000 file. This class is
            typically used in the JPEG2000RasterLayer to allow JPEG2000 raster images to be shown on your map.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.EcwRasterSource">
            <summary>This class represents the ECW raster source.</summary>
            <remarks>
            This class allows you to access pictures from an ECW file. This class is
            typically used in the ECWLayer to allow ECW raster images to be shown on your map.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterSource.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>This is the default constructor and is not typically used.</overloads>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterSource.#ctor(System.String)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <remarks>
            This is typically the constructor you want to use for this class. It allows you
            to pass in the ECW file you wish to work with. Note that the ECW file is not accessed
            or opened until you call the open command of the class.
            </remarks>
            <param name="imagePathFilename">
            This parameter represents the path and file name of the ECW file you want to load
            into the class for display.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterSource.#ctor(System.String,System.String)">
            <summary>
            This is the constructor for the class.
            </summary>
            <remarks>
             It allows you to pass in the ECW file you wish to work with, as well as its corresponding world file.
             Note that the ECW file is not accessed or opened until you call the open command of the class.
            </remarks>
            <param name="imagePathFilename">
            This parameter represents the path and file name of the ECW file you want to load
            into the class for display.
            </param>
            <param name="worldfilePathFilename">The corresponding world file name that contains the world file information.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterSource.#ctor(System.String,ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>
            This is the constructor for the class.
            </summary>
            <remarks>
             It allows you to pass in the ECW file you wish to work with and its corresponding extent.
             Note that the ECW file is not accessed or opened until you call the open command of the class.
            </remarks>
            <param name="imagePathFilename">
            This parameter represents the path and file name of the ECW file you want to load
            into the class for display.
            </param>
            <param name="imageExtent">The corresponding world extent, which can calculate out the world information with the help of width and height from the ECW file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterSource.GetProjectionTextCore">
            <summary>
            This method returns the projection text in proj4 format.
            </summary>
            <returns>Projection text string.</returns>
            <remarks>
            	<para>This protected virtual method is called from the concrete public method
                GetProjectionText.</para>
            	<para>The default implementation of this core method is to load the projection
                information from the ECW file and return the projection information in proj4
                projection string format.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterSource.GetImageWidthCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a raster source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the width of the raster image in screen coordinates.</summary>
            <returns>This method returns the width of the raster image in screen coordinates.</returns>
            <remarks>This method returns the width of the raster image in screen coordinates.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterSource.GetImageHeightCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a raster source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the height of the raster image in screen coordinates.</summary>
            <returns>This method returns the height of the raster image in screen coordinates.</returns>
            <remarks>This method returns the height of the raster image in screen coordinates.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterSource.OpenCore">
            <summary>
            This method opens the ImageSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concrete public method Open.
            The Open method plays an important role, as it is responsible for initializing the
            ImageSource. Most methods on the ImageSource will throw an exception if the state of
            the ImageSource is not opened. When the map draws each layer, it will open the
            ImageSource as one of its first steps; then, after it is finished drawing with that
            layer, it will close it. In this way, we are sure to release all resources used by the
            ImageSource.<br/>
            	<br/>
            When implementing this abstract method, consider opening files for file based-sources,
            connecting to databases in the database-based sources and so on. You will get a chance
            to close these in the Close method of the ImageSource.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a raster source which has already been opened, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterSource.CloseCore">
            <summary>
            This method opens the ImageSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concrete public method Close.
            The Close method plays an important role in the life cycle of the ImageSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed FeatureSource is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterSource.GetImageCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass in a worldExtent that is invalid, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a worldExtent that is invalid, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a raster image width that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a raster image height that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a raster source which has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method is responsible for returning the image based on the parameters passed
            in.
            </remarks>
            <summary>
            This method returns an image based on the worldExtent and raster image width and
            height.
            </summary>
            <returns>
            This method returns an image based on the worldExtent and raster image width and
            height.
            </returns>
            <param name="worldExtent">This parameter represents the worldExtent you want to draw.</param>
            <param name="canvasWidth">This parameter represents the width of the raster image you want to draw.</param>
            <param name="canvasHeight">This parameter represents the height of the raster image you want to draw.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EcwRasterSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the RasterSource.</summary>
            <returns>This method returns the bounding box of the RasterSource.</returns>
            <remarks>This method returns the bounding box of the RasterSource.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.EcwRasterSource.PathFilename">
            <summary>
            This property gets or sets the file name and path of the ECW raster image you are
            working with.
            </summary>
            <decimalDegreesValue>
            This property returns the file name and path of the ECW raster image you are working
            with.
            </decimalDegreesValue>
            <remarks>
            If you wish to change the file the class is working with, you would change
            it here. You cannot change the file you are working with while the class is in an open
            state.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a raster source which has been opened, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.EcwRasterSource.HasProjectionTextCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a raster source which is not open, it will throw an InvalidOperationException.</exception>
            <summary>
            This property returns true if the RasterSource has projection text, false if it does not.
            </summary>
            <remarks>
            	<para>This protected virtual method is called from the concrete public property
                HasProjectionText. Thus, if
                you inherit RasterSource, please ensure that you override this virtual property to return
                the correct projection status of your raster source.</para>
            	<para></para>
            	<para>We will check the HasProjectionText status before you call the
                GetProjectionText method. It will throw an exception if the HasProjectionText
                property returns false.</para>
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Jpeg2000RasterSource.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>This is the default constructor and is not typically used.</overloads>
            If you use this constructor then you need to set the properties
            manually before using the source.
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Jpeg2000RasterSource.#ctor(System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and file information for the JPEG2000RasterSource
            file.`
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the RasterSource ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and file name of the file you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Jpeg2000RasterSource.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and file information and world file information for the JPEG2000RasterSource
            file.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the RasterSource ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and file name of the file you want to use.</param>
            <param name="worldFilePathFilename">This parameter is the path and file name of the world file you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Jpeg2000RasterSource.#ctor(System.String,ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the file and path information and extent information for the JPEG2000RasterSource
            file.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the RasterSource ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and file name of the ECW file you want to use.</param>
            <param name="imageExtent">This parameter is the image extent of ECW file you want to use.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GISDataOper">
            <summary>
            Private function class of GISDataOper
            </summary>
            <summary>
            The static class is used to convert and operate the data of GISSystem
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISDataOper.Pj_Geocentric_To_Geodetic(System.Double,System.Double,System.Int64,System.Int32,ThinkGeo.MapSuite.Core.ProjUV[],System.Double[],System.Int32@)">
            <summary>
            geocentric projection transform to geodetic projection 
            </summary>
            <param name="a">Major axis or radius if es==0</param>
            <param name="es">e^2</param>
            <param name="point_count">Point count</param>
            <param name="point_offset">point offset</param>
            <param name="height">Height of geocentic</param>
            <param name="uvList">Data of transformation</param>
            <returns>Changed data</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISDataOper.Pj_Get_Geocentric_Parameters(ThinkGeo.MapSuite.Core.GeocentricInfo,System.Double,System.Double)">
            <summary>
            obtain instance of GeocentricInfo
            </summary>
            <param name="a">variables a</param>
            <param name="b">variables b</param>
            <returns>instance of GeocentricInfo</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISDataOper.Pj_Convert_Geocentric_To_Geodetic(ThinkGeo.MapSuite.Core.GeocentricInfo,System.Double,System.Double,System.Double,ThinkGeo.MapSuite.Core.ProjUV[],System.Double[],System.Int64,System.Int32@)">
            <summary>
            convert geocentric projection to geodetic projection
            </summary>
            <param name="gi">GeocentricInfo object</param>
            <param name="x">double value x</param>
            <param name="y">double value y</param>
            <param name="z">double value z</param>
            <param name="uv">conversing point</param>
            <param name="height">double array for height</param>
            <param name="io">long value specified offset value</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISDataOper.Pj_Inv(ThinkGeo.MapSuite.Core.XY,ThinkGeo.MapSuite.Core.ProjType,System.Int32@)">
            <summary>
            inverse transform function for frame
            </summary>
            <param name="xy">XY object conversing point</param>
            <param name="p">ProjType object projection</param>
            <returns>LP object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISDataOper.CheckReturn(System.Double[],System.Boolean,System.Int32@)">
            <summary>
            check the height is the temporary or not
            </summary>
            <param name="height">double array</param>
            <param name="z_is_temp">bool</param>
            <returns>bool</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISDataOper.Pj_Transform(ThinkGeo.MapSuite.Core.ProjType,ThinkGeo.MapSuite.Core.ProjType,System.Int64,System.Int32,System.Double[],ThinkGeo.MapSuite.Core.ProjUV[],System.Int32@)">
            <summary>
            The mutual transformation of different coordinate systems
            </summary>
            <param name="srcdefn">source projection</param>
            <param name="dstdefn">destination projection</param>
            <param name="point_count">point count</param>
            <param name="point_offset">point offset</param>
            <param name="height">height of transformation</param>
            <param name="uvList">data list of transformation</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISDataOper.ComposePara(System.String[])">
            <summary>
            compose the Mapsuiteprojection system's parameter
            </summary>
            <param name="args">the string array of arguments</param>
            <returns>the collection has been generated by string</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISDataOper.AppendParaToParas(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            append the argument for the paras collection
            </summary>
            <param name="paras">the collection generated by string</param>
            <param name="arg">the string argument</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISDataOper.Pj_Datum_Transform(ThinkGeo.MapSuite.Core.ProjType,ThinkGeo.MapSuite.Core.ProjType,System.Int64,System.Int32,ThinkGeo.MapSuite.Core.ProjUV[],System.Double[],System.Int32@)">
            <summary>
            Datum of source projection converted for the datum of destination projection
            </summary>
            <param name="srcdefn">Source projection object</param>
            <param name="dstdefn">Destination projection object</param>
            <param name="point_count">Point count</param>
            <param name="point_offset">Point offset</param>
            <param name="uvList">Data of transformation</param>
            <param name="height">Height of transformation</param>
            <returns>If the transformation successful return 0,otherwise return 1</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType">
            <summary>This enumeration represents the type of ExcutingSqlStatement.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.Unknow">
            <summary>Default value of this enumation, it has no idea of what type of ExcutingSqlStatement is for now.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.GetFeaturesByIds">
            <summary> This value shows the type of ExcutingSqlStatement is GetFeauturesByIds.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.CommitTransaction">
            <summary> This value shows the type of ExcutingSqlStatement is CommitTransaction.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.GetFeaturesInsideBoundingBox">
            <summary> This value shows the type of ExcutingSqlStatement is GetFeaturesInsideBoundingBox.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.GetFeaturesOutsideBoundingBox">
            <summary> This value shows the type of ExcutingSqlStatement is GetFeaturesOutsideBoundingBox.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.GetSpatialDataType">
            <summary> This value shows the type of ExcutingSqlStatement is GetSpatialDataType.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.GetBoundingBox">
            <summary> This value shows the type of ExcutingSqlStatement is GetBoundingBox.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.GetAllFeatures">
            <summary> This value shows the type of ExcutingSqlStatement is GetAllFeatures.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.GetCount">
            <summary> This value shows the type of ExcutingSqlStatement is GetCount.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.GetColumns">
            <summary> This value shows the type of ExcutingSqlStatement is GetColumns.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.BuildIndex">
            <summary> This value shows the type of ExcutingSqlStatement is BuildIndex.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.ExecuteScalar">
            <summary> This value shows the type of ExcutingSqlStatement is ExecuteScalar.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.ExecuteQuery">
            <summary> This value shows the type of ExcutingSqlStatement is ExecuteQuery.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.ExecuteNonQuery">
            <summary> This value shows the type of ExcutingSqlStatement is ExecuteNonQuery.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.GetFirstGeometryType">
            <summary> This value shows the type of ExcutingSqlStatement is GetFirstGeometryType.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.MakeAllGeometriesValid">
            <summary> This value shows the type of ExcutingSqlStatement is MakeAllGeometriesValid.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.Validate">
            <summary> This value shows the type of ExcutingSqlStatement is Validate.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.CommitTransactionEx">
            <summary> This value shows the type of ExcutingSqlStatement is CommitTransaction.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.GetFeaturesInsideBoundingBoxEx">
            <summary> This value shows the type of ExcutingSqlStatement is GetFeaturesInsideBoundingBox.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ExecutingSqlStatementType.Unknown">
            <summary>Default value of this enumation, it has no idea of what type of ExcutingSqlStatement is for now.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LayersDrawingEventArgs">
            <summary>
            This is the event arguments class for the LayersDrawing event on the MapEngine class. It
            is raised before any of the layers are drawn.
            </summary>
            <remarks>
            This is the event arguments class for the LayersDrawing event on the MapEngine class. It
            is raised before any of the layers are drawn. This event allows you to cancel, manipulate the
            Layer, or draw something with the canvas before the Layer draws.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LayersDrawingEventArgs.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LayersDrawingEventArgs.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Layer},ThinkGeo.MapSuite.Core.RectangleShape,System.Object)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to set the layers to be drawn, the world extent, and
            the image you are drawing on.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="layers">This parameter is the layers that will be drawn.</param>
            <param name="worldExtent">This parameter is the world extent you are drawing.</param>
            <param name="nativeImage">This parameter is the GeoImage or native map image.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LayersDrawingEventArgs.Cancel">
            <summary>
            This property gets and sets the value that indicates you want to cancel all of the layers from
            drawing.
            </summary>
            <value>This property gets the value that indicates you want to cancel all of the layers from drawing.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LayersDrawingEventArgs.WorldExtent">
            <summary>This property gets and sets the world extent that will be drawn.</summary>
            <value>This property gets the world extent that will be drawn.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LayersDrawingEventArgs.NativeImage">
            <summary>
            This property gets and sets the GeoImage or native image that we are drawing
            on.
            </summary>
            <value>This property gets the GeoImage or native image that we are drawing on.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LayersDrawingEventArgs.Layers">
            <summary>This property gets and sets the layers you will be drawing.</summary>
            <value>This property gets the layers you will be drawing.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LayerDrawingEventArgs">
            <summary>
            This is the event arguments class for the LayerDrawing event on the MapEngine class. It
            is raised before the layer is drawn.
            </summary>
            <remarks>
            This is the event arguments class for the LayerDrawing event on the MapEngine class. It
            is raised before the layer is drawn. This event allows you to cancel, manipulate the
            Layer, or draw something with the canvas before the Layer draws.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LayerDrawingEventArgs.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LayerDrawingEventArgs.#ctor(ThinkGeo.MapSuite.Core.Layer,ThinkGeo.MapSuite.Core.RectangleShape,System.Object)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to set the Layer to be drawn, the world extent, and
            the image you are drawing on.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="currentLayer">This parameter is the layer you will be drawing.</param>
            <param name="worldExtent">This parameter is the world extent you are drawing.</param>
            <param name="nativeImage">This parameter is the GeoImage or native map image.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LayerDrawingEventArgs.Cancel">
            <summary>
            This property gets and sets the value that indicates you want to cancel the layer from
            drawing.
            </summary>
            <value>This property gets the value that indicates you want to cancel the layer from drawing.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LayerDrawingEventArgs.CurrentLayer">
            <summary>This property gets and sets current layer that will be drawn.</summary>
            <value>This property gets current layer that will be drawn.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LayerDrawingEventArgs.WorldExtent">
            <summary>This property gets and sets the world extent that will be drawn.</summary>
            <value>This property gets the world extent that will be drawn.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LayerDrawingEventArgs.NativeImage">
            <summary>
            This property gets and sets the GeoImage or native image that we are drawing
            on.
            </summary>
            <value>This property gets the GeoImage or native image that we are drawing on.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ValueItem">
            <summary>This class represents a single value to match and styles to draw.</summary>
            <remarks>
            Value Style:<br/>
            	<br/>
            The ValueStyle allows you to match data in the FeatureSource against a value string. If
            the value matches, then we will use the style defined in that item to do the drawing.
            For example, let's say you have some data that contains states, and each state is categorized as either a high,
            medium or low pollution state. Based on the string values of "High", Medium" and "Low",
            we can match on these. If a feature's data for the column matched the string "High", then
            we would use the high ValueItem's styles to draw that feature. This can be applied to all
            kinds of things, such as road classifications, etc.<br/>
            	<br/>
            This can be somewhat slow because we have to match data from the FeatureSource. If
            performance is key, then instead of using the ValueStyle, we recommend that you create a set
            custom index for your layer, one index with only "High" elements, one for "Medium" and so on.
            Then load each as a separate layer. In this way, you would only have one data set, but
            multiple indexes. This is the fastest way if you are working with Shape Files. If you are
            working with spatial databases, then we suggest creating a view to segment out each
            category.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ValueItem.#ctor">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <overloads>
            If you use this constructor, you should set the necessary properties
            manually.
            </overloads>
            <remarks>
            If you use this constructor, you should set the necessary properties
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ValueItem.#ctor(System.String,ThinkGeo.MapSuite.Core.AreaStyle)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify an AreaStyle you want to use. You should
            use this if the features you are drawing are area-based. Alternatively, you can set the
            properties of the DefaultAreaSytle directly on the class.
            </overloads>
            <returns>None</returns>
            <remarks>
            It is recommended that you do not use this constructor unless it is absolutely necessary.
            Instead, you can set the properties directly on the DefaultAreaStyle.
            </remarks>
            <param name="value">
            This parameter is the value that will match with the data specified for the
            feature.
            </param>
            <param name="areaStyle">This parameter is the style you want to draw with if the value matches.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ValueItem.#ctor(System.String,ThinkGeo.MapSuite.Core.LineStyle)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify a LineStyle you want to use. You should
            use this if the features you are drawing are line-based. Alternatively, you can set the
            properties of the DefaultLineSytle directly on the class.
            </overloads>
            <returns>None</returns>
            <remarks>
            It is recommended that you do not use this constructor unless it is absolutely necessary.
            Instead, you can set the properties directly on the DefaultLineStyle.
            </remarks>
            <param name="value">
            This parameter is the value that will match with the data specified for the
            feature.
            </param>
            <param name="lineStyle">This parameter is the style you want to draw with if the value matches.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ValueItem.#ctor(System.String,ThinkGeo.MapSuite.Core.PointStyle)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify a PointStyle you want to use. You should
            use this if the features you are drawing are point based. Alternatively, you can set the
            properties of the DefaultPointSytle directly on the class.
            </overloads>
            <returns>None</returns>
            <remarks>
            It is recommended that you do not use this constructor unless it is absolutely necessary.
            Instead, you can set the properties directly on the DefaultPointStyle.
            </remarks>
            <param name="value">
            This parameter is the value that will match with the data specified for the
            feature.
            </param>
            <param name="pointStyle">This parameter is the style you want to draw with if the value matches.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ValueItem.#ctor(System.String,ThinkGeo.MapSuite.Core.TextStyle)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify a TextStyle you want to use. You should
            use this if the features you are drawing are text based. Alternatively, you can set the
            properties of the DefaultTextSytle directly on the class.
            </overloads>
            <returns>None</returns>
            <remarks>
            It is recommended that you do not use this constructor unless it is absolutely necessary.
            Instead, you can set the properties directly on the DefaultTextStyle.
            </remarks>
            <param name="value">
            This parameter is the value that will match with the data specified for the
            feature.
            </param>
            <param name="textStyle">This parameter is the style you want to draw with if the value matches.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ValueItem.#ctor(System.String,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.Style})">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify a group of CustomStyles you want to use. You can add the potential AreaStyle,
            LineStyle, or PointStyle to the CustomStyles to draw areas, lines and points separately.
            </overloads>
            <returns>None</returns>
            <param name="value">
            This parameter is the value that will match with the data specified for the
            feature.
            </param>
            <param name="customStyles">This parameter represents the styles you want to draw with if the value matches.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ValueItem.Value">
            <summary>
            This property gets and sets the value that we use to match with the feature data.
            If the value matches, we use the style for this item.
            </summary>
            <value>This property gets the value that we use to match with the feature data.</value>
            <remarks>
            The value must match exactly. If more complex matching is required, we
            suggest you use the RegexStyle. The RegexStyle enables you to use regular expressions,
            which are very powerful for fuzzy matching.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ValueItem.DefaultAreaStyle">
            <summary>
            This property gets and sets the default AreaStyle. You should use this style if
            your features are area-based.
            </summary>
            <value>This property gets the default AreaStyle.</value>
            <remarks>
            The default style allows you to directly set properties on the styles without
            having to create a new style each time. You can start simply by setting properties like color, etc.
            This makes modifying styles very easy.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ValueItem.DefaultLineStyle">
            <summary>
            This property gets and sets the default LineStyle. You should use this style if
            your features are line-based.
            </summary>
            <value>This property gets the default LineStyle.</value>
            <remarks>
            The default style allows you to directly set properties on the styles without
            having to create a new style each time. You can start simply by setting properties like color, etc.
            This makes modifying styles very easy.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ValueItem.DefaultPointStyle">
            <summary>
            This property gets and sets the default PointStyle. You should use this style if
            your features are point-based.
            </summary>
            <value>This property gets the default LineStyle.</value>
            <remarks>
            The default style allows you to directly set properties on the styles without
            having to create a new style each time. You can start simply by setting properties like color, etc.
            This makes modifying styles very easy.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ValueItem.DefaultTextStyle">
            <summary>
            This property gets and sets the default TextStyle. You should use this style if
            your features are text-based (such as labels).
            </summary>
            <value>This property gets the default TextStyle.</value>
            <remarks>
            The default style allows you to directly set properties on the styles without
            having to create a new style each time. You can start simply by setting properties like color, etc.
            This makes modifying styles very easy.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ValueItem.CustomStyles">
            <summary>This property gets the collection of custom styles.</summary>
            <value>This property gets the collection of custom styles.</value>
            <remarks>
            The custom styles allow you to use styles other than the default style
            properties of the class. In this way, you can use a DotDensityStyle or any other style in the
            API.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ZoomLevel">
            <summary>This class defines how InternalFeatures will be drawn based on their scale.</summary>
            <remarks>
            This class defines how InternalFeatures will be drawn based on their scale. Inside of the
            ZoomLevelSet there are a number of zoom levels. We will determine which ZoomLevel to
            use based on which one has the Scale property closest to the current scale. The
            matching one will define the styles that will be used to draw the InternalFeatures on the
            map.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ZoomLevel.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, you should set the
            require properties on the class manually.
            </overloads>
            <remarks>
            This is the default constructor. If you use this constructor, you should set the
            require properties on the class manually.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ZoomLevel.#ctor(System.Double)">
            <summary>This is a constructor for the class.</summary>
            <overloads>This constructor allows you to provide the scale for this ZoomLevel.</overloads>
            <returns>None</returns>
            <remarks>This constructor allows you to provide the scale for this ZoomLevel.</remarks>
            <param name="scale">This paramter is the scale for the ZoomLevel.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ZoomLevel.GetRequiredColumnNames">
            <remarks>
            In this method, we return the column names that are required for the styles to
            draw the feature properly. For example, if you have a style that colors areas blue when
            a certain column value is over 100, then you need to be sure you include the column
            name. This will ensure that the column data is returned to you in the feature when it
            is ready to draw.<br/>
            	<br/>
            In many of the styles, we add properties to allow the user to specify which field they
            need; then, in the GetRequiredColumnNamesCore, we read that property and add it to the
            collection.
            </remarks>
            <summary>
            This method returns the column data for each feature that is required for the
            styles to properly draw.
            </summary>
            <returns>This method returns a collection containing the required column names.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ZoomLevel.Draw(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the ZoomLevel.</summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method DrawCore. This
                method draws the representation of the Layer based on the extent you provided.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <param name="canvas">This parameter is the Canvas used to draw the InternalFeatures.</param>
            <param name="features">This parameter is the collection of features that we will draw.</param>
            <param name="currentLayerLabels">This parameter is the collection of labels in the current layer.</param>
            <param name="allLayerLabels">This parameter is the collection of labels in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ZoomLevel.Draw(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.BaseShape},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the ZoomLevel.</summary>
            <returns>None</returns>
            <remarks>
            	<para>This method is the concrete wrapper for the abstract method DrawCore. This
                method draws the representation of the Layer based on the extent you provided.<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <param name="canvas">This parameter is the Canvas used to draw the InternalFeatures.</param>
            <param name="shapes">This parameter is the collection of shapes that we will draw.</param>
            <param name="currentLayerLabels">This parameter is the collection of labels in the current layer.</param>
            <param name="allLayerLabels">This parameter is the collection of labels in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ZoomLevel.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the ZoomLevel.</summary>
            <returns>None</returns>
            <remarks>
            This method draws the representation of the Layer based on the extent you
            provided.
            </remarks>
            <param name="canvas">This parameter is the Canvas used to draw the InternalFeatures.</param>
            <param name="features">This parameter is the collection of feature that we will draw.</param>
            <param name="currentLayerLabels">This parameter is the collection of labels in the current layer.</param>
            <param name="allLayerLabels">This parameter is the collection of labels in all layers.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevel.IsActive">
            <summary>This property gets and sets whether the ZoomLevel is active and should draw.</summary>
            <value>This property gets whether the ZoomLevel is active and should draw.</value>
            <remarks>
            Setting the value to false means that this zoom level will not be considered
            in the ZoomLevelSet and thus will not draw.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevel.Scale">
            <summary>This property gets and sets the scale for the ZoomLevel.</summary>
            <value>This property gets and sets the scale for the ZoomLevel.</value>
            <remarks>The scale</remarks>
            <requirements>
            The scale is the ratio of a single unit of distance on the map to the equivalent
            distance on the ground. For example, a scale of 1:1 means that one foot on the ground
            would be displayed as one foot on the screen. A scale of 1:1,000 means that one foot on
            the screen is equal to 1,000 feet on the ground.
            </requirements>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevel.DefaultAreaStyle">
            <summary>This property gets and sets the default AreaStyle used to draw.</summary>
            <value>This property gets the default AreaStyle used to draw.</value>
            <remarks>
            If you set this style, then it will be used for drawing.<br/>
            	<br/>
            If you use the default styles, you should only use one. The one you use should
            match your feature data. For example, if your features are lines, then you should use the
            DefaultLineStyle.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevel.DefaultLineStyle">
            <summary>This property gets and sets the default LineStyle used to draw.</summary>
            <value>This property gets the default LineStyle used to draw.</value>
            <remarks>
            If you set this style, then it will be used for drawing.<br/>
            	<br/>
            If you use the default styles, you should only use one. The one you use should
            match your feature data. For example, if your features are lines, then you should use the
            DefaultLineStyle.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevel.DefaultPointStyle">
            <summary>This property gets and sets the default PointStyle used to draw.</summary>
            <value>This property gets the default PointStyle used to draw.</value>
            <remarks>
            If you set this style, then it will be used for drawing.<br/>
            	<br/>
            If you use the default styles, you should only use one. The one you use should
            match your feature data. For example, if your features are lines, then you should use the
            DefaultLineStyle.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevel.DefaultTextStyle">
            <summary>This property gets and sets the default TextStyle used to draw.</summary>
            <value>This property gets the default TextStyle used to draw.</value>
            <remarks>
            If you set this style, then it will be used for drawing.<br/>
            	<br/>
            If you use the default styles, you should only use one. The one you use should
            match your feature data. For example, if your features are lines, then you should use the
            DefaultLineStyle.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevel.ApplyUntilZoomLevel">
            <summary>
            This property gets and sets the zoom to which we will use this zoom level's
            styles.
            </summary>
            <value>This property gets the zoom to which we will use this zoom level's styles.</value>
            <remarks>
            This property allows you to apply the current ZoomLevel's styles across many
            ZoomLevels. For example, you may want to display roads as a thin line from
            ZoomLevel10 through ZoomLevel15. To accomplish this easily, you can set the correct styles
            on ZoomLevel10 and then set its ApplyUntilZoomLevel property to Level15. This will mean
            that Level10's style will be used until Level15. There is no need to set Level11,
            Level12, Level13 and so on.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevel.Name">
            <summary>This property gets and sets the name for the ZoomLevel.</summary>
            <value>This property gets the name for the ZoomLevel.</value>
            <remarks>
            The name is user defined. It is useful to set, as it may be used for higher level
            components such as legends, etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ZoomLevel.CustomStyles">
            <summary>This property gets a collection of custom styles used to draw.</summary>
            <value>This property gets a collection of custom styles used to draw.</value>
            <remarks>
            This is a collection of styles to draw. If you only need to draw one style, then
            we suggest you do not use this collection and instead use one of the default styles, such as
            DefaultAreaStyle, DefaultLineStyle, DefaultTextStyle, etc.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.StreamLoadingEventArgs">
            <summary>This class represents the event arguments for the StreamLoading event.</summary>
            <remarks>
            Alternate Streams<br/>
            	<br/>
            Where possible we allow you to use stream in place of concreate files on the file
            system. This gives you the flexibility to retrieve data from isolated storage,
            encrypted files, compressed files, fast memory streams or any other stream origin. This
            is typically available where you would pass in a path and file name. Streams can be
            substituted in a number of places such as images, shape files etc. Below describes how
            the system works though specific places may have slightly different variations.<br/>
            	<br/>
             You will create the object that will use the stream normally such as a
            ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these classes
            you typically need to supply a path and file name, while this is still required you can
            pass in a valid path that does not exist such as "Z:\ShapeFile1.shp". When we need the
            stream from you we will give you this string so you can find the associated stream. In
            essence you can use the path and file name as a key to kink to the source of your
            stream.<br/>
            	<br/>
             When we need the file we will raise the StreamLoading event and allow you to pass an
            alternate stream. In the StreamLoading event we provide you with the path and file name
            you used and we expect for you to create the stream and set it as the AlternatStream
            property along with setting the FileMode and File access appropriate to the stream.
            This helps us know our limits with the stream.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.StreamLoadingEventArgs.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This is the default constructor taking no arguments which is typically not
            used.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor taking no arguments which is typically not
            used.<br/>
            	<br/>
            Alternate Streams<br/>
            	<br/>
            Where possible we allow you to use stream in place of concreate files on the file
            system. This gives you the flexibility to retrieve data from isolated storage,
            encrypted files, compressed files, fast memory streams or any other stream origin. This
            is typically available where you would pass in a path and file name. Streams can be
            substituted in a number of places such as images, shape files etc. Below describes how
            the system works though specific places may have slightly different variations.<br/>
            	<br/>
             You will create the object that will use the stream normally such as a
            ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these classes
            you typically need to supply a path and file name, while this is still required you can
            pass in a valid path that does not exist such as "Z:\ShapeFile1.shp". When we need the
            stream from you we will give you this string so you can find the associated stream. In
            essence you can use the path and file name as a key to kink to the source of your
            stream.<br/>
            	<br/>
             When we need the file we will raise the StreamLoading event and allow you to pass an
            alternate stream. In the StreamLoading event we provide you with the path and file name
            you used and we expect for you to create the stream and set it as the AlternatStream
            property along with setting the FileMode and File access appropriate to the stream.
            This helps us know our limits with the stream.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.StreamLoadingEventArgs.#ctor(System.String,System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)">
            <summary>This is the constructor for the class.</summary>
            <overloads>This is the constructor we suggest you you when creating this class.</overloads>
            <remarks>
            This is the constructor we suggest you you when creating this class.<br/>
            	<br/>
            Alternate Streams<br/>
            	<br/>
            Where possible we allow you to use stream in place of concreate files on the file
            system. This gives you the flexibility to retrieve data from isolated storage,
            encrypted files, compressed files, fast memory streams or any other stream origin. This
            is typically available where you would pass in a path and file name. Streams can be
            substituted in a number of places such as images, shape files etc. Below describes how
            the system works though specific places may have slightly different variations.<br/>
            	<br/>
             You will create the object that will use the stream normally such as a
            ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these classes
            you typically need to supply a path and file name, while this is still required you can
            pass in a valid path that does not exist such as "Z:\ShapeFile1.shp". When we need the
            stream from you we will give you this string so you can find the associated stream. In
            essence you can use the path and file name as a key to kink to the source of your
            stream.<br/>
            	<br/>
             When we need the file we will raise the StreamLoading event and allow you to pass an
            alternate stream. In the StreamLoading event we provide you with the path and file name
            you used and we expect for you to create the stream and set it as the AlternatStream
            property along with setting the FileMode and File access appropriate to the stream.
            This helps us know our limits with the stream.
            </remarks>
            <returns>None</returns>
            <param name="alternateStreamName">
            This parameter represents the key string you will use to find the stream on the
            client end.
            </param>
            <param name="alternateStream">
            This parameter should be set in the event by the user to represent the alternate
            stream.
            </param>
            <param name="fileMode">
            This parameter should be set in the event by the user to represent the file mode
            that the alternate stream need to function as.
            </param>
            <param name="fileAccess">
            This parameter should be set in the event by the user to represent the file
            access that the alternate stream need to function as.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StreamLoadingEventArgs.AlternateStreamName">
            <summary>
            This property gets or sets the source of the stream you wish the user to pass
            you.
            </summary>
            <remarks>
            	<para>This is always set by the person who created the event arguments and should
                not be changed by the user.<br/>
            		<br/>
                The streamSource name just needs to be some unique string that will let the user
                know which file or stream you want. For example you could have a streamSourceName
                of "Z:\test.shp" and though the Z drive might not exist it might be a cue for you
                to load "test.shp" from isolated storage. We suggest you use a string that is in
                the file format of "?:\????.???" as this allows is to validate it though we do not
                check if it exists.<br/>
            		<br/>
                Alternate Streams<br/>
            		<br/>
                Where possible we allow you to use stream in place of concreate files on the file
                system. This gives you the flexibility to retrieve data from isolated storage,
                encrypted files, compressed files, fast memory streams or any other stream origin.
                This is typically available where you would pass in a path and file name. Streams
                can be substituted in a number of places such as images, shape files etc. Below
                describes how the system works though specific places may have slightly different
                variations.<br/>
            		<br/>
                 You will create the object that will use the stream normally such as a
                ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these
                classes you typically need to supply a path and file name, while this is still
                required you can pass in a valid path that does not exist such as
                "Z:\ShapeFile1.shp". When we need the stream from you we will give you this string
                so you can find the associated stream. In essence you can use the path and file
                name as a key to kink to the source of your stream.<br/>
            		<br/>
                 When we need the file we will raise the StreamLoading event and allow you to pass
                an alternate stream. In the StreamLoading event we provide you with the path and
                file name you used and we expect for you to create the stream and set it as the
                AlternatStream property along with setting the FileMode and File access appropriate
                to the stream. This helps us know our limits with the stream.</para>
            </remarks>
            <decimalDegreesValue>
            This property gets source of the stream you wish the user to pass you as a
            string.
            </decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StreamLoadingEventArgs.AlternateStream">
            <summary>This property gets and sets the alternate stream you want to use.</summary>
            <decimalDegreesValue>This property gets the alternate stream you want to use.</decimalDegreesValue>
            <remarks>
            When the event is raised the user should be responsible for either ignoring this
            property or setting it. It should default to null and if the user wishes to use an
            alternate stream instead of a file from the disk then they should replace it
            here.<br/>
            	<br/>
            Alternate Streams<br/>
            	<br/>
            Where possible we allow you to use stream in place of concreate files on the file
            system. This gives you the flexibility to retrieve data from isolated storage,
            encrypted files, compressed files, fast memory streams or any other stream origin. This
            is typically available where you would pass in a path and file name. Streams can be
            substituted in a number of places such as images, shape files etc. Below describes how
            the system works though specific places may have slightly different variations.<br/>
            	<br/>
             You will create the object that will use the stream normally such as a
            ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these classes
            you typically need to supply a path and file name, while this is still required you can
            pass in a valid path that does not exist such as "Z:\ShapeFile1.shp". When we need the
            stream from you we will give you this string so you can find the associated stream. In
            essence you can use the path and file name as a key to kink to the source of your
            stream.<br/>
            	<br/>
             When we need the file we will raise the StreamLoading event and allow you to pass an
            alternate stream. In the StreamLoading event we provide you with the path and file name
            you used and we expect for you to create the stream and set it as the AlternatStream
            property along with setting the FileMode and File access appropriate to the stream.
            This helps us know our limits with the stream.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StreamLoadingEventArgs.FileMode">
            <summary>
            This property gets and sets the file mode that the alternate stream need to
            function as.
            </summary>
            <decimalDegreesValue>
            This property gets the file mode that the alternate stream need to function
            as.
            </decimalDegreesValue>
            <remarks>
            You should set the file mode to the mode that best describes the limitations
            inherent to your alternate stream.<br/>
            	<br/>
            Alternate Streams<br/>
            	<br/>
            Where possible we allow you to use stream in place of concreate files on the file
            system. This gives you the flexibility to retrieve data from isolated storage,
            encrypted files, compressed files, fast memory streams or any other stream origin. This
            is typically available where you would pass in a path and file name. Streams can be
            substituted in a number of places such as images, shape files etc. Below describes how
            the system works though specific places may have slightly different variations.<br/>
            	<br/>
             You will create the object that will use the stream normally such as a
            ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these classes
            you typically need to supply a path and file name, while this is still required you can
            pass in a valid path that does not exist such as "Z:\ShapeFile1.shp". When we need the
            stream from you we will give you this string so you can find the associated stream. In
            essence you can use the path and file name as a key to kink to the source of your
            stream.<br/>
            	<br/>
             When we need the file we will raise the StreamLoading event and allow you to pass an
            alternate stream. In the StreamLoading event we provide you with the path and file name
            you used and we expect for you to create the stream and set it as the AlternatStream
            property along with setting the FileMode and File access appropriate to the stream.
            This helps us know our limits with the stream.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.StreamLoadingEventArgs.FileAccess">
            <remarks>
            You should set the file access to the mode that best describes the limitations
            inherent to your alternate stream.<br/>
            	<br/>
            Alternate Streams<br/>
            	<br/>
            Where possible we allow you to use stream in place of concreate files on the file
            system. This gives you the flexibility to retrieve data from isolated storage,
            encrypted files, compressed files, fast memory streams or any other stream origin. This
            is typically available where you would pass in a path and file name. Streams can be
            substituted in a number of places such as images, shape files etc. Below describes how
            the system works though specific places may have slightly different variations.<br/>
            	<br/>
             You will create the object that will use the stream normally such as a
            ShapeFielFeatureSource and then subscribe to the StreamLoading event. For these classes
            you typically need to supply a path and file name, while this is still required you can
            pass in a valid path that does not exist such as "Z:\ShapeFile1.shp". When we need the
            stream from you we will give you this string so you can find the associated stream. In
            essence you can use the path and file name as a key to kink to the source of your
            stream.<br/>
            	<br/>
             When we need the file we will raise the StreamLoading event and allow you to pass an
            alternate stream. In the StreamLoading event we provide you with the path and file name
            you used and we expect for you to create the stream and set it as the AlternatStream
            property along with setting the FileMode and File access appropriate to the stream.
            This helps us know our limits with the stream.
            </remarks>
            <summary>
            This property gets and sets the file access that the alternate stream need to
            function as.
            </summary>
            <decimalDegreesValue>
            This property gets the file access that the alternate stream need to function
            as.
            </decimalDegreesValue>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ClosedRasterSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the ClosedRasterSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClosedRasterSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.SimpleCandidate">
            <summary>This class stores simple label information used in the PositionStyle.</summary>
            <remarks>
            This class is used in the PositionStyle for storing simple label infromation. It
            has a limited scope.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.SimpleCandidate.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to
            manually set the properties necessary for this class.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, then you need to manually set the properties
            necessary for this class.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.SimpleCandidate.#ctor(System.String,ThinkGeo.MapSuite.Core.PolygonShape)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the original text and the simple polygon
            in screen coordinates.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="originalText">This parameter is the text for the label.</param>
            <param name="simplePolygonInScreenCoordinate">
            This parameter is a polygon in screen coordinates that represents the area of the
            label.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleCandidate.OriginalText">
            <summary>This property gets and sets the text for the label.</summary>
            <value>This property gets the text for the label.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleCandidate.SimplePolygonInScreenCoordinate">
            <summary>
            This property gets and sets the polygon in screen coordinates that represents the
            area of the label.
            </summary>
            <value>
            This property gets the polygon in screen coordinates that represents the area of
            the label.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LabelInformation">
            <summary>
            This class represents the location of a piece of a label that may be
            drawn.
            </summary>
            <remarks>
            This class is used within the labeling logic, specifically in the labeling
            candidate. The object may represent an entire label or, in the case of a label spline,
            a single character in the label.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LabelInformation.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>This is the default constructor.</overloads>
            <remarks>
            If you use this constructor, you should set the various properties
            manually.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LabelInformation.#ctor(ThinkGeo.MapSuite.Core.PointShape,System.String,System.Double)">
            <summary>This is the constructor for the class.</summary>
            <overloads>This constructor allows you to set all of the class properties.</overloads>
            <remarks>None</remarks>
            <returns>None</returns>
            <param name="positionInScreenCoordinates">This parameter is the position of the label that may draw.</param>
            <param name="text">This parameter is the text for the label.</param>
            <param name="rotationAngle">This parameter is the angle of rotation for the label.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LabelInformation.PositionInScreenCoordinates">
            <summary>
            This property gets and sets the position of a piece of a label, in screen
            coordinates.
            </summary>
            <value>
            This property gets the position of a piece of a label, in screen
            coordinates.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LabelInformation.Text">
            <summary>This property gets and sets the text of the label.</summary>
            <value>This property gets the text of the label.</value>
            <remarks>This may be the entire label text or a single character.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LabelInformation.RotationAngle">
            <summary>This property gets and sets the angle of rotation for the label.</summary>
            <value>This property gets the angle of rotation for the label.</value>
            <remarks>
            This could be the rotation of the entire label text, a single character, or a set of
            characters.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MrSidRasterLayer">
            <summary>This class represents a MrSid image to be drawn on the map.</summary>
            <remarks>
            The MrSidRasterLayer represents a MrSid file for drawing on the map. Simply provide
            the path and filename to the MrSid file, add the layer to the MapEngine class and
            start drawing. You can also draw the layer manually outside of the MapEngine.<br/>
            	<br/>
            MrSid:<br/>
            	<br/>
            MrSid is a image compression system developed by LizardTech. It allows you to
            combine and compress large sets of satellite images into a single file. The images can
            be accessed very quickly at a variety of scales. It is very popular in the GIS
            community.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterLayer.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the PathFileName property manually before using the layer.
            </overloads>
            <remarks>
            If you use this constructor then, you need to set the PathFileName property
            manually before using the layer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterLayer.#ctor(System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename information for the MrSid
            file.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and filename of the MrSid file you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterLayer.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename information for both the MrSid image and its world file.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and filename of the MrSid image file you want to use.</param>
            <param name="worldFilePathFilename">This parameter is the world file path and filename for the MrSid image you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterLayer.#ctor(System.String,ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename for the MrSid image file and the
            image extent to use.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and filename of the MrSid image file you want to use.</param>
            <param name="imageExtent">This parameter is the image extent of the MrSid image file you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterLayer.Dispose">
            <summary>
            Release the unmanage resource in RasterSource.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MrSidRasterLayer.PathFilename">
            <summary>
            This property gets and sets the path and filename of the MrSid file you want to
            use.
            </summary>
            <decimalDegreesValue>This property gets the path and filename of the MrSid file you want to use.</decimalDegreesValue>
            <remarks>This should be a complete path and filename for the MrSid file.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MrSidRasterLayer.SuppressClose">
            <summary>
            Gets or sets the SuppressClose property.
            </summary>
            <remarks>If set the SuppressClose to ture, then the RasterSource will not 
            be closed even you call the Close API.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MrSidRasterLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In mrSidRasterLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoLinearGradientBrush">
            <summary>Encapsulates a <strong>GeoBrush</strong> with a linear gradient.</summary>
            <remarks>
            	<para>This class encapsulates both two-color gradients and custom multicolor
                gradients.</para>
            	<para></para>
            	<para>All linear gradients are defined along a line specified either by the width
                of a rectangle or by two points.</para>
            	<para></para>
            	<para>By default, a two-color linear gradient is an even horizontal linear blend
                from the starting color to the ending color along the specified line.</para>
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoBrush">
            <summary>
            Defines objects used to fill the interiors of AreaBaseShapes, such as
            MultiPolygonShape, PolygonShape, EllipseShape, and other AreaBaseShapes.
            </summary>
            <remarks>
            	<para>This is an abstract base class and cannot be instantiated. To create a
                GeoBrush object, use classes derived from GeoBrush, such as GeoSolidBrush.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoBrush.#ctor">
            <summary>This is the constructor for the GeoBrush</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoBrush.CloneDeep">
            <summary>Create a copy of GeoBrush using the deep clone process.</summary>
            <returns>A cloned GeoBrush.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoBrush.CloneDeepCore">
            <summary>Create a copy of GeoBrush using the deep clone process. The default implementation uses serialization.</summary>
            <returns>A cloned GeoBrush.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoBrush.Id">
            <summary>
            The id of the GeoBrush. This is always used as a key when in the cached brushes.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoLinearGradientBrush.#ctor">
            <summary>
            Create a new instance of the GeoLinearGradientBrush with default settings.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoLinearGradientBrush.#ctor(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoLinearGradientDirection)">
            <summary>
            Create an instance of GeoLinearGradientBrush by passing a gradient start color and
            gradient end color followed by the gradient direction enum.
            </summary>
            <param name="startColor">
            This parameter specifies the starting <strong>GeoColor</strong> of the
            <strong>GeoLinearGradientBrush</strong>.
            </param>
            <param name="endColor">
            This parameter specifies the endding <strong>GeoColor</strong> of the
            <strong>GeoLinearGradientBrush</strong>.
            </param>
            <param name="direction">
            This parameter specifies the <strong>GeoLinearGradientDirection</strong>
            enumeration of the <strong>GeoLinearGradientBrush</strong>.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoLinearGradientBrush.#ctor(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>
            Create an instance of GeoLinearGradientBrush by passing a gradient start color and
            gradient end color followed by the gradient direction angle.
            </summary>
            <param name="startColor">
            This parameter specifies the starting <strong>GeoColor</strong> of the
            <strong>GeoLinearGradientBrush</strong>.
            </param>
            <param name="endColor">
            This parameter specifies the endding <strong>GeoColor</strong> of the
            <strong>GeoLinearGradientBrush</strong>.
            </param>
            <param name="directionAngle">
            This parameter specifies the direction angle value of the
            <strong>GeoLinearGradientBrush</strong>.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoLinearGradientBrush.StartColor">
            <summary>Gets or sets the starting <strong>GeoColor</strong> of the gradient.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoLinearGradientBrush.EndColor">
            <summary>Gets or sets the ending <strong>GeoColor</strong> of the gradient.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoLinearGradientBrush.DirectionAngle">
            <summary>
            Gets or sets the Direction angle of the
            <strong>GeoLinearGradientBrush</strong>.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoLinearGradientBrush.WrapMode">
            <summary>
            Gets or sets a <strong>GeoWrapMode</strong> enumeration that indicates the wrap
            mode for the <strong>GeoLinearGradientBrush</strong>.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.QueryType">
            <summary>
            This enumeration specifies the ways you can execute a spatial query against a
            FeatureSource.
            </summary>
            <remarks>
            This enumeration is used on the FeatureSource for the SpatialQuery method and
            reflects all the ways you can compare geometries.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.QueryType.Disjoint">
            <summary>The current shape and the targetShape have no points in common.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.QueryType.Intersects">
            <summary>The current shape and the targetShape have at least one point in common.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.QueryType.Touches">
            <summary>
            The current shape and the targetShape have at least one boundary point in common,
            but no interior points.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.QueryType.Crosses">
            <summary>
            The current shape and the targetShape share some but not all interior
            points.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.QueryType.Within">
            <summary>The current shape lies within the interior of the targetShape.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.QueryType.Contains">
            <summary>The targetShape lies within the interior of the current shape.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.QueryType.Overlaps">
            <summary>
            The current shape and the targetShape share some but not all points in
            common.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.QueryType.TopologicalEqual">
            <summary>The current shape and the target Shape are topologically equal.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileIndex.Open(System.IO.FileAccess)">
            <summary>
            Open Files
            </summary>
            <param name="fileAccess">the name of the Shx file</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileIndex.Close">
            <summary>
            Close all the Files
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.HeaderPage">
            <summary>
            HeaderPage is the page header in memory.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeaderPage.#ctor(ThinkGeo.MapSuite.Core.RtreeFile)">
            <summary>
            Constructor for existing page.
            </summary>
            <param name="rtFile"></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeaderPage.#ctor(ThinkGeo.MapSuite.Core.RtreeFile,System.UInt32,ThinkGeo.MapSuite.Core.Gist_Ext_Id)">
            <summary>
            Constructor for new page.
            </summary>
            <param name="rtFile"></param>
            <param name="pageNo">	page No.			</param>
            <param name="extId">	file type Id		</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeaderPage.Read">
            <summary>
            Read FILE_HEADER
            </summary>
            <returns>
            	true for success  
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeaderPage.Write">
            <summary>
            Write FILE_HEADER
            </summary>
            <returns>
            	true for success  
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.HeaderPage.Dump">
            <summary>
            Dump file header.
            </summary>
            <returns>
            	dumped string 		
            </returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.HeaderPage.FileHeader">
            <summary>
            Property FileHeader
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WfsFeatureSource">
            <summary>This class represents the wfs(web feature service) FeauteSource.</summary>
            <remarks>
            This class allows you to get features from an wfs server. 
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.#ctor">
            <summary>
            WfsFeatureSource Constructor.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.#ctor(System.String,System.String)">
            <summary>
            WfsFeatureSource Constructor
            </summary>
            <remarks>The parameters can not be null.</remarks>
            <param name="serviceLocationUrl">The url of wfs service.</param>
            <param name="typeName">The typename in the specify wfs service.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.OnRequestingData(ThinkGeo.MapSuite.Core.RequestingDataWfsFeatureSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the RequestingData event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            RequestingData event. This may be useful if you plan to extend the FeatureSource
            and you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called before the requesting data by url from wfs server.<br/>
            	<br/>
            </remarks>
            <param name="requestingDataWfsFeatureSourceEventArgs">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.OnRequestedData(ThinkGeo.MapSuite.Core.RequestedDataWfsFeatureSourceEventArgs)">
            <returns>None</returns>
            <summary>
            This method allows you to raise the RequestedData event from a derived
            class.
            </summary>
            <remarks>
            You can call this method from a derived class to enable it to raise the
            RequestedData event. This may be useful if you plan to extend the FeatureSource
            and you need access to the event.<br/>
            	<br/>
            Details on the event:<br/>
            	<br/>
            This event is called after the requesting data by url from wfs server.<br/>
            	<br/>
            </remarks>
            <param name="requestedDataWfsFeatureSourceEventArgs">
            This parameter is the event arguments which define the parameters passed to the
            recipient of the event.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.GetCapabilities(System.String)">
             <summary>
             Get capabilities from the specific wfs service url.
             </summary>
             <returns>The xml text represents capabilities of this wfs server.</returns>
             <remarks><para>Every OGC Web Service (OWS), including a Web Feature Service, must have the ability to describe its capabilities by returning service metadata in response to a GetCapabilities request. Specifically, every web feature service must support the KVP encoded form of the GetCapabilities request over HTTP GET so that a client can always know how to obtain a capabilities document.</para>
             <para>
             The capabilities response document contains the following sections:
            1. Service Identification section
            The service identification section provides information about the WFS service itself.
            2. Service Provider section
            The service provider section provides metadata about the organization operating the WFS server.
            3. Operation Metadata section
            The operations metadata section provides metadata about the operations defined in this specification and implemented by a particular WFS server. This metadata includes the DCP, parameters and constraints for each operation.
            4. FeatureType list section
            This section defines the list of feature types (and operations on each feature type) that are available from a web feature service. Additional information, such as the default SRS, any other supported SRSs, or no SRS whatsoever (for non-spatial feature types), for WFS requests is provided for each feature type.
            5. ServesGMLObjectType list section
            This section defines the list of GML Object types, not derived from gml:AbstractFeatureType, that are available from a web feature service that supports the GetGMLObject operation. These types may be defined in a base GML schema, or in an application schema using its own namespace.
            6. SupportsGMLObjectType list section
            The Supports GML Object Type section defines the list of GML Object types that a WFS server would be capable of serving if it was deployed to serve data.
            described by an application schema that either used those GML Object types directly (for non-abstract types), or defined derived types based on those types.
            7. Filter capabilities section
            The schema of the Filter Capabilities Section is defined in the Filter Encoding Implementation Specification [3]. This is an optional section. If it exists, then the WFS should support the operations advertised therein. If the Filter Capabilities Section is not defined, then the client should assume that the server only supports the minimum default set of filter operators.
             </para>
             </remarks>
             <param name="serviceLocationUrl">The url of wfs service.</param>
             <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If serviceLocationUrl is null, we will throw an ArgumentNullException.</exception>        
             <exception cref="T:System.ArgumentException" caption="ArgumentException">If serviceLocationUrl is empty, we will throw an ArgumentException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.GetCapabilities(System.Uri)">
             <summary>
             Get capabilities from the specific wfs service url.
             </summary>
             <returns>The xml text represents capabilities of this wfs server.</returns>
             <remarks><para>Every OGC Web Service (OWS), including a Web Feature Service, must have the ability to describe its capabilities by returning service metadata in response to a GetCapabilities request. Specifically, every web feature service must support the KVP encoded form of the GetCapabilities request over HTTP GET so that a client can always know how to obtain a capabilities document.</para>
             <para>
             The capabilities response document contains the following sections:
            1. Service Identification section
            The service identification section provides information about the WFS service itself.
            2. Service Provider section
            The service provider section provides metadata about the organization operating the WFS server.
            3. Operation Metadata section
            The operations metadata section provides metadata about the operations defined in this specification and implemented by a particular WFS server. This metadata includes the DCP, parameters and constraints for each operation.
            4. FeatureType list section
            This section defines the list of feature types (and operations on each feature type) that are available from a web feature service. Additional information, such as the default SRS, any other supported SRSs, or no SRS whatsoever (for non-spatial feature types), for WFS requests is provided for each feature type.
            5. ServesGMLObjectType list section
            This section defines the list of GML Object types, not derived from gml:AbstractFeatureType, that are available from a web feature service that supports the GetGMLObject operation. These types may be defined in a base GML schema, or in an application schema using its own namespace.
            6. SupportsGMLObjectType list section
            The Supports GML Object Type section defines the list of GML Object types that a WFS server would be capable of serving if it was deployed to serve data.
            described by an application schema that either used those GML Object types directly (for non-abstract types), or defined derived types based on those types.
            7. Filter capabilities section
            The schema of the Filter Capabilities Section is defined in the Filter Encoding Implementation Specification [3]. This is an optional section. If it exists, then the WFS should support the operations advertised therein. If the Filter Capabilities Section is not defined, then the client should assume that the server only supports the minimum default set of filter operators.
             </para>
             </remarks>
             <param name="serverUri">The url of wfs service.</param>
             <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If serviceLocationUrl is null, we will throw an ArgumentNullException.</exception>        
             <exception cref="T:System.ArgumentException" caption="ArgumentException">If serviceLocationUrl is empty, we will throw an ArgumentException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.GetCapabilities(System.Uri,System.Net.WebProxy)">
             <summary>
             Get capabilities from the specific wfs service url.
             </summary>
             <returns>The xml text represents capabilities of this wfs server.</returns>
             <remarks><para>Every OGC Web Service (OWS), including a Web Feature Service, must have the ability to describe its capabilities by returning service metadata in response to a GetCapabilities request. Specifically, every web feature service must support the KVP encoded form of the GetCapabilities request over HTTP GET so that a client can always know how to obtain a capabilities document.</para>
             <para>
             The capabilities response document contains the following sections:
            1. Service Identification section
            The service identification section provides information about the WFS service itself.
            2. Service Provider section
            The service provider section provides metadata about the organization operating the WFS server.
            3. Operation Metadata section
            The operations metadata section provides metadata about the operations defined in this specification and implemented by a particular WFS server. This metadata includes the DCP, parameters and constraints for each operation.
            4. FeatureType list section
            This section defines the list of feature types (and operations on each feature type) that are available from a web feature service. Additional information, such as the default SRS, any other supported SRSs, or no SRS whatsoever (for non-spatial feature types), for WFS requests is provided for each feature type.
            5. ServesGMLObjectType list section
            This section defines the list of GML Object types, not derived from gml:AbstractFeatureType, that are available from a web feature service that supports the GetGMLObject operation. These types may be defined in a base GML schema, or in an application schema using its own namespace.
            6. SupportsGMLObjectType list section
            The Supports GML Object Type section defines the list of GML Object types that a WFS server would be capable of serving if it was deployed to serve data.
            described by an application schema that either used those GML Object types directly (for non-abstract types), or defined derived types based on those types.
            7. Filter capabilities section
            The schema of the Filter Capabilities Section is defined in the Filter Encoding Implementation Specification [3]. This is an optional section. If it exists, then the WFS should support the operations advertised therein. If the Filter Capabilities Section is not defined, then the client should assume that the server only supports the minimum default set of filter operators.
             </para>
             </remarks>
             <param name="serverUri">The url of wfs service.</param>
             <param name="webProxy">The proxy of the wfs service.</param>
             <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If serviceLocationUrl is null, we will throw an ArgumentNullException.</exception>        
             <exception cref="T:System.ArgumentException" caption="ArgumentException">If serviceLocationUrl is empty, we will throw an ArgumentException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.GetLayers(System.String)">
            <summary>
            Get layer names from specific wfs service url.
            </summary>
            <param name="serviceLocationUrl">The url of wfs service.</param>
            <returns>The collection represent layer names.</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If serviceLocationUrl is null, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If serviceLocationUrl is empty, we will throw an ArgumentException.</exception> 
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.GetLayers(System.Uri)">
            <summary>
            Get layer names from specific wfs service url.
            </summary>
            <param name="serverUri">The url of wfs service.</param>
            <returns>The collection represent layer names.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.GetLayers(System.Uri,System.Net.WebProxy)">
            <summary>
            Get layer names from specific wfs service url.
            </summary>
            <param name="serverUri">The url of wfs service.</param>
            <param name="webProxy">The proxy of the wfs service.</param>
            <returns>The collection represent layer names.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concrete public method Open.
            The Open method plays an important role, as it is responsible for initializing the
            FeatureSource. Most methods on the FeatureSource will throw an exception if the state
            of the FeatureSource is not opened. When the map draws each layer, it will open the
            FeatureSource as one of its first steps, then after it is finished drawing with that
            layer it will close it. In this way we are sure to release all resources used by the
            FeatureSource.<br/>
            	<br/>
            When implementing this virtual method ,consider opening files for file-based sources,
            connecting to databases in the database-based sources and so on. You will get a chance
            to close these in the Close method of the FeatureSource.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.CloseCore">
            <summary>
            This method closes the FeatureSource and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concrete public method Close.
            The close method plays an important role in the life cycle of the FeatureSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed FeatureSource is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state, it will throw a InvalidOperationException.</exception>
            <remarks>
            	<para>This protected virtual method is called from the concrete public method
                GetBoundingBox. It does not take into account any transaction activity, as this is
                the responsibility of the concrete public method GetBoundingBox. In this way, as a
                developer, if you choose to override this method you do not have to consider
                transactions at all.<br/>
            		<br/>
                The default implementation of GetBoundingBoxCore uses the GetAllRecordsCore method
                to calculate the bounding box of the FeatureSource. We strongly recommend that you
                provide your own implementation for this method that will be more efficient.<br/>
            		<br/>
                If you do not override this method, it will get the BoundingBox by calling
                the GetAllFeatureCore method and deriving it from each feature. This is a very
                inefficient way to get the BoundingBox in most data sources. It is highly
                recommended that you override this method and replace it with a highly optimized
                version. For example, in a ShapeFile the BoundingBox is in the main header of the
                file. Similarly, if you are using Oracle Spatial, you can execute a simple query to
                get the BoundingBox of all the records without returning them. In these ways you
                can greatly improve the performance of this method.</para>
            </remarks>
            <summary>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </summary>
            <returns>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.GetColumnsCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the columns available for the FeatureSource.</summary>
            <remarks>
            As this is the virtual core version of the Columns method, it is intended to
            be overridden in inherited version of the class. When overriding, you will be
            responsible for getting a list of all of the columns supported by the FeatureSource. In
            this way, the FeatureSource will know what columns are available and will remove any
            extra columns when making calls to other core methods. For example, if you have a
            FeatureSource that has three columns of information and the user calls a method that
            requests four columns of information (something they can do with custom fields), we will
            first compare what they are asking for to the results of the GetColumnsCore. This
            way we can strip out custom columns before calling other Core methods, which are only
            responsible for returning data in the FeatureSource. For more information on custom
            fields, please see the documentation on OnCustomFieldsFetch.
            </remarks>
            <returns>This method returns the columns available for the FeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.GetFeaturesByIdsCore(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns a collection of InternalFeatures by providing a group of Ids.</summary>
            <returns>This method returns a collection of InternalFeatures by providing a group of Ids.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetAllFeaturesCore. Because of this, if you want a more
            efficient version of this method, then we highly suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids which uniquely identified the InternalFeatures
            in the FeatureSource.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the ids, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.GetFirstFeaturesWellKnownTypeCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the well known type that represents the first feature from FeatureSource.</summary>
            <returns>This method returns the well known type that represents the first feature from FeatureSource.</returns>
            <remarks>
            	<para>This protected virtual method is called from the concrete public method
                GetFirstFeaturesWellKnownType. It does not take into account any transaction activity, as this is the
                responsibility of the concrete public method GetFirstFeaturesWellKnownType. This way, as a developer,
                if you choose to override this method you do not have to consider transactions at
                all.<br/>
            		<br/>
                The default implementation of GetCountCore uses the GetAllRFeaturesCore method to
                get WellKnownType of the first feature from all features. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient.<br/>
            		<br/>
                If you do not override this method, it will get the count by calling the
                GetAllFeaturesCore method and get WellKnownType of the first feature from all features. This is a very inefficient way
                to get the count in most data sources. It is highly recommended that you override
                this method and replace it with a highly optimized version. For example, in a
                ShapeFile the record count is in the main header of the file. Similarly, if you are
                using Oracle Spatial, you can execute a simple query to get the count of all of the
                records without returning them. In these ways you can greatly improve the
                performance of this method.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.GetAllFeaturesCore(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. You will not need
            to consider anything about pending transactions as this will be handled in the non Core
            version of the method.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We wanted as the framework developers to provide you
            the user with as much default virtual implementation as possible. To do this we needed
            a way to get access to all of the features. For example, we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all the records then we can brute force
            the answer. In this way if you inherited form this class and only implemented this one
            method we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource
            it comes with a price. The price is that it is very inefficient. In the case we just
            discussed about finding all of the InternalFeatures in a bounding box we would not want to look
            at every record to fulfil this method. Instead we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be fast. For
            example in Oracle Spatial there is a specific SQL statement to do this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. It will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.
            </remarks>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WfsFeatureSource.GetFeaturesInsideBoundingBoxCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource that are inside of the
            specified bounding box.
            </summary>
            <returns>
            The returned decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource that are inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions, as this is handled by the concrete version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesInsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding box. We
            strongly recommend that you provide your own implementation for this method that will
            be more efficient. That is especially important for this method, as many other default
            virtual methods use this for their calculations. When you override this method, we highly recommend
            that you use any spatial indexes you have at your disposal to make this
            method as fast as possible.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box that you wish to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data that you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WfsFeatureSource.ServiceLocationUrl">
            <summary>
            The url of wfs service.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WfsFeatureSource.WfsNamespace">
            <summary>
            Add ogc as prefix to in some cases, currently it is only works in API GetFeaturesByColumnValue.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WfsFeatureSource.TypeName">
            <summary>
            The typename in the specify wfs service.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WfsFeatureSource.LastXmlResponse">
            <summary>
            The xml text represnets last respone, it will pass out by RequestedData event as parameter.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WfsFeatureSource.TimeoutInSeconds">
            <summary>
            This property specifies the timeout of the web request in seconds.  The default timeout value is 20 seconds.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WfsFeatureSource.WebProxy">
            <summary>
            This property gets or sets the proxy used for requesting a Web Response.
            </summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.WfsFeatureSource.RequestingData">
            <summary>This event is called before the requesting data by url from wfs server.</summary>
            <remarks>This event is called before the requesting data by url from wfs server.</remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.WfsFeatureSource.RequestedData">
            <summary>This event is called after the requesting data by url from wfs server.</summary>
            <remarks>This event is called after the requesting data by url from wfs server.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RotationProjection">
            <summary>This projection allows you to rotate the map image base don an angle.</summary>
            <remarks>
            This can be usefully when you are working with directional maps such as driving
            maps where you want the upper center of the map to be in line with the direction of the
            vehicle heading.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RotationProjection.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor and will set the angle to 0 whick is north being
            up.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor and will set the angle to 0 whick is north being
            up.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RotationProjection.#ctor(System.Double)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in an angle to change the rotation of the
            map.
            </overloads>
            <returns>None</returns>
            <remarks>
            This constructor allows you to pass in an angle to change the rotation of the
            map.
            </remarks>
            <param name="angle">This parameter is the angle you want to map to rotate to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RotationProjection.GetUpdatedExtent(ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This method returns an adjusted extend based on the angle of rotation.</summary>
            <returns>This method returns an adjusted extend based on the angle of rotation.</returns>
            <remarks>
            This method returns an adjusted extend based on the angle of rotation. It is
            important that you update your current extent every time you adjust the angle of the
            projection. This will ensure the rotaion is performed properly.
            </remarks>
            <param name="worldExtent">This parameter is the world extent before the rotation.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RotationProjection.ConvertToExternalProjectionCore(System.Double[],System.Double[])">
            <summary>
            This method returns a projected vertices based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns a projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically you can call the
            projection utility library that has interfaces for dozens of different types of
            projections.
            </remarks>
            <param name="x">This parameter is the X values of the points that will be projected.</param>
            <param name="y">This parameter is the Y values of the points that will be projected.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RotationProjection.ConvertToInternalProjectionCore(System.Double[],System.Double[])">
            <summary>
            This method returns a de-projected vertices based on the coordinates passed
            in.
            </summary>
            <returns>
            This method returns a de-projected vertices based on the coordinates passed
            in.
            </returns>
            <remarks>
            This method returns a de-projected vertex based on the coordinates passed in. You
            will need to override this method for the Projection class. Typically you can call the
            projection utility library that has interfaces for dozens of different types of
            projections. The de-projection is important because inside of the FeatureSource you
            will in many cases to to and from various projections.
            </remarks>
            <param name="x">This parameter is the X values of the points that will be de-projected.</param>
            <param name="y">This parameter is the Y values of the points that will be de-projected.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RotationProjection.Angle">
            <summary>This property sets the angle of rotation.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.NativeImageTile">
            <summary>
            This class represents a NativeImageTile, which is defined as scale, RectangleBox
            and a byte array for its tile bitmap.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.NativeImageTile.#ctor">
            <summary>
            This is the default constructor without passing any parameters. All its
            properties should be set via the properties.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.NativeImageTile.#ctor(ThinkGeo.MapSuite.Core.RectangleShape,System.Double)">
             <summary>
            This is the constructor for Tile by passing the boundingBox and scale.
             </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.NativeImageTile.#ctor(System.Byte[],ThinkGeo.MapSuite.Core.RectangleShape,System.Double)">
             <summary>
            This is the constructor for Tile by passing image bitmap array and the boundingBox and scale.
             </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.NativeImageTile.NativeImage">
            <summary>This property is the byte arry showing the image of the tile.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PjDatum">
            <summary>
            Datum setting
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PjDatum.GetDatumID(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Obtain ID value of Datum
            </summary>
            <param name="args">Parameter string dictionary</param>
            <returns>ID of Datum</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PjDatum._InitDatum(System.String)">
            <summary>
            According to datums list set value of datums
            </summary>
            <param name="datumID">ID value of datum object</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PjDatum.Datum">
            <summary>
            Obtain PjDatums object of corresponding ID
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.SpatialDataType">
            <summary>
            This property gets the spatial data type in the
            <strong>MsSql2008FeatureSource</strong>.
            </summary>
            <remarks>
            	<para>In SQL Server 2008 there are two new data types for storing spatial
                information: GeometryType and GeographyType.</para>
            	<para>The Geometry data type supports a flat 2D surface with XY coordinates for
                points. Points can be lines , on line string and mark edges of polygons.</para>
            	<para>The Geography data type uses the same methods but the data type reflects the
                fact that we live on a curved 2D surface popularly known as the earth.</para>
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.SpatialDataType.Geometry">
            <summary>
            The GeometryType supported in SQL Server2008.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.SpatialDataType.Geography">
            <summary>
            The GeographyType supported in SQL Server2008.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LayersDrawnEventArgs">
            <summary>
            This is the event arguments class for the LayersDrawn event on the MapEngine class. It
            is raised after all of the layers are drawn.
            </summary>
            <remarks>
            This is the event arguments class for the LayersDrawn event on the MapEngine class. It
            is raised after the layers are drawn. This event allows you to draw something
            with the canvas after all of the Layers are drawn.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LayersDrawnEventArgs.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LayersDrawnEventArgs.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Layer},ThinkGeo.MapSuite.Core.RectangleShape,System.Object)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to set the layers that were drawn, the world extent, and
            the image you are drawing on.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="layers">This parameter is the layers that were drawn.</param>
            <param name="worldExtent">This parameter is the world extent you are drawing.</param>
            <param name="nativeImage">This parameter is the GeoImage or native map image.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LayersDrawnEventArgs.WorldExtent">
            <summary>This property gets and sets the world extent to draw.</summary>
            <value>This property gets the world extent to draw.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LayersDrawnEventArgs.NativeImage">
            <summary>
            This property gets and sets the GeoImage or native image we are drawing
            on.
            </summary>
            <value>This property gets the GeoImage or native image we are drawing on.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LayersDrawnEventArgs.Layers">
            <summary>This property gets and sets the layers that have been drawn.</summary>
            <value>This property gets the layers that have been drawn.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.IconStyle">
            <summary>This class displays an icon with text from the data of the feature.</summary>
            <remarks>
            You can use the IconStyle when you have an icon you want to display on the map
            with characters inside of that icon. For example, if you have a circular icon and you
            want to label the number 1-100 inside of the icon, you can use this class. You need to
            specify the column name where the numbers or letters will come from, as well as a font.
            Through various properties, you can also control the positioning of the icon, just as you
            would with the TextStyle.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconStyle.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this, then you should set the
            properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you use this, then you should set the properties manually -- such as the column
            name, font, solid brush and the image.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconStyle.#ctor(System.String,System.String,ThinkGeo.MapSuite.Core.GeoFont,ThinkGeo.MapSuite.Core.GeoSolidBrush)">
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <overloads>
            This constructor allows you to pass in the path to the icon, along with the column
            name, font and solid brush to use. This is the most commonly used constructor.
            </overloads>
            <remarks>
            This constructor allows you to pass in the path to the icon, along with the column
            name, font and solid brush to use. This is the most commonly used constructor. If you
            need to use an image from a stream, then you should use the constructor that takes a
            GeoImage.
            </remarks>
            <param name="iconPathFilename">This parameter is the path and filename of the icon you want to use.</param>
            <param name="textColumnName">This parameter is the column name from which to get the data for the text.</param>
            <param name="textFont">This parameter is the font used to draw the text on the icon.</param>
            <param name="textSolidBrush">
            This parameter is the solid brush that is used to draw the text on the
            icon.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconStyle.#ctor(ThinkGeo.MapSuite.Core.GeoImage,System.String,ThinkGeo.MapSuite.Core.GeoFont,ThinkGeo.MapSuite.Core.GeoSolidBrush)">
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <overloads>
            This constructor allows you to use a GeoImage instead of specifying a path and
            filename of the icon. This is commonly used if the image comes from a stream.
            </overloads>
            <remarks>
            This constructor allows you to use a GeoImage instead of specifying a path and
            filename of the icon. This is commonly used if the image comes from a stream.
            </remarks>
            <param name="iconImage">This parameter is the image to use in this style.</param>
            <param name="textColumnName">This parameter is the column name from which to get the data for the text.</param>
            <param name="textFont">This parameter is the font used to draw the text on the icon.</param>
            <param name="textSolidBrush">
            This parameter is the solid brush that is used to draw the text on the
            icon.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconStyle.GetLabelingCandidateCore(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeoCanvas)">
            <summary>This method determines which labels will be candidates for drawing.</summary>
            <remarks>
            This overridden method is called from the concrete public method
            GetLabelingCandidate. In this method, we determine if the feature passed in will be a
            candidate for drawing. If you have the grid method enabled, then we determine this by
            ensuring that only one label will be eligible per grid cell. In this way, we can ensure
            that labels always draw in the same place at the same scale.
            </remarks>
            <returns>This method returns a collection of labeling candidates.</returns>
            <param name="feature">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconStyle.IconFilePathName">
            <summary>
            This property gets and sets the filename and path for the image you want to use
            in the style.
            </summary>
            <value>
            This property gets the filename and path for the image you want to use in the
            style.
            </value>
            <remarks>
            You can also optionally use the IconImage property if the image you want to use
            is derived from a stream.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconStyle.IconImage">
            <summary>This property gets and sets the GeoImage you want to use for the image.</summary>
            <value>This property gets the GeoImage you want to use for the image.</value>
            <remarks>
            You will typically want to use this property if your image is derived from a
            stream. Otherwise, you can use the IconFilePathName property to specify where the icon
            is located and we will handle the rest.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconStyle.IconImageScale">
            <summary>This property gets and sets the scale of the image you want to draw.</summary>
            <value>This property gets the scale of the image you want to draw.</value>
            <remarks>
            This property allows you to scale the image up and down depending on how large or
            small you want it. It can be changed dynamically, so you could change it at every scale
            level to resize the bitmap based on the current scale. A scale of 1 would be the original size,
            while a scale of 2 would double the size. A scale of .5 would reduce the size of the image by half,
            and so on.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconStyle.SuppressPartialLabels">
            <summary>
            This property gets and sets whether a partial label in the current extent will be drawn or not.
            </summary>
            <remarks>This property provides a solution to the "cut off" label issue in Map Suite Web Edition and Desktop Edition, which occurs when multiple
            tiles exist. When you set this property to true, any labels outside of the current extent will not be drawn.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.AreaStyles">
            <summary>
            This class is a collection of predefined styles and helper methods for creating
            styles.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>This method builds a simple area style.</summary>
            <overloads>This overload allows you to specify just a fill color.</overloads>
            <returns>This method builds a simple area style.</returns>
            <remarks>None</remarks>
            <param name="fillBrushColor">This parameter is the fill color of the area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>This method builds a simple area style.</summary>
            <overloads>This overload allows you to provide a fill and an outline.</overloads>
            <returns>This method builds a simple area style.</returns>
            <remarks>None</remarks>
            <param name="fillBrushColor">This parameter is the fill color for the area.</param>
            <param name="outlinePenColor">This parameter is the outline pen color for the area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Int32)">
            <summary>This method builds a simple area style.</summary>
            <overloads>This overload allows you to pass the fill color, pen color and pen width.</overloads>
            <returns>This method builds a simple area style.</returns>
            <remarks>None</remarks>
            <param name="fillBrushColor">This parameter is the fill color for the area.</param>
            <param name="outlinePenColor">This parameter is the outline pen color for the area.</param>
            <param name="outlinePenWidth">This parameter is the outline pen width for the area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Int32,ThinkGeo.MapSuite.Core.LineDashStyle)">
            <summary>This method builds a simple area style.</summary>
            <overloads>This overload allows you to pass the fill color, pen color and pen width.</overloads>
            <returns>This method builds a simple area style.</returns>
            <remarks>None</remarks>
            <param name="fillBrushColor">This parameter is the fill color for the area.</param>
            <param name="outlinePenColor">This parameter is the outline pen color for the area.</param>
            <param name="outlinePenWidth">This parameter is the outline pen width for the area.</param>
            <param name="borderStyle"> This parameter is the BorderStyle for the area style.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,System.Single)">
            <summary>This method builds a simple area style.</summary>
            <returns>This method builds a simple area style.</returns>
            <overloads>
            This overload allows you to pass in the fill color and a pixel offset in X &amp;
            Y.
            </overloads>
            <remarks>None</remarks>
            <param name="fillBrushColor">This parameter is the fill color for the area.</param>
            <param name="xOffsetInPixel">This parameter is the X pixels offset for this area.</param>
            <param name="yOffsetInPixel">This parameter is the Y pixels offset for this area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single,System.Single)">
            <summary>This method builds a simple area style.</summary>
            <returns>This method builds a simple area style.</returns>
            <remarks>None</remarks>
            <overloads>
            This overload allows you to provide a fill, outline color and offset in X &amp;
            Y.
            </overloads>
            <param name="fillBrushColor">This parameter is the fill color for the area.</param>
            <param name="outlinePenColor">This parameter is the outline color for the area.</param>
            <param name="xOffsetInPixel">This parameter is the X pixels offset for this area.</param>
            <param name="yOffsetInPixel">This parameter is the Y pixels offset for this area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Int32,System.Single,System.Single)">
            <summary>This method builds a simple area style.</summary>
            <returns>This method builds a simple area style.</returns>
            <remarks>None</remarks>
            <overloads>
            This overload allows you to pass the fill color, pen color, pen width and X &amp;
            Y offset.
            </overloads>
            <param name="fillBrushColor">This parameter is the fill color for the area.</param>
            <param name="outlinePenColor">This parameter is the outline pen color for the area.</param>
            <param name="outlinePenWidth">This parameter is the outline pen width for the area.</param>
            <param name="xOffsetInPixel">This parameter is the X pixels offset for this area.</param>
            <param name="yOffsetInPixel">This parameter is the Y pixels offset for this area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateSimpleAreaStyle(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Int32,ThinkGeo.MapSuite.Core.LineDashStyle,System.Single,System.Single)">
             <summary>This method builds a simple area style.</summary>
             <returns>This method builds a simple area style.</returns>
             <remarks>None</remarks>
             <overloads>
             This overload allows you to pass the fill color, pen color, pen width and X &amp;
             Y offset.
             </overloads>
             <param name="fillBrushColor">This parameter is the fill color for the area.</param>
             <param name="outlinePenColor">This parameter is the outline pen color for the area.</param>
             <param name="outlinePenWidth">This parameter is the outline pen width for the area.</param>
            <param name="borderStyle"> This parameter is the BorderStyle for the area.</param>
             <param name="xOffsetInPixel">This parameter is the X pixels offset for this area.</param>
             <param name="yOffsetInPixel">This parameter is the Y pixels offset for this area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateHatchStyle(ThinkGeo.MapSuite.Core.GeoHatchStyle,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>This method returns an AreaStyle with a hatch pattern.</summary>
            <overloads>This overload allows you to specify the background and foreground color.</overloads>
            <returns>This property is the color of the foreground of the hatch pattern.</returns>
            <remarks>None</remarks>
            <param name="hatchStyle">This parameter is the hatch pattern to be used.</param>
            <param name="foregroundBrushColor">This property is the color of the foreground of the hatch pattern.</param>
            <param name="backgroundBrushColor">This property is the color of the background of the hatch pattern.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateHatchStyle(ThinkGeo.MapSuite.Core.GeoHatchStyle,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>This method returns an AreaStyle with a hatch pattern.</summary>
            <returns>This method returns an AreaStyle with a hatch pattern.</returns>
            <remarks>None</remarks>
            <overloads>
            This overload allows you to specify the background color, foreground color, and a
            border color.
            </overloads>
            <param name="hatchStyle">This parameter is the hatch pattern to be used.</param>
            <param name="foregroundBrushColor">This property is the color of the foreground of the hatch pattern.</param>
            <param name="backgroundBrushColor">This property is the color of the background of the hatch pattern.</param>
            <param name="outlinePenColor">This parameter is the border color for the area.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateHatchStyle(ThinkGeo.MapSuite.Core.GeoHatchStyle,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Int32,ThinkGeo.MapSuite.Core.LineDashStyle,System.Single,System.Single)">
            <summary>This method returns a GeoHatchStyle.</summary>
            <requirements>None</requirements>
            <returns>This method returns an AreaStyle with a hatch pattern.</returns>
            <overloads>
            This overload allows you to specify the background color, foreground color,
            border color and many other parameters.
            </overloads>
            <param name="hatchStyle">This parameter is the hatch pattern to be used.</param>
            <param name="foregroundBrushColor">This property is the color of the foreground of the hatch pattern.</param>
            <param name="backgroundColor">This property is the color of the background of the hatch pattern.</param>
            <param name="outlinePenColor">This parameter is the border color for the area.</param>
            <param name="outlinePenWidth">This parameter is the border width for the area.</param>
            <param name="outlineDashStyle">This parameter is the dahs style to be used for the border.</param>
            <param name="xOffsetInPixel">This parameter is the pixel offset for X.</param>
            <param name="yOffsetInPixel">This parameter is the pixel offset for Y.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateLinearGradientStyle(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>This method returns a linear gradient style.</summary>
            <returns>This method returns an AreaStyle.</returns>
            <remarks>None</remarks>
            <param name="fromColor">
            This parameter represents the starting <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="toColor">
            This parameter represents the ending <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="angle">
            This parameter represents the angle of the color changing from start to
            end.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateLinearGradientStyle(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>This method returns a linear gradient style.</summary>
            <returns>This method returns an AreaStyle.</returns>
            <remarks>None</remarks>
            <param name="fromColor">
            This parameter represents the starting <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="toColor">
            This parameter represents the ending <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="angle">
            This parameter represents the angle of the color changing from start to
            end.
            </param>
            <param name="outlinePenColor">This parameter represents the outline pen color of the area style.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateHueFamilyAreaStyle(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Int32)">
            <summary>This method returns an AreaStyle.</summary>
            <returns>This method returns an AreaStyle.</returns>
            <remarks>None.</remarks>
            <param name="outlinePenColor">
            This parameter specifies the GeoPen you want to use on the outline of the area
            style.
            </param>
            <param name="baseColor">The base <strong>GeoColor</strong> of the hue family colors.</param>
            <param name="numberOfColors">The number of GeoColors in hue family to construct the 
            areastyle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateHueFamilyLinearGradientAreaStyle(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Int32,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>This method returns an AreaStyle in a family of hue-related colors drawn with a linear gradient.</summary>
            <returns>This method returns an AreaStyle in a family of hue-related colors drawn with a linear gradient.</returns>
            <remarks>None.</remarks>
            <param name="outlinePenColor">
            This parameter specifies the GeoPen you want to use on the outline of the AreaStyle.
            </param>
            <param name="baseColor">The base <strong>GeoColor</strong> for the hue family of colors.</param>
            <param name="numberOfColors">The number of GeoColors in the hue family to construct the
            AreaStyle.</param>
            <param name="fromColor">
            This parameter represents the starting <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="toColor">
            This parameter represents the ending <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="angle">This parameter represents the angle for the gradient.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateQualityFamilyAreaStyle(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Int32)">
            <summary>This method returns an AreaStyle in a family of quality-realted colors.</summary>
            <returns>This method returns an AreaStyle in a family of quality-realted colors.</returns>
            <param name="outlinePenColor">
            This parameter specifies the GeoPen you want to use on the outline of the
            AreaStyle.
            </param>
            <param name="baseColor">The base <strong>GeoColor</strong> for the quality family of colors.</param>
            <param name="numberOfColors">The number of GeoColors in the quality-based family to construct the AreaStyle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyles.CreateQualityFamilyLinearGradientAreaStyle(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Int32,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>This method returns an AreaStyle in a family of quality-related colors drawn with a linear gradient.</summary>
            <returns>This method returns an AreaStyle in a family of quality-related colors drawn with a linear gradient.</returns>
            <remarks>None.</remarks>
            <param name="outlinePenColor">
            This parameter specifies the GeoPen you want to use on the outline of the
            AreaStyle.
            </param>
            <param name="baseColor">The base <strong>GeoColor</strong> for the quality family of colors.</param>
            <param name="numberOfColors">The number of GeoColors in quality-based family to construct the AreaStyle.</param>
            <param name="fromColor">
            This parameter represents the starting <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="toColor">
            This parameter represents the ending <strong>GeoColor</strong> for the
            gradient.
            </param>
            <param name="angle">This parameter represents the angle for the gradient.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.NoData1">
            <summary>This property gets a style that represents NoData1.</summary>
            <value>This property gets a style that represents NoData1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Water1">
            <summary>This property gets a style that represents Water1.</summary>
            <value>This property gets a style that represents Water1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Water2">
            <summary>This property gets a style that represents Water2.</summary>
            <value>This property gets a style that represents Water2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Military1">
            <summary>This property gets a style that represents Military1.</summary>
            <value>This property gets a style that represents Military1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Wildlife1">
            <summary>This property gets a style that represents Wildlife1.</summary>
            <value>This property gets a style that represents Wildlife1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.State1">
            <summary>This property gets a style that represents State1.</summary>
            <value>This property gets a style that represents State1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.State2">
            <summary>This property gets a style that represents State2.</summary>
            <value>This property gets a style that represents State2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.County1">
            <summary>This property gets a style that represents County1.</summary>
            <value>This property gets a style that represents County1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.County2">
            <summary>This property gets a style that represents County2.</summary>
            <value>This property gets a style that represents County2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Country1">
            <summary>This property gets a style that represents Country1.</summary>
            <value>This property gets a style that represents Country1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Country2">
            <summary>This property gets a style that represents Country2.</summary>
            <value>This property gets a style that represents Country2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Swamp1">
            <summary>This property gets a style that represents Swamp1.</summary>
            <value>This property gets a style that represents Swamp1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Swamp2">
            <summary>This property gets a style that represents Swamp2.</summary>
            <value>This property gets a style that represents Swamp2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Urban1">
            <summary>This property gets a style that represents Urban1.</summary>
            <value>This property gets a style that represents Urban1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Urban2">
            <summary>This property gets a style that represents Urban2.</summary>
            <value>This property gets a style that represents Urban2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Antarctica1">
            <summary>This property gets a style that represents Antarctica1.</summary>
            <value>This property gets a style that represents Antarctica1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Evergreen1">
            <summary>This property gets a style that represents Evergreen1.</summary>
            <value>This property gets a style that represents Evergreen1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Evergreen2">
            <summary>This property gets a style that represents Evergreen2.</summary>
            <value>This property gets a style that represents Evergreen2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Grass1">
            <summary>This property gets a style that represents Grass1.</summary>
            <value>This property gets a style that represents Grass1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.WaterIntermittent1">
            <summary>This property gets a style that represents WaterIntermittent1.</summary>
            <value>This property gets a style that represents WaterIntermittent1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Sand1">
            <summary>This property gets a style that represents Sand1.</summary>
            <value>This property gets a style that represents Sand1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.SeaIce1">
            <summary>This property gets a style that represents SeaIce1.</summary>
            <value>This property gets a style that represents SeaIce1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.SnowIce1">
            <summary>This property gets a style that represents SnowIce1.</summary>
            <value>This property gets a style that represents SnowIce1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Tundra1">
            <summary>This property gets a style that represents Tundra1.</summary>
            <value>This property gets a style that represents Tundra1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Crop1">
            <summary>This property gets a style that represents Crop1.</summary>
            <value>This property gets a style that represents Crop1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Forest1">
            <summary>This property gets a style that represents Forest1.</summary>
            <value>This property gets a style that represents Forest1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyles.Park1">
            <summary>This property gets a style that represents Park1.</summary>
            <value>This property gets a style that represents Park1.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeographicColors">
            <summary>
            This class is a convenient way to access a predefined set of geographic
            colors.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.Sand">
            <summary>This property returns a Sand GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Sand GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.Grass">
            <summary>This property returns a Grass GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Grass GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.Dirt">
            <summary>This property returns a Dirt GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Dirt GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.Mountains">
            <summary>This property returns a Mountains GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Mountains GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.Lake">
            <summary>This property returns a Lake GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Lake GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.DeepOcean">
            <summary>This property returns a DeepOcean GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a DeepOcean GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.ShallowOcean">
            <summary>This property returns a ShallowOcean GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a ShallowOcean GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.Tundra">
            <summary>This property returns a Tundra GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Tundra GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.Forest">
            <summary>This property returns a Forest GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Forest GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.Ice">
            <summary>This property returns a Ice GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Ice GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.Swamp">
            <summary>This property returns a Swamp GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Swamp GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.Road">
            <summary>This property returns a Road GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Road GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.Highway">
            <summary>This property returns a Highway GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Highway GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.InnerState">
            <summary>This property returns a Interstate GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Interstate GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.LocalRoad">
            <summary>This property returns a LocalRoad GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a LocalRoad GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeographicColors.MajorRoad">
            <summary>This property returns a MajorRoad GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a MajorRoad GeoColor.</decimalDegreesValue>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WorldLabelingCandidate">
            <summary>This class represents a candidate with world center point information for labeling.</summary>
            <remarks>
            This class is used in the labeling system. We keep track of
            every potential label in this class as it goes through the labeling rules.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LabelingCandidate">
            <summary>This class represents a candidate for labeling.</summary>
            <remarks>
            This class is used in the internals of the labeling system. We keep track of
            every potential label in this class as it goes through the labeling rules.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LabelingCandidate.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, then you should set the applicable properties
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LabelingCandidate.#ctor(System.String,ThinkGeo.MapSuite.Core.PolygonShape,ThinkGeo.MapSuite.Core.PointShape)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the area of the label as well as the center
            point.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="originalText">
            This parameter represents the text of the label before it is potentially
            modified.
            </param>
            <param name="simplePolygonInScreenCoordinates">This parameter is a polygon (in screen coordinates) representing the area to be labeled.</param>
            <param name="centerPointInScreenCoordinates">
            This parameter is the center of the polygon (in screen coordinates) representing the area to
            be labeled.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LabelingCandidate.#ctor(System.String,ThinkGeo.MapSuite.Core.PolygonShape,ThinkGeo.MapSuite.Core.PointShape,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.LabelInformation})">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the area of the label and the center
            point.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="originalText">
            This parameter represents the text of the label before it is potentially
            modified.
            </param>
            <param name="simplePolygonInScreenCoordinates">This parameter is a polygon (in screen coordinates) representing the area to be labeled.</param>
            <param name="centerPointInScreenCoordinates">
            This parameter is the center of the polygon (in screen coordinates) representing the area to
            be labeled.
            </param>
            <param name="labelInformation">This parameter is the labeling information for this labeling candidate.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LabelingCandidate.OriginalText">
            <summary>This property gets and sets the original text for the label.</summary>
            <value>This property gets the original text for the label.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LabelingCandidate.ScreenArea">
            <summary>This property gets and sets the screen area that encompasses the label.</summary>
            <value>This property gets the screen area that encompasses the label.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LabelingCandidate.CenterPoint">
            <summary>This property gets and sets the center point for the center of the label.</summary>
            <value>This property gets the center point for the center of the label.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LabelingCandidate.LabelInformation">
            <summary>This property gets and sets the label information for this label.</summary>
            <value>This property gets the label information for this label.</value>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldLabelingCandidate.#ctor">
            <summary>This is a default constructor for the class.</summary>
            <returns>None</returns>
            <remarks>
            If you use this constructor, then you should set the applicable properties
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldLabelingCandidate.#ctor(System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the text of the label.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="originalText">
            This parameter represents the text of the label before it is potentially
            modified.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldLabelingCandidate.#ctor(System.String,ThinkGeo.MapSuite.Core.PointShape)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the text of the label as well as the world center
            point.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="originalText">
            This parameter represents the text of the label before it is potentially
            modified.
            </param>
            <param name="centerPointInWorldCoordinates">
            This parameter is the center of the polygon (in world coordinates) representing the area to
            be labeled.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldLabelingCandidate.CenterPointInWorldCoordinates">
            <summary>
            This property gets or sets the Center Point position in world Coordinate system.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.AdornmentLayersDrawnEventArgs">
            <summary>
            This is the event arguments class for the AdornmentLayersDrawn event. It is raised
            after all of the AdornmentLayers have been drawn.
            </summary>
            <remarks>
            This is the event arguments class for the AdornmentLayersDrawn event. It is raised
            after all of the AdornmentLayers have been drawn. This event allows you to manipulate the
            AdornmentLayers, or draw something with the canvas after all of the AdornmentLayers
            have been drawn.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AdornmentLayersDrawnEventArgs.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AdornmentLayersDrawnEventArgs.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.AdornmentLayer})">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="adornmentLayers">This parameter is the AdornmentLayers that have been drawn.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AdornmentLayersDrawnEventArgs.AdornmentLayers">
            <summary>This property gets and sets the AdornmentLayers that have been drawn.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.YahooMapsLayer">
            <summary>
            <summary>Represents an object that encapsulates a Yahoo Map layer.</summary>
            </summary>
            <remarks>This clss uses Yahoo Static Maps API to implement url request.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.YahooMapsLayer.#ctor">
            <summary>This is the constructor the for the class. If you use this constructor, then you need to set
            the required properties manually.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.YahooMapsLayer.#ctor(System.String)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <remarks>This constructor initializes a new layer and assgin a license key.
            </remarks>
            <param name="licenseKey">license key of the Yahoo Static Maps API.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.YahooMapsLayer.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a Layer which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method opens the Layer so that it is initialized and ready to use.</summary>
            <remarks>
            This abstract method is called from the concrete public method Open. The
            open method plays an important role, as it is responsible for initializing the Layer.
            Most methods on the Layer will throw an exception if the state of the Layer is not
            opened. When the map draws each layer, the layer will be opened as one of its first steps;
            then, after it is finished drawing with that layer, it will close it. In this way, we
            are sure to release all resources used by the Layer.<br/>
            <br/>
            When implementing the abstract method, consider opening the FeatureSource or
            RasterSource. You will get a chance to close these in the Close method of the
            Layer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.YahooMapsLayer.CloseCore">
            <summary>
            This method closes the Layer and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This abstract method is called from the concrete public method Close. The close
            method plays an important role in the life cycle of the Layer. It may be called after
            drawing to release any memory and other resources that were allocated since the Open
            method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed Layer is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.YahooMapsLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the Layer.</summary>
            <remarks>
            This method is the concrete wrapper for the abstract method DrawCore. This
                method draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties that
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter represents the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.YahooMapsLayer.PictureFormat">
            <summary>
            Gets or sets a value represents the image format of the image.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.YahooMapsLayer.LicenseKey">
            <summary>
            Gets or sets a value represents the license key for YahooMaps API.
            </summary>
            <remarks>The Yahoo Maps API lets you embed Yahoo Maps in your own application. A single Maps API key is valid for a single "directory" or domain. If the license type is premier, it repesents client id, eg "gme-yourclientid".</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.YahooMapsLayer.WebProxy">
            <summary>
            This property gets or sets the proxy used for requesting a Web Response.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RandomColorType">
            <summary>
            Defines values represent which kind of color will use for randomly.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.RandomColorType.All">
            <summary>
            This item represents all random color.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.RandomColorType.Pastel">
            <summary>
            This item represents pastel color.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.RandomColorType.Bright">
            <summary>
            This item represents bright color.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Factors">
            <summary>
            definition of class Factors
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.BuildingIndexShapeFileFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the BuildingIndex
            event in ShapeFileFeatureSource class.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BuildingIndexShapeFileFeatureSourceEventArgs.#ctor">
            <summary>
            This is the default constructor of the event args.
            </summary>
            <remarks>If you use this constructor, you have to set the properties manually.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BuildingIndexShapeFileFeatureSourceEventArgs.#ctor(System.Int32,System.Int32,ThinkGeo.MapSuite.Core.Feature,System.DateTime,System.Boolean)">
            <summary>
            This is the constructor of the event args by passing the desired parameters.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.BuildingIndexShapeFileFeatureSourceEventArgs.RecordCount">
            <summary>
            Gets the total record count to build rTree index.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.BuildingIndexShapeFileFeatureSourceEventArgs.CurrentRecordIndex">
            <summary>
            Gets the current record index for building rTree index.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.BuildingIndexShapeFileFeatureSourceEventArgs.CurrentFeature">
            <summary>
            Gets the current feature for building rTree index.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.BuildingIndexShapeFileFeatureSourceEventArgs.StartProcessTime">
            <summary>
            Gets the starting process time for building the index.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.BuildingIndexShapeFileFeatureSourceEventArgs.Cancel">
            <summary>
            Gets or sets to see if we need to cancel the building index of current record.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RectangleShape">
            <summary>
            This class represents a rectangle, which is defined as an upper left point and a
            lower right point.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.RectangleShape.tolerance">
            <summary>
            Gets and sets the tolerance when construct the RectangleShape. 
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.#ctor">
            <summary>This constructor creates a RectangleShape.</summary>
            <overloads>This overload creates a RectangleShape with default values.</overloads>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.#ctor(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape)">
            <summary>This constructor creates a RectangleShape.</summary>
            <overloads>
            This overload creates a RectangleShape by allowing you to specify the upperLeft
            and lowerRight points of the rectangle.
            </overloads>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a upperLeftPoint that has a X value that is more than the lowerRightPoint's X value, it will throw a ArgumentException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a upperLeftPoint that has a Y value that is less than the lowerRightPoint's Y value, it will throw a ArgumentException.</exception>
            <param name="upperLeftPoint">This parameter specifies the upper left point of the rectangle.</param>
            <param name="lowerRightPoint">This parameter specifies the lower right point of the rectangle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>This constructor creates a RectangleShape.</summary>
            <overloads>
            This overload creates a RectangleShape by allowing you to specify the maximum and
            minimum of the X &amp; Y values.
            </overloads>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxX that is less than the minX, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxY that is less than the minY, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="minX">
            This property specifies the minimum X value. This is also the upper left
            X.
            </param>
            <param name="maxY">
            This property specifies the maximum Y value. This is also the upper left
            Y.
            </param>
            <param name="maxX">
            This property specifies the maximum X value. This is also the lower right
            X.
            </param>
            <param name="minY">
            This property specifies the minimum Y value. This is also the lower right
            Y.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates a RectangleShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates a RectangleShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.GetIntersection(ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>
            This method returns the intersection of the current RectangleShape and the target shape,
            defined as the set of all points which lie in both the current shape and the target
            shape.
            </summary>
            <returns>
            The return type is a RectangleShape that contains the set of all points which
            lie in both the current shape and the target shape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="targetShape">The shape you are trying to find the intersection with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.ToPolygon">
            <summary>This method returns the current shape as a PolygonShape.</summary>
            <returns>This method returns the current shape as a PolygonShape.</returns>
            <remarks>
            This method is mainly used to convert this GIS non-standard shape to a GIS
            standard shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.ExpandToInclude(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method will expand the current RectangleShape to include the targetShape
            parameter.
            </summary>
            <overloads>This overload takes a single shape.</overloads>
            <remarks>
            There is also an overload that can expand the RectangleShape using a list of
            multiple shapes.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <param name="targetShape">This parameter is used to expand the current rectangle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.ExpandToInclude(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method will expand the current RectangleShape to include the target feature
            parameter.
            </summary>
            <overloads>This overload takes a single feature.</overloads>
            <remarks>
            There is also an overload that can expand the RectangleShape using a collection of features.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <param name="targetFeature">This parameter is used to expand the current feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.ExpandToInclude(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.BaseShape})">
            <summary>
            This method will expand the current RectangleShape to include the shapes in the targetShapes
            parameter.
            </summary>
            <overloads>This overload takes a list of shapes.</overloads>
            <remarks>
            There is also an overload that can expand the RectangleShape using a single
            shape.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in targetShapes that do not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <param name="targetShapes">This parameter is used to expand the current rectangle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.ExpandToInclude(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature})">
            <summary>
            This method will expand the current RectangleShape to include the features in the targetFeatures
            parameter.
            </summary>
            <overloads>This overload takes a feature collection.</overloads>
            <remarks>
            There also is an overload that can expand the RectangleShape using a single
            feature.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass in targetFeatures that do not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <param name="targetFeatures">This parameter is a group of features used to expand the current rectangle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.GetCenterPointCore">
            <summary>This method returns the center point of the current shape's bounding box.</summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            A PointShape representing the center point of the current shape's bounding
            box.
            </returns>
            <remarks>
            This method returns the center point of the current shape's bounding box. It is
            important to note that this is the center point of the bounding box. There are numerous
            ways to calculate the "center" of a geometry such, as its weighted center, etc. You can
            find other centers by examining the various methods of the shape itself.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.ExpandToIncludeCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method will expand the current RectangleShape to include the shape in the targetShape
            parameter.
            </summary>
            <overloads>This overload takes a single shape.</overloads>
            <remarks>
            There is also an overload that can expand the RectangleShape using a list of
            shapes.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <param name="targetShape">This parameter is used to expand the current rectangle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.GetPerimeterCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns the perimeter of the shape (defined as the sum of the lengths
            of all its sides).
            </summary>
            <overloads>
            In this overload the return unit is based on the LengthUnit you specify in the
            returningLengthUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the LengthUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            You would use this method to find the distance around the area shape.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.GetAreaCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.AreaUnit)">
            <summary>
            This method returns the area of the shape (defined as the size of the region
            enclosed by the figure).
            </summary>
            <overloads>
            In this overload the return unit is based on the AreaUnit you specify in the
            returningUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the AreaUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>You would use this method to find the area inside the shape.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the AreaUnit you would like to use as the return value. For example, if
            you select square miles as your returningUnit, then the distance will be returned in
            square miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>None</remarks>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.RegisterCore(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns a MultipointShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            This method returns a MultipointShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </returns>
            <remarks>
            The register method is useful, for example, when a group of points represented by a
            MultipointShape has been generated in a non-geographic coordinate in meters, and you want to
            plot the points on a map that is in decimal degrees.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the GeographyUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another, based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload the X and Y offset are based on a DistanceUnit you specify
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape 1 unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles to
                on the X axis and 3 miles on the Y axis.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the
                move. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the shape from one location to another, based on a
            direction in degrees and distance.
            </summary>
            <overloads>In this overload the distance is in the same GeographicUnit as the shape.</overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an
                angleInDegrees and distance parameter. With this overload, it is important to note
                that the distance units are the same GeographicUnit as the shape. For example,
                if your shape is in decimal degrees and you call this method with a distance of 1,
                you're going to move this shape 1 decimal degree in direction of the
                angleInDegrees. In many cases it is more useful to specify the DistanceUnit of movement,
                such as in miles or yards, so for these scenarios there is another overload you may
                want to use instead.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape in the angle specified. The
            distance unit will be the same as the GeographyUnit for the shape. The distance must be
            greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the
                move. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.GetClosestPointToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.GetDistanceToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>The distance returned will be in the unit of the shape.</overloads>
            <returns>
            The return type is the distance between this shape and the targetShape in the
            GeographyUnit of the shape.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </returns>
            <remarks>
            In this method, we compute the closest distance between the two shapes. The
            returned unit will be in the unit of distance specified.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">The GeographyUnit of the targetShape.</param>
            <param name="distanceUnit">The DistanceUnit of the returned value.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.GetWellKnownTextCore">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric shapes.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Core.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe a geometry as a binary array. Well-known
            binary is useful when you want to save a geometry in an efficient format using as little
            space as possible. An alternative to well-known binary is well-known text, which is a
            textual representation of a geometry object. We have methods that work with well-known
            text as well.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies whether the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.IsDisjointedCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns whether the current shape and the targetShape have no points in
            common.
            </summary>
            <returns>
            This method returns whether the current shape and the targetShape have no points in
            common.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.ValidateCore(ThinkGeo.MapSuite.Core.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.GetCrossingCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RectangleShape.ToString">
            <summary>
            This method returns a formatted representation of the UpperLeftPoint.X, UpperLeftPoint.Y, LowerRightPoint.X and LowerRightPoint.Y
            value.
            </summary>
            <returns>
            This method returns a formatted representation of the UpperLeftPoint.X, UpperLeftPoint.Y, LowerRightPoint.X and LowerRightPoint.Y
            value.
            </returns>
            <remarks>The value will be formatted in the standard string format: -180,90,180,-90"</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RectangleShape.UpperLeftPoint">
            <summary>
            This property returns or sets the PointShape that represents the upper left point
            of the RectangleShape.
            </summary>
            <value>
            This property returns a PointShape at represents the upper left point of the
            RectangleShape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RectangleShape.UpperRightPoint">
            <summary>
            This property returns the PointShape that represents the upper right point of the
            RectangleShape.
            </summary>
            <value>
            This property returns the PointShape that represents the upper right point of the
            RectangleShape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RectangleShape.LowerRightPoint">
            <remarks>None</remarks>
            <summary>
            This property returns or sets the PointShape that represents the lower right point
            of the RectangleShape.
            </summary>
            <value>
            This property returns the PointShape that represents the lower right point of the
            RectangleShape.
            </value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RectangleShape.LowerLeftPoint">
            <summary>
            This property returns the PointShape that represents the lower left point of the
            RectangleShape.
            </summary>
            <value>
            This property returns the PointShape that represents the lower left point of the
            RectangleShape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RectangleShape.Height">
            <summary>
            This property returns the height of the RectangleShape in the unit of the
            shape.
            </summary>
            <value>
            This property returns the height of the RectangleShape in the unit of the
            shape.
            </value>
            <remarks>None</remarks>        
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RectangleShape.Width">
            <summary>
            This property returns the width of the RectangleShape in the unit of the
            shape.
            </summary>
            <value>
            This property returns the width of the RectangleShape in the unit of the
            shape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DecimalDegreesHelper">
            <summary>
            This class contains a static routine for converting between degree-minute-second
            measurement and decimal degree measurement. In essense, it is a routine for converting from
            a non-decimal degree unit to decimal degree unit distance.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetDegreesMinutesSecondsFromDecimalDegree(System.Double)">
            <summary>
            This method returns a degrees, minutes and seconds structure from a decimal degree
            value.
            </summary>
            <remarks>The method allows you pass in a decimal degree number and return the degree, minute, second as variables
            passed in on the method call.</remarks>
            <returns>
            This method returns a degrees, minutes and seconds structure from a decimal degree
            value.
            </returns>
            <param name="decimalDegreesValue">The decimal degree value you want to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetDegreesMinutesSecondsStringFromDecimalDegree(System.Double)">
            <summary>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </summary>
            <remarks>
            Example: If you enter 75.358 as the number of decimal degrees, the result would be 75
            degrees, 21 minutes, 28 seconds. Thus, the return string would be 75º 21' 28".
            </remarks>
            <returns>      
            This method returns a string representation in degrees, minutes and seconds
            from a decimal degree value.
            </returns>
            <overloads>This overload allows you to specify the decimal degree value.</overloads>
            <param name="decimalDegreesValue">The number of decimal degrees to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetDegreesMinutesSecondsStringFromDecimalDegree(System.Double,System.Int32)">
            <summary>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value and a specified precision.
            </summary>
            <remarks>Example: If you enter 75.358 as the number of decimal degree and 12 as decimals, the result would be
            75 degrees, 21 minutes, 28.80000000015 seconds. Thus, the return string would be 75º 21' 28.80000000015".</remarks>
            <returns>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </returns>
            <overloads>
            This overload allows you to specify the decimal degree value along with the
            precision of the returned value.
            </overloads>
            <param name="decimalDegreesValue">The number of decimal degree to convert.</param>
            <param name="decimals">The number of float decision for the second.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetDegreesMinutesSecondsStringFromDecimalDegreePoint(ThinkGeo.MapSuite.Core.PointShape)">
            <summary>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </summary>
            <remarks>Passing in a point will return the point's location represented in degrees,
            minutes, and seconds. For example, if the point's location in decimal degrees is (75.358, 36.345),
            the actual returned string would be "75º 21' 29''E  36º 20' 42''N".</remarks>
            <returns>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </returns>
            <overloads>This overload allows you to pass in a point shape to be converted.</overloads>
            <param name="pointShape">The point you want to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetDegreesMinutesSecondsStringFromDecimalDegreePoint(ThinkGeo.MapSuite.Core.PointShape,System.Int32)">
            <summary>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </summary>
            <returns>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </returns>
            <overloads>
            This overload allows you to pass in a point shape to be converted, along with the
            precision of the returned value.
            </overloads>
            <remarks>None</remarks>
            <param name="pointShape">The point of decimal degree to convert.</param>
            <param name="decimals">The number of decimal degree to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetDegreesMinutesSecondsStringFromDecimalDegreePoint(ThinkGeo.MapSuite.Core.Feature,System.Int32)">
            <summary>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </summary>
            <returns>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </returns>
            <overloads>
            This overload allows you to pass in a feature to be converted, along with the
            precision of the returned value.
            </overloads>
            <remarks>None</remarks>
            <param name="point">The feature whose decimal degrees to convert.</param>
            <param name="decimalPlaces">The number of decimal degree to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetDegreesMinutesSecondsStringFromDecimalDegreePoint(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </summary>
            <returns>
            This method returns a string representation in degrees, minutes and seconds from
            a decimal degree value.
            </returns>
            <overloads>
            This overload allows you to pass in a feature to be converted, along with the
            precision of the returned value.
            </overloads>
            <remarks>None</remarks>
            <param name="point">The feature whose decimal degrees to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetDecimalDegreeFromDegreesMinutesSeconds(System.String)">
            <summary>
            This method returns a decimal degree value based on a string containing degrees,
            minutes, and seconds.
            </summary>
            <remarks>If you pass in "75º 21' 28''" as a string, then the result will be 75.35777777784.</remarks>
            <returns>
            This method returns a decimal degree value based on a string containing degrees,
            minutes, and seconds.
            </returns>
            <param name="degreesMinutesSeconds">This parameter represents the degrees, minutes and seconds in a string.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetDecimalDegreeFromDegreesMinutesSeconds(ThinkGeo.MapSuite.Core.DegreesMinutesSeconds)">
            <summary>
            This method returns a decimal degree value based on a degree, minute and second
            structure.
            </summary>
            <remarks>If you pass in 75, 21 and 28, the result passed back will be 75.2577777778. </remarks>
            <returns>
            This method returns a decimal degree value based on a degree, minute and second
            structure.
            </returns>
            <param name="degreesMinutesSeconds">This structure represents the degrees, minutes and seconds.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetDecimalDegreeFromDegreesMinutesSeconds(System.Int32,System.Int32,System.Double)">
            <summary>
            This method returns a decimal degree value based on a set of degrees, minutes, and
            seconds.
            </summary>
            <returns>
            This method returns a decimal degree value based on a set of degrees, minutes, and
            seconds.
            </returns>
            <remarks>
            If you pass in 75, 21 and 28, the result passed back will be
            75.2577777778.
            </remarks>
            <param name="degrees">
            This parameter represents the degree component of the degrees, minutes and
            seconds.
            </param>
            <param name="minutes">
            This parameter represents the minute component of the degrees, minutes and
            seconds.
            </param>
            <param name="seconds">
            This parameter represents the second component of the degrees, minutes and
            seconds.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetDistanceFromDecimalDegrees(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This method returns the distance between two decimal degree points.</summary>
            <returns>
            This method returns the distance between two decimal degree points in the unit specified by
            the returningUnit parameter.
            </returns>
            <remarks>None</remarks>
            <overloads>This overload allows you to pass in two point shapes.</overloads>
            <param name="fromPoint">The point shape you will measure from.</param>
            <param name="toPoint">The point shape you will measure to.</param>
            <param name="returningUnit">The unit you would like your results back in, such as miles or kilometers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetDistanceFromDecimalDegrees(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This method returns the distance between two decimal degree points.</summary>
            <returns>
            This method returns the distance between two decimal degree points in the unit specified by
            the returningUnit parameter.
            </returns>
            <remarks>None</remarks>
            <overloads>This overload allows you to pass in two point shapes.</overloads>
            <param name="fromPointFeature">The feature you will measure from.</param>
            <param name="toPointFeature">The feature you will measure to.</param>
            <param name="returningUnit">The unit you would like your results back in, such as miles or kilometers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetDistanceFromDecimalDegrees(System.Double,System.Double,System.Double,System.Double,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This method returns the distance between two decimal degree points.</summary>
            <returns>
            This method returns the distance between two decimal degree points in the unit specified by
            the returningUnit parameter.
            </returns>
            <remarks>None</remarks>
            <overloads>
            This overload allows you to pass in the from and to latitude and longitude
            values.
            </overloads>
            <param name="fromLongitude">This is the from longitude value.</param>
            <param name="fromLatitude">This is the from latitude value.</param>
            <param name="toLongitude">This is the to longitude value.</param>
            <param name="toLatitude">This is the to latitude value.</param>
            <param name="returningUnit">
            This is the distance unit you would like to use in the return value. For example,
            if you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetLongitudeDifferenceFromDistance(System.Double,ThinkGeo.MapSuite.Core.DistanceUnit,System.Double)">
            <summary>
            Calculate the amount of longitude change given a certain distance and latitude. 
            </summary>
            <returns>Double representing the distance.</returns>
            <remarks>None</remarks>
            <param name="distance">The distance over which you would like to know the change in longitude.</param>
            <param name="distanceUnit">The unit the distance is in, such as miles or kilometers.</param>
            <param name="latitude">The latitude on the globe that the distance is measured at.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DecimalDegreesHelper.GetLatitudeDifferenceFromDistance(System.Double,ThinkGeo.MapSuite.Core.DistanceUnit,System.Double)">
            <summary>
            Calculate the amount of longitude change given a certain distance and longitude. 
            </summary>
            <returns>Double representing the distance.</returns>
            <remarks>None</remarks>
            <param name="distance">The distance over which you would like to know the change in longitude.</param>
            <param name="distanceUnit">The unit the distance is in, such as miles or kilometers.</param>
            <param name="longitude">The longitude on the globe that the distance is measured at.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.BufferCapType">
            <summary>
            This class represents various ways a buffer operation can cap the objects
            buffered.
            </summary>
            <remarks>
            Buffered shapes can be computed with different line-end buffer cap styles. The
            buffer cap style determines how the line-work for the buffer polygon is constructed at
            the ends of lines.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.BufferCapType.Round">
            <summary>End caps are rounded at the line ends. </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.BufferCapType.Square">
            <summary>End caps are truncated flat at the line ends.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.BufferCapType.Butt">
            <summary>End caps are squared off at the buffer distance beyond the line ends.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DrawingPenAlignment">
            <summary>
            Specifies the alignment of a GeoPen object in relation to the theoretical,
            zero-width line.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingPenAlignment.Center">
            <summary>Specifies that the GeoPen object is centered over the theoretical line.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingPenAlignment.Inset">
            <summary>
            Specifies that the GeoPen is positioned on the inside of the theoretical
            line.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingPenAlignment.Left">
            <summary>Specifies the GeoPen is positioned to the left of the theoretical line.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingPenAlignment.Outset">
            <summary>Specifies the GeoPen is positioned on the outside of the theoretical line.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingPenAlignment.Right">
            <summary>Specifies the GeoPen is positioned to the right of the theoretical line.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DegreesMinutesSeconds">
            <summary>This structure represents a degrees, minutes and seconds value.</summary>
            <remarks>
            This structure is used in many places to represent decimal degree numbers as
            degrees, minutes and seconds.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DegreesMinutesSeconds.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            This constructor allows you to create an instance of the class by specifying the
            degree, minute and second values.
            </summary>
            <remarks>None</remarks>
            <param name="degrees">This parameter represents the degree portion of the structure.</param>
            <param name="minutes">This parameter represents the minute portion of the structure.</param>
            <param name="seconds">This parameter represents the second portion of the structure.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DegreesMinutesSeconds.GetHashCode">
            <summary>
            Serves as hash function for the particular type.
            </summary>
            <returns>The hash code for this particular type.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DegreesMinutesSeconds.Equals(System.Object)">
            <summary>Compares current DegreesMinutesSeconds with a passing object.</summary>
            <returns>
            	<para>True if the passing object satisfies the following two conditions:</para>
            	<para>1) The object is of DegreesMinutesSeconds type.</para>
            	<para>2) The Degrees, Minutes and Seconds of both DegreesMinutesSeconds should be the
                same.</para>
            	<para>If both conditions are not met, will return false.</para>
            </returns>
            <param name="obj">
            The passing object which will be used to compare with current
            DegreesMinutesSeconds.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DegreesMinutesSeconds.Add(ThinkGeo.MapSuite.Core.DegreesMinutesSeconds)">
            <summary>
            Add two DegreesMinutsSeconds together and return back a summary of the
            two.
            </summary>
            <returns>The summary of the two DegreesMinutesSeconds.</returns>
            <example>
            	<code lang="CS" title="C# Sample">
            DegreesMinutesSeconds dms1 = new DegreesMinutesSeconds(15, 21, 19.1); 
            DegreesMinutesSeconds dms2 = new DegreesMinutesSeconds(12, 43, 12); 
                
            DegreesMinutesSeconds dms3 = dms1.Add(dms2); 
            // The return value should be:28d 4' 31.1''
            </code>
            	<code lang="VB" title="VB Sample">
            Dim dms1 As New DegreesMinutesSeconds(15, 21, 19.1) 
            Dim dms2 As New DegreesMinutesSeconds(12, 43, 12) 
             
            Dim dms3 As DegreesMinutesSeconds = dms1.Add(dms2) 
            ' The return value should be:28d 4' 31.1''
            </code>
            </example>
            <param name="targetDegreesMinutesSeconds">The target DegreesMinutesSeconds to be added together.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DegreesMinutesSeconds.op_Addition(ThinkGeo.MapSuite.Core.DegreesMinutesSeconds,ThinkGeo.MapSuite.Core.DegreesMinutesSeconds)">
            <summary>
            Operation + overloads for DegreesMinutesSeconds.Sum of two
            DegreesMinutesSeconds.
            </summary>
            <returns>The summary of the two DegreesMinutesSeconds.</returns>
            <example>
            	<code lang="CS" title="C# Sample">
            DegreesMinutesSeconds dms1 = new DegreesMinutesSeconds(15, 21, 19.1); 
            DegreesMinutesSeconds dms2 = new DegreesMinutesSeconds(12, 43, 12); 
                
            DegreesMinutesSeconds dms3 = dms1 + dms2; 
            // The return value should be:28d 4' 31.1''
            </code>
            	<code lang="VB" title="VB Sample">
            Dim dms1 As New DegreesMinutesSeconds(15, 21, 19.1) 
            Dim dms2 As New DegreesMinutesSeconds(12, 43, 12) 
             
            Dim dms3 As DegreesMinutesSeconds = dms1 + dms2 
            ' The return value should be:28d 4' 31.1''
            </code>
            </example>
            <param name="degreesMinutesSeconds1">The first target DegreesMinutesSeconds.</param>
            <param name="degreesMinutesSeconds2">The second target DegreesMinutesSeconds.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DegreesMinutesSeconds.op_Equality(ThinkGeo.MapSuite.Core.DegreesMinutesSeconds,ThinkGeo.MapSuite.Core.DegreesMinutesSeconds)">
            <summary>
            Operation == overloads for DegreesMinutesSeconds.Sum of two
            DegreesMinutesSeconds.
            </summary>
            <returns>
            True if the two degreesMinutesSeconds are equal in their responding Degrees,
            Minutes, Seconds. Otherwise returns false.
            </returns>
            <param name="degreesMinutesSeconds1">The first target DegreesMinutesSeconds.</param>
            <param name="degreesMinutesSeconds2">The second target DegreesMinutesSeconds.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DegreesMinutesSeconds.op_Inequality(ThinkGeo.MapSuite.Core.DegreesMinutesSeconds,ThinkGeo.MapSuite.Core.DegreesMinutesSeconds)">
            <summary>
            Operation != overloads for DegreesMinutesSeconds.Sum of two
            DegreesMinutesSeconds.
            </summary>
            <returns>
            True if any of the two degreesMinutesSeconds are not equal in their
            responding Degrees, Minutes, Seconds. Otherwise returns false.
            </returns>
            <param name="degreesMinutesSeconds1">The first target DegreesMinutesSeconds.</param>
            <param name="degreesMinutesSeconds2">The second target DegreesMinutesSeconds.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DegreesMinutesSeconds.ToString">
            <summary>
            This method returns a formatted representation of the degrees, minutes and seconds
            value.
            </summary>
            <returns>
            This method returns a formatted representation of the degrees, minutes and seconds
            value.
            </returns>
            <remarks>The value will be formatted in the standard string format: 75º 21' 28"</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DegreesMinutesSeconds.ToString(System.Int32)">
            <summary>This method returns a formatted representation of the degrees, minutes and seconds
            value that has been rounded to the specified decimals.</summary>
            <param name="decimals">
            The target decimals that the degrees, minutes, seconds value will be rounded
            to.
            </param>
            <returns>
            This method returns a formatted representation of the degrees, minutes and seconds
            value.
            </returns>
            <remarks>The value will be formatted in the standard string format. For example, 75º 21' 2.1235" (when the decimals parameter is set to 4).</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DegreesMinutesSeconds.Degrees">
            <summary>This property returns the degrees portion of the structure.</summary>
            <decimalDegreesValue>This property returns the degrees portion of the structure.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DegreesMinutesSeconds.Minutes">
            <summary>This property returns the minutes portion of the structure.</summary>
            <decimalDegreesValue>This property returns the minutes portion of the structure.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DegreesMinutesSeconds.Seconds">
            <summary>This property returns the seconds portion of the structure.</summary>
            <decimalDegreesValue>This property returns the seconds portion of the structure.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.SimpleColors">
            <summary>
            This class is a convenient way to access a predefined set of simple
            colors.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.Transparent">
            <summary>This property returns a Transparent GeoColor.</summary>
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Transparent GeoColor.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.Black">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Black GeoColor.</decimalDegreesValue>
            <summary>This property returns a Black GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.Red">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Red GeoColor.</decimalDegreesValue>
            <summary>This property returns a Red GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.Blue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Blue GeoColor.</decimalDegreesValue>
            <summary>This property returns a Blue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.Yellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Yellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a Yellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.Green">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Green GeoColor.</decimalDegreesValue>
            <summary>This property returns a Green GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.Orange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Orange GeoColor.</decimalDegreesValue>
            <summary>This property returns a Orange GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.DarkRed">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a DarkRed GeoColor.</decimalDegreesValue>
            <summary>This property returns a DarkRed GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.DarkBlue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a DarkBlue GeoColor.</decimalDegreesValue>
            <summary>This property returns a DarkBlue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.DarkYellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a DarkYellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a DarkYellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.DarkGreen">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a DarkGreen GeoColor.</decimalDegreesValue>
            <summary>This property returns a DarkGreen GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.DarkOrange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a DarkOrange GeoColor.</decimalDegreesValue>
            <summary>This property returns a DarkOrange GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.LightRed">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a LightRed GeoColor.</decimalDegreesValue>
            <summary>This property returns a LightRed GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.LightBlue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a LightBlue GeoColor.</decimalDegreesValue>
            <summary>This property returns a LightBlue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.LightYellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a LightYellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a LightYellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.LightGreen">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a LightGreen GeoColor.</decimalDegreesValue>
            <summary>This property returns a LightGreen GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.LightOrange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a transparent GeoColor.</decimalDegreesValue>
            <summary>This property returns a transparent GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.PaleRed">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PaleRed GeoColor.</decimalDegreesValue>
            <summary>This property returns a PaleRed GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.PaleBlue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PaleBlue GeoColor.</decimalDegreesValue>
            <summary>This property returns a PaleBlue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.PaleYellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PaleYellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a PaleYellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.PaleGreen">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PaleGreen GeoColor.</decimalDegreesValue>
            <summary>This property returns a PaleGreen GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.PaleOrange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PaleOrange GeoColor.</decimalDegreesValue>
            <summary>This property returns a PaleOrange GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.BrightRed">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightRed GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightRed GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.BrightBlue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightBlue GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightBlue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.BrightYellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightYellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightYellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.BrightGreen">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightGreen GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightGreen GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.BrightOrange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a BrightOrange GeoColor.</decimalDegreesValue>
            <summary>This property returns a BrightOrange GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.PastelRed">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelRed GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelRed GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.PastelBlue">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelBlue GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelBlue GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.PastelYellow">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelYellow GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelYellow GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.PastelGreen">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelGreen GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelGreen GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.PastelOrange">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a PastelOrange GeoColor.</decimalDegreesValue>
            <summary>This property returns a PastelOrange GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.Silver">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Silver GeoColor.</decimalDegreesValue>
            <summary>This property returns a Silver GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.Gold">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Gold GeoColor.</decimalDegreesValue>
            <summary>This property returns a Gold GeoColor.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SimpleColors.Copper">
            <remarks>None</remarks>
            <decimalDegreesValue>This property returns a Copper GeoColor.</decimalDegreesValue>
            <summary>This property returns a Copper GeoColor.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RtreeSpatialIndex">
            <summary>
            Rtree is a facade class of MapSuiteRtree.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.#ctor">
            <summary>
            DefauLb constructor.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.Dispose">
            <summary>
            This method is targeting releasing or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.GetBestPageSize(System.Int32)">
            <summary>
            Static method for getting the best page size according to the record count of a ShapeFile.
            </summary>
            <param name="recordCount">Record count of ShapeFile.</param>
            <returns>best page size</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.GetRoot">
            <summary>
            Get the root node.
            </summary>
            <returns>root node</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.CreateRectangleIdxFile(System.String,System.Boolean,ThinkGeo.MapSuite.Core.RtreeSpatialIndexPageSize)">
            <summary>
            Create an index file whose type is rectangle.
            </summary>
            <param name="indexFileName">Index file name</param>
            <param name="isFloat">Indicates whether it is float or not</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.ValidateRtreeIndex">
            <summary>
            Check to ensure RtreeIndex is valid.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.OpenCore">
            <summary>
            Open an existing index file as read only.
            </summary>
            <param name="fileName"> Index file name </param>
            <param name="fileAccess"> 
            	true for read only
            	false for read and write 
            </param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.CloseCore">
            <summary>
            Close a previously opened index file.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.Flush">
            <summary>
            Write memory to disk if modified.
            </summary>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.InsertPoint(System.Double,System.Double,System.String)">
            <summary>
            Insert a point.
            </summary>
            <param name="x">	x coordinate	</param>
            <param name="y">	y coordiante	</param>
            <param name="pointId">Index of record	</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.DeletePoint(System.Double,System.Double)">
            <summary>
            Delete a point.
            </summary>
            <param name="x"> x coordinate</param>
            <param name="y"> y coordinate</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.InsertRectangle(System.Double,System.Double,System.Double,System.Double,System.String)">
            <summary>
            Insert a rectangle into index file.
            </summary>
            <param name="upperLeftX">	First point's x coordinate	</param>
            <param name="upperLeftY">	First point's y coordinate	</param>
            <param name="lowerRightX">	Second point's x coordinate	</param>
            <param name="lowerRightY">	Second point's y coordinate	</param>
            <param name="rectangleId">Record index					</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.DeleteRectangle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Delete a rectangle record from index file.
            </summary>
            <param name="upperLeftX"> First point's x coordinate</param>
            <param name="upperLeftY"> First point's y coordinate</param>
            <param name="lowerRightX"> Second point's x coordinate</param>
            <param name="lowerRightY"> Second point's y coordinate</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.GetRecordIndexesCompletelyInsideRectangle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Query for shape that contains a specific rectangle.
            </summary>
            <param name="upperLeftX">The minimum decimalDegreesValue of the x coords of specific rectangle.</param>
            <param name="upperLeftY">The minimum decimalDegreesValue of the y coords of specific rectangle.</param>
            <param name="lowerRightX">The maximum decimalDegreesValue of the x coords of specific rectangle.</param>
            <param name="lowerRightY">The maximum decimalDegreesValue of the y coords of specific rectangle.</param>
            <returns>Index Array of int</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.GetRecordIndexesContainingRectangle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Query for shape that is contained by a specific rectangle.
            </summary>
            <param name="upperLeftX">The minimum decimalDegreesValue of the x coords of specific rectangle.</param>
            <param name="upperLeftY">The minimum decimalDegreesValue of the y coords of specific rectangle.</param>
            <param name="lowerRightX">The maximum decimalDegreesValue of the x coords of specific rectangle.</param>
            <param name="lowerRightY">The maximum decimalDegreesValue of the y coords of specific rectangle.</param>
            <returns>Index Array of int</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.GetRecordIndexesInsideRectangle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Query for shape that is overlapped by a specific rectangle.
            </summary>
            <param name="upperLeftX">The minimum decimalDegreesValue of the x coords of specific rectangle.</param>
            <param name="upperLeftY">The minimum decimalDegreesValue of the y coords of specific rectangle.</param>
            <param name="lowerRightX">The maximum decimalDegreesValue of the x coords of specific rectangle.</param>
            <param name="lowerRightY">The maximum decimalDegreesValue of the y coords of specific rectangle.</param>
            <returns>Index Array of int</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.GetRecordIndexesNearestToPoint(System.Double,System.Double,System.Int32)">
            <summary>
            Get records nearest to a specific point, up to the returningRecordCount.
            </summary>
            <param name="x">		x coordinate	</param>
            <param name="y">		y coordinate	</param>
            <param name="returningRecordCount">	Maximum number of records to return</param>
            <returns> index Array of int</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.GetNearests(System.Double,System.Double,System.Int32)">
            <summary>
            Query for the [MaxNum] closest shapes to a specific point.
            </summary>
            <param name="x">		x coordinate	</param>
            <param name="y">		y coordinate	</param>
            <param name="MaxNum">	Maximum number to return</param>
            <returns> index Array of int</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.GetFeatureCountCore">
            <summary>
            Get the count of all records in all leaf nodes.
            </summary>
            <returns> record count</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.GetIdsFileFromIdxFile(System.String)">
            <summary>
            Dump all nodes for debugging.
            </summary>
            <returns>dumped contents</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RtreeSpatialIndex.PageSize">
            <summary>
            Property PageSize.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Child">
            <summary>
            Internal node of the Rtree. Used to access Leaf nodes, where real data lies.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Child.#ctor(ThinkGeo.MapSuite.Core.ChildPage)">
            <summary>
            Constructor
            </summary>
            <param name="page">ChildPage object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Child.SplitNode(ThinkGeo.MapSuite.Core.Record,ThinkGeo.MapSuite.Core.Node[]@)">
            <summary>
            Split Child
            </summary>
            <param name="insertRec"></param>
            <param name="nodeList"></param>
            <returns>Leaf array that contains two child objects.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PanDirection">
            <summary>This enumeration defines panning directions.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PanDirection.Up">
            <summary>This pans up.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PanDirection.UpperRight">
            <summary>This pans to the upper right.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PanDirection.Right">
            <summary>This pans to the right.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PanDirection.LowerRight">
            <summary>This pans to the lower left.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PanDirection.Down">
            <summary>This pans down.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PanDirection.LowerLeft">
            <summary>This pans to the lower left.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PanDirection.Left">
            <summary>This pans to the left.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PanDirection.UpperLeft">
            <summary>This pans to the upper left.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.AdornmentLocation">
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AdornmentLocation.UseOffsets">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the upper left point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AdornmentLocation.UpperLeft">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the upper left point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AdornmentLocation.UpperCenter">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the upper center point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AdornmentLocation.UpperRight">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the upper right point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AdornmentLocation.CenterLeft">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the center left point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AdornmentLocation.Center">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the center point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AdornmentLocation.CenterRight">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the center right point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AdornmentLocation.LowerLeft">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the lower left point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AdornmentLocation.LowerCenter">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the lower center point.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AdornmentLocation.LowerRight">
            <summary>
            This method makes the GetDrawingLocation function calculate the drawing location by
            XOffset and YOffset from the lower right point.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.SimplificationType">
            <summary>
            Specifies which algorthm will be use to simplify.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.SimplificationType.TopologyPreserving">
            <summary>
            Simplifies a point, ensuring that the result is a valid point having the same dimension and number of components as the input. The simplification uses a maximum distance difference algorithm similar to the one used in the Douglas-Peucker algorithm. In particular, if the input is an areal point ( Polygon or MultiPolygon ) The result has the same number of shells and holes (rings) as the input, in the same order The result rings touch at no more than the number of touching point in the input (although they may touch at fewer points). 
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.SimplificationType.DouglasPeucker">
            <summary>
            Simplifies a Geometry using the standard Douglas-Peucker algorithm. Ensures that any polygonal geometries returned are valid. Simple lines are not guaranteed to remain simple after simplification. Note that in general D-P does not preserve topology - e.g. polygons can be split, collapse to lines or disappear holes can be created or disappear, and lines can cross. To simplify point while preserving topology use TopologySafeSimplifier. (However, using D-P is significantly faster). 
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WmsServerLayer">
            <remarks>
                <para>A WMS Layer includes many properties and attributes. However, the properties list below are 
                not supported by now.
                </para>
                <para>Dimension</para>
                <para>Extent</para>
                <para>Attribution</para>
                <para>AuthorityURL</para>
                <para>Identifier</para>
                <para>MetadataURL</para>
                <para>DataURL</para>
                <para>FeatureListURL</para>
            </remarks>
            <summary> 
            Represents an object that encapsulates a WMS Layer.
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.Cascaded">
            <summary>
            0: layer has not been retransmitted by a Cascading Map Server.
            n: layer has been retransmitted n times.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.MinScale">
            <summary>
            Minimum scale for which it is appropriate to display this layer.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.MaxScale">
            <summary>
            Maximum scale for which it is appropriate to display this layer.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.Title">
            <summary> 
            Title of this requesting WMS layer. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.Name">
            <summary> 
            Name of this requesting WMS layer. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.Abstract">
            <summary> 
            Abstract of this requesting WMS layer. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.Queryable">
            <summary> 
            Queryable property of this requesting WMS layer. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.Opaque">
            <summary>
            False: map data represents vector features that probably do not completely fill space.
            True: map data are mostly or completely opaque.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.NoSubsets">
            <summary>
            False: WMS can map a subset of the full bounding box.
            True: WMS can only map the entire bounding box.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.FixedWidth">
            <summary>
            0: WMS can resize map to arbitrary width.
            nonzero: map has a fixed width that cannot be changed by the WMS.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.FixedHeight">
            <summary>
            0: WMS can resize map to arbitrary height.
            nonzero: map has a fixed height that cannot be changed by the WMS.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.KeyWords">
            <summary> 
            KeyWords property of this requesting WMS layer. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.Styles">
            <summary> 
            The styles supported by the layer. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.Crs">
            ' <summary> 
            ' The Coordinate Reference Systems supported by the layer.
            ' </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsServerLayer.ChildLayers">
            <summary> 
            Return child layers. 
            </summary> 
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RowColumnRange">
            <summary>
            This structure is used to describe a range of tiles for a given extent.
            Basiclly, 4 values exists : the Row range is from MinColumnIndex to MaxColumnIndex,
            the Column range is from the MinRowIndex to MaxRowIndex.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RowColumnRange.#ctor(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Contructor of the structure to instance a RowColumnRange.
            </summary>
            <param name="minRowIndex">Min Row Index which stands for the up boundary.</param>
            <param name="maxRowIndex">Max Row Index which stands for the lower boundary.</param>
            <param name="minColumnIndex">Min Column Index which stands for the left boundary.</param>
            <param name="maxColumnIndex">Max Column Index which stands for the right boundary.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RowColumnRange.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RowColumnRange.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RowColumnRange.op_Equality(ThinkGeo.MapSuite.Core.RowColumnRange,ThinkGeo.MapSuite.Core.RowColumnRange)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <param name="rowColumnRange1">This parameter represents the first rowColumnRange to compare.</param>
            <param name="rowColumnRange2">This parameter represents the second rowColumnRange to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RowColumnRange.op_Inequality(ThinkGeo.MapSuite.Core.RowColumnRange,ThinkGeo.MapSuite.Core.RowColumnRange)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <param name="rowColumnRange1">This parameter represents the first rowColumnRange to compare.</param>
            <param name="rowColumnRange2">This parameter represents the second rowColumnRange to compare.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RowColumnRange.MinRowIndex">
            <summary>
            Gets or sets the Min Row Index which stands for the up boundary.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RowColumnRange.MaxRowIndex">
            <summary>
            Gets or sets the Max Row Index which stands for the lower boundary.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RowColumnRange.MinColumnIndex">
            <summary>
            Gets or sets the Min Column Index which stands for the left boundary.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RowColumnRange.MaxColumnIndex">
            <summary>
            Gets or sets the Max Column Index which stands for the right boundary.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.BuildRecordIdMode">
            <summary>This enumeration represents whether a record ID should be rebuilt or not.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.BuildRecordIdMode.DoNotRebuild">
            <summary>Do not rebuild the record ID if it exists.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.BuildRecordIdMode.Rebuild">
            <summary>Rebuild the record ID if it exists.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GISSys">
             <summary>
            Core class of ThinkGeo.MapSuite.Core 
             </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys._InitPJUnits">
            <summary>
            Initialize pj_Units_List object
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys._InitPJList">
            <summary>
            Initialize projection object
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys._InitPJEllps">
            <summary>
            Initialize ellipsoid object 
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys._InitPJDatums">
            <summary>
            Initialize datum object
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys._InitPJMeridians">
            <summary>
            Initialize data of Meridians list
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys.InitGISSystem(System.String)">
            <summary>
            Initialize GISSystem system
            </summary>
            <param name="args">Passing parameters</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys.Pj_Transform(ThinkGeo.MapSuite.Core.ProjType,ThinkGeo.MapSuite.Core.ProjType,System.Int64,System.Int32,ThinkGeo.MapSuite.Core.ProjUV[],System.Double[])">
            <summary>
            The source projection constants are converted for the destination projection constants
            </summary>
            <param name="srcdefn">Variables of source projection</param>
            <param name="dstdefn">Variables of destination projection</param>
            <param name="point_count">Point count</param>
            <param name="point_offset">Point offset</param>
            <param name="uvList">Data of transformation</param>
            <param name="z">Hight of transformation</param>
            <returns>Return new data</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys._InitPjConst(ThinkGeo.MapSuite.Core.PjDatum,ThinkGeo.MapSuite.Core.Unit,ThinkGeo.MapSuite.Core.Meridian,ThinkGeo.MapSuite.Core.ProjType,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Initialize the PJconsts object
            </summary>
            <param name="datum">PjDatum object</param>
            <param name="unitObj">Unit object</param>
            <param name="meridian">Meridian object</param>
            <param name="proj">ProjType object</param>
            <param name="args">general collection string object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys.Pj_Datum_Set(ThinkGeo.MapSuite.Core.PjDatums,System.Collections.Generic.Dictionary{System.String,System.String},ThinkGeo.MapSuite.Core.ProjType)">
            <summary>
            Datum setting
            </summary>
            <param name="pjDatum">PjDatums object</param>
            <param name="args">Parameter list</param>
            <param name="projObj">Projection object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys.AddDefaultParaInProj(ThinkGeo.MapSuite.Core.ProjType,System.String)">
            <summary>
            set default parameter according to default config file
            </summary>
            <param name="projObj">ProjType object</param>
            <param name="projName">Projection name</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys.Set_Para(System.IO.FileStream,System.String,ThinkGeo.MapSuite.Core.ProjType)">
            <summary>
            set parameters's value according to file stream 
            </summary>
            <param name="stream">File stream</param>
            <param name="keyField">Key word string</param>
            <param name="projObj">ProjType object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys.SetToMeter(ThinkGeo.MapSuite.Core.PJUnit,System.Collections.Generic.Dictionary{System.String,System.String},ThinkGeo.MapSuite.Core.ProjType)">
            <summary>
            Check if to_meter parameter present
            </summary>
            <param name="pjUnit">Unit object</param>
            <param name="args">Initialize the array of string parameter </param>
            <param name="projObj">Projection object</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys.GetMeridianValue(ThinkGeo.MapSuite.Core.Pj_Prime_Meridians)">
            <summary>
            Obtain the value of meridian
            </summary>
            <param name="meri">object of meridian</param>
            <returns>return the value of meridian</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys.Getvalue(System.String,System.Int32@)">
            <summary>
            According to the parameter of meridian obtain the value of meridian 
            </summary>
            <param name="meriDefn">parameter of meridian</param>
            <returns>return value of meridian</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys.Pj_Datum_Transform(ThinkGeo.MapSuite.Core.ProjType,ThinkGeo.MapSuite.Core.ProjType,System.Int64,System.Int32,ThinkGeo.MapSuite.Core.ProjUV[],System.Double[])">
            <summary>
            Datum of source projection converted for the datum of destination projection
            </summary>
            <param name="srcdefn">object of source projection</param>
            <param name="dstdefn">object of destination projection</param>
            <param name="point_count">point count</param>
            <param name="point_offset">point offset</param>
            <param name="uvList">data of transformation</param>
            <param name="height">height of transformation</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys.Pj_Geodetic_To_Geocentric(System.Double,System.Double,System.Int64,System.Int32,ThinkGeo.MapSuite.Core.ProjUV[],System.Double[])">
            <summary>
            geodetic projection to geocentric projection transform
            </summary>
            <param name="src_a">the value of src proj's a</param>
            <param name="src_es">the value of src proj's es</param>
            <param name="point_count">number of point</param>
            <param name="point_offset">the offset of point</param>
            <param name="list">parameters</param>
            <param name="height">double value height</param>
            <returns>transform success or fail</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GISSys.Pj_Geocentric_To_Geodetic(System.Double,System.Double,System.Int64,System.Int32,ThinkGeo.MapSuite.Core.ProjUV[],System.Double[])">
            <summary>
            geocentric projection to geodetic projection transform
            </summary>
            <param name="a">the value of src proj's a</param>
            <param name="es">the value of src proj's es</param>
            <param name="point_count">number of point</param>
            <param name="point_offset">the offset of point</param>
            <param name="uvList">converting point</param>
            <param name="height">double value height</param>
            <returns>transform success or fail</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RegexItem">
            <summary>This class represents a single Regex Match statement and styles to draw.</summary>
            <remarks>
            The RegexItem represents a single matching criteria for a RegexStyle.<br/>
            	<br/>
            RegexStyle:<br/>
            	<br/>
            The RegexStyle allows you to use complex regular expression matching to determine how
            your features are drawn. A regular expression is a matching syntax that allows you to
            match a string based on very complex criteria. For example, let's say you have a layer that has a
            column in the data that contains school names. Most school names include the type of school
            they are. For instance, you may have "Lincoln Middle School" or "Bush High School." There are
            variations to these names though, containing words such as "Elementary" or "Prep." With a regular
            expression, you can create matching criteria that will allow you to match on many
            variations of the names. It is especially useful for fuzzy matches where your data is
            not clearly categorized. Another classic example is for matching or validating email
            addresses, where matching rules can become complex.<br/>
            	<br/>
            In the RegexStyle, you specify the matching criteria string and also the style you want
            to use to draw the feature if the criteria matches. It is a simple yet powerful style
            for dealing with complex rule sets and imprecise data.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RegexItem.#ctor">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <overloads>
            If you use this constructor, you should set the necessary properties
            manually.
            </overloads>
            <remarks>
            If you use this constructor, you should set the necessary properties
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RegexItem.#ctor(System.String,ThinkGeo.MapSuite.Core.AreaStyle)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify an AreaStyle you want to use. You should
            use this if the features you are drawing are area-based. Alternatively, you can set the
            properties of the DefaultAreaStyle directly on the class.
            </overloads>
            <returns>None</returns>
            <remarks>
            It is recommended that you do not use this constructor unless it is absolutely necessary.
            Instead, you can set the properties directly on the DefaultAreaStyle.
            </remarks>
            <param name="regularExpression">
            This parameter is the regular expression statement you would like to
            match.
            </param>
            <param name="areaStyle">
            This parameter is the style you want to draw with if the regular expression
            matches.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RegexItem.#ctor(System.String,ThinkGeo.MapSuite.Core.LineStyle)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify a LineStyle you want to use. You should
            use this if the features you are drawing are line-based. Alternatively, you can set the
            properties of the DefaultLineStyle directly on the class.
            </overloads>
            <returns>None</returns>
            <remarks>
            It is recommended that you do not use this constructor unless it is absolutely necessary.
            Instead, you can set the properties directly on the DefaultLineStyle.
            </remarks>
            <param name="regularExpression">
            This parameter is the regular expression statement you would like to
            match.
            </param>
            <param name="lineStyle">
            This parameter is the style you want to draw with if the regular expression
            matches.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RegexItem.#ctor(System.String,ThinkGeo.MapSuite.Core.PointStyle)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify a PointStyle you want to use. You should
            use this if the features you are drawing are point-based. Alternatively, you can set the
            properties of the DefaultPointStyle directly on the class.
            </overloads>
            <returns>None</returns>
            <remarks>
            It is recommended that you do not use this constructor unless it is absolutely necessary.
            Instead, you can set the properties directly on the DefaultPointStyle.
            </remarks>
            <param name="regularExpression">
            This parameter is the regular expression statement you would like to
            match.
            </param>
            <param name="pointStyle">
            This parameter is the style you want to draw with if the regular expression
            matches.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RegexItem.#ctor(System.String,ThinkGeo.MapSuite.Core.TextStyle)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify a TextStyle you want to use. You should
            use this if the features you are drawing are text-based. Alternatively, you can set the
            properties of the DefaultTextStyle directly on the class.
            </overloads>
            <returns>None</returns>
            <remarks>
            It is recommended that you do not use this constructor unless it is absolutely necessary.
            Instead, you can set the properties directly on the DefaultTextStyle.
            </remarks>
            <param name="regularExpression">
            This parameter is the regular expression statement you would like to
            match.
            </param>
            <param name="textStyle">
            This parameter is the style you want to draw with if the regular expression
            matches.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RegexItem.#ctor(System.String,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.Style})">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify the TextStyles you want to use. You should
            use this if the features you are drawing are text-based. Alternatively, you can set the
            properties of the CustomStyles directly on the class.
            </overloads>
            <returns>None</returns>
            <remarks>
            It is recommended that you do not use this constructor unless it is absolutely necessary.
            Instead, you can set the properties directly on the CustomStyles.
            </remarks>
            <param name="regularExpression">
            This parameter is the regular expression statement you would like to
            match.
            </param>
            <param name="styles">
            This parameter represents the styles you want to draw with if the regular expression
            matches.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RegexItem.RegularExpression">
            <summary>This property gets and sets the regular expression text used for matching.</summary>
            <value>This property gets the regular expression text used for matching.</value>
            <remarks>
            This should be a valid regular expression string. Formatting regular expression
            strings is outside the scope of this documentation; however, there are many useful
            resources on the web for learning about regular expressions.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RegexItem.CustomStyles">
            <summary>This property gets the collection of custom styles.</summary>
            <value>This property gets the collection of custom styles.</value>
            <remarks>
            The custom styles allow you to use styles other than the default style
            properties of the class. In this way, you can use a DotDensityStyle or any other style in the
            API.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RegexItem.DefaultAreaStyle">
            <summary>
            This property gets and sets the default AreaStyle. You should use this style if
            your features are area-based.
            </summary>
            <value>This property gets the default AreaStyle.</value>
            <remarks>
            The default style allows you to directly set properties on the styles without
            having to create a new style each time. You can start simply by setting properties like color, etc.
            This makes modifying styles very easy.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RegexItem.DefaultLineStyle">
            <summary>
            This property gets and sets the default LineStyle. You should use this style if
            your features are line-based.
            </summary>
            <value>This property gets the default LineStyle.</value>
            <remarks>
            The default style allows you to directly set properties on the styles without
            having to create a new style each time. You can start simply by setting properties like color, etc.
            This makes modifying styles very easy.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RegexItem.DefaultPointStyle">
            <summary>
            This property gets and sets the default PointStyle. You should use this style if
            your features are point-based.
            </summary>
            <value>This property gets the default LineStyle.</value>
            <remarks>
            The default style allows you to directly set properties on the styles without
            having to create a new style each time. You can start simply by setting properties like color, etc.
            This makes modifying styles very easy.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RegexItem.DefaultTextStyle">
            <summary>
            This property gets and sets the default TextStyle. You should use this style if
            your features are text-based (such as labels).
            </summary>
            <value>This property gets the default TextStyle.</value>
            <remarks>
            The default style allows you to directly set properties on the styles without
            having to create a new style each time. You can start simply by setting properties like color, etc.
            This makes modifying styles very easy.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ClassBreakStyle">
            <summary>This class represents a style based on class break values.</summary>
            <remarks>
            	<para>The ClassBreakStyle allows you to change the way features are drawn based on
                their data values. It is often useful for you to display features differently based
                on ranges of numeric values. For example, you may have a states ShapeFile that has
                the populations of each state as part of its data. You may then want to color
                states differently based on their population. The ClassBreakStyle allows you to do
                this.<br/>
            		<br/>
                How class breaks work:<br/>
            	<br/>
                You add a number of ClassBreak classes to the ClassBreak collection. The numeric values
                of the breaks are important and you must place the breaks in numerical order. For
                example, break 0 must be added before break 100. In each ClassBreak, you specify the
                style you want to represent that break. Additionally, in the ColumnName property, you specify the
                name of the column where we will find the data used to compare the breaks. The column
                name must point to a column that is numeric.<br/>
            	<br/>
                When we proceed to draw the style, we look through the ClassBreaks and select the ClassBreak
                that is where the features column data is greater than and closest to the break
                value.<br/>
            	<br/>
                Example:<br/>
            	<br/>
                Feature Value = 42<br/>
            	<br/>
                ClassBreak1.Value = 0<br/>
                ClassBreak2.Value = 20<br/>
                ClassBreak3.Value = 40<br/>
                ClassBreak4.Value = 60<br/>
            	<br/>
                In this case, the break closest to the feature value without exceeding it is
                ClassBreak3(40). If the feature value had been less than zero, nothing would have been
                drawn. If the feature value were 1000, then ClassBreak4 would draw.<br/>
            	<br/>
                If you wanted to represent a value that is less then zero, you could do that as shown in the
                sample below.<br/>
            	<br/>
                Feature Value = -1<br/>
            	<br/>
                ClassBreak1.Value = Double.Min<br/>
                ClassBreak2.Value = 0<br/>
                ClassBreak3.Value = 20<br/>
                ClassBreak4.Value = 40<br/>
            	<br/>
                In this example, the first class break would be used.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClassBreakStyle.#ctor">
            <summary>This is the constructor for this class.</summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClassBreakStyle.#ctor(System.String)">
            <summary>This is the constructor for this class.</summary>
            <overloads>
            This constructor allows you to specify the column name of the column that will be
            used for the break values.
            </overloads>
            <returns>None</returns>
            <param name="columnName">
            This parameter is the column name of the column that will be used for the break
            values.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClassBreakStyle.#ctor(System.String,ThinkGeo.MapSuite.Core.BreakValueInclusion)">
            <summary>This is the constructor for this class.</summary>
            <overloads>
            This constructor allows you to specify the column name of the column that will be
            used for the break values. It also lets you specify whether the break value is included in
            the class break calculation.
            </overloads>
            <returns>None</returns>
            <param name="columnName">
            This parameter is the column name of the column that will be used for the break
            values.
            </param>
            <param name="breakValueInclusion">
            This parameter lets you specify whether the break value is included in the class break
            calculation.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClassBreakStyle.#ctor(System.String,ThinkGeo.MapSuite.Core.BreakValueInclusion,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.ClassBreak})">
            <summary>This is the constructor for this class.</summary>
            <overloads>
            This constructor allows you to specify the column name of the column that will be
            used for the break values. It also lets you specify whether the break value is included in
            the class break calculation.
            </overloads>
            <returns>None</returns>
            <param name="columnName">
            This parameter is the column name of the column that will be used for the break
            values.
            </param>
            <param name="breakValueInclusion">
            This parameter lets you specify whether the break value is included in the class break
            calculation.
            </param>
            <param name="classBreaks">The parameter represents the class break that will determine which style to be used
            on the break values. Please see the ClassBreakStyle class remarks for a full description of how the
            ClassBreakStyle works.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClassBreakStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If OutlinePen is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If FillSolidBrush is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If the ClassBreaks are invalid, we will throw an ArgumentException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ClassBreakStyle.GetRequiredColumnNamesCore">
            <remarks>
            This abstract method is called from the concrete public method
            GetRequiredFieldNames. In this method, we return the column names that are required for
            the style to draw the feature properly. For example, if you have a style that colors
            areas blue when a certain column value is over 100, then you need to be sure you include
            that column name. This will ensure that the column data is returned to you in the
            feature when it is ready to draw.<br/>
            	<br/>
            In many of the styles, we add properties to allow the user to specify which field they
            need; then, in the GetRequiredColumnNamesCore, we read that property and add it to the
            collection.
            </remarks>
            <summary>
            This method returns the column data for each feature that is required for the
            style to properly draw.
            </summary>
            <returns>This method returns a collection of the column names that it needs.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ClassBreakStyle.ColumnName">
            <summary>
            This property gets and sets the column name in the FeatureSource where the data
            will be found for each feature.
            </summary>
            <value>
            This property gets the column name in the FeatureSource where the data will be found
            for each feature.<br/>
            	<br/>
            Please see the ClassBreakStyle class remarks for a full description of how the
            ClassBreakStyle works.
            </value>
            <remarks>
            You use this property to set the name of the column where the numeric data is
            stored for your features.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ClassBreakStyle.BreakValueInclusion">
            <summary>
            This property gets and sets the value of if the break values are included in the
            break calculation.
            </summary>
            <value>
            This property gets the value of if the break values are included in the break
            calculation.
            </value>
            <remarks>
            Example: If you have a class break value set to 100 and the break value is included,
            then 100 is included for this break. If you set the value to excluded, then 100 would match with
            the break below 100 instead.<br/>
            	<br/>
            Please see the ClassBreakStyle class remarks for a full description of how the
            ClassBreakStyle works.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ClassBreakStyle.ClassBreaks">
            <summary>This property gets the collection of class breaks.</summary>
            <value>This property gets the collection of class breaks.</value>
            <remarks>
            The class breaks determine which style to use, based on the break values.<br/>
            	<br/>
            Please see the ClassBreakStyle class remarks for a full description of how the
            ClassBreakStyle works.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.AreaStyleAdvanced">
            <summary>This class represents the advanced drawing options for area styles.</summary>
            <remarks>
            This class allows you to set the FillCustomBrush. This enables you to use custom
            brushes to achieve effects such as linear gradients and bitmap fills.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyleAdvanced.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.AreaStyleAdvanced.CloneDeep">
            <summary>Create a copy of AreaStyleAdvanced class using the deep clone process.</summary>
            <returns>A cloned AreaStyleAdvanced.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.AreaStyleAdvanced.FillCustomBrush">
            <summary>This property allows you to get and set a custom fill brush.</summary>
            <value>This property returns a custom fill brush.</value>
            <remarks>
            This allows you to use custom brushes to achieve effects such as linear gradients and
            bitmap fills. If you use any brush besides the SolidBrush, you would set it in this
            property.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DrawingLevel">
            <summary>This enumeration represents the drawing level used in the GeoCanvas.</summary>
            <remarks>
            This enumeration is used to control the drawing level. If you draw an item on the first
            level and another item on the second level, the second level item will occlude the first. In this way,
            you can layer various drawing symbols to get unique effects. For example, you can create
            a road by first drawing a wide black line on level one, followed by a thinner white line on
            level two. The white line will draw on top of the black line and create the illusion
            of an outlined road. Adding a centered dashed line on level three will create a
            centerline.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLevel.LevelOne">
            <summary>The first drawing level.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLevel.LevelTwo">
            <summary>The second drawing level.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLevel.LevelThree">
            <summary>The third drawing level.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLevel.LevelFour">
            <summary>The fourth drawing level.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLevel.LabelLevel">
            <summary>The level for label drawing</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.OpenedRasterSourceEventArgs">
            <summary>
            This class represents the parameters passed in the OpenedRasterSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.OpenedRasterSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MrSidRasterSource">
            <summary>This class represents the MrSid raster source.</summary>
            <remarks>
            This class allows you to access pictures from a MrSid file. This class is
            typically used in the MrSidLayer to allow MrSid images to be shown on your map.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterSource.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>This is the default constructor and is not typically used.</overloads>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterSource.#ctor(System.String)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <remarks>
            This is typically the constructor you want to use for this class. It allows you
            to pass in the MrSid file you wish to work with. Note that the MrSid file is not accessed
            or opened until you call the open command of the class.
            </remarks>
            <param name="imagePathFilename">
            This parameter represents the path and file name of the MrSid file you want to load
            into the class for display.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterSource.#ctor(System.String,System.String)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <remarks>
            This is typically the constructor you want to use for this class. It allows you
            to pass in the MrSid file and world file path and filename you wish to work with. Note that the MrSid file is not accessed
            or opened until you call the open command of the class.
            </remarks>
            <param name="imagePathFilename">
            This parameter represents the path and file name of the MrSid file you want to load
            into the class for display.
            </param>
            <param name="worldFilePathFilename">
            This parameter represents the world file path and file name of the MrSid file you want to use 
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterSource.#ctor(System.String,ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the file and path information and extent information for the raster source.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the RasterSource ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and file name of the Sid source you want to use.</param>
            <param name="imageExtent">This parameter is the image extent of sid source you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterSource.Dispose">
            <summary>
            Release the unmanage resource by setting the rasterImage to null.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterSource.GetImageWidthCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the width of the image in screen coordinates.</summary>
            <returns>This method returns the width of the image in screen coordinates.</returns>
            <remarks>This method returns the width of the image in screen coordinates.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterSource.GetImageHeightCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the height of the image in screen coordinates.</summary>
            <returns>This method returns the height of the image in screen coordinates.</returns>
            <remarks>This method returns the height of the image in screen coordinates.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterSource.OpenCore">
            <summary>
            This method opens the ImageSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concreate public method Open.
            The open method play an important role as it is responsible for initializing the
            ImageSource. Most methods on the ImageSource will throw an exception if the state of
            the ImageSource is not opened. When the map draws each layer it will open the
            ImageSource as one of its first steps, then after it is finished drawing with that
            layer it will close it. In this way we are sure to release all resources used by the
            ImageSource.<br/>
            	<br/>
            When implementing this abstract method consider opening files for file based source,
            connecting to databases in the database based sources and so on. You will get a chance
            to close these in the Close method of the ImageSource.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has already been opened it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterSource.CloseCore">
            <summary>
            This method opens the ImageSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concreate public method Close.
            The close method plays an important role in the life cycle of the ImageSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            It is recommended that if you override this method that you take the following things
            into account. This method may be called multiple times so we suggest you write the so
            that that a call to a closed FeatureSource is ignored and does not generate an error.
            We also suggest that in the close you free all resources that have been opened.
            Remember that the object will not be destroyed but will be re-opened possibly in the
            near future.
            
            This API will only take effect when the suppressClose are set to false.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterSource.GetImageCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass in a worldExtent which is invalid we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a worldExtent which is invalid we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image width which is smaller than or equal to 0 we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image height which is smaller than or equal to 0 we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened it will throw an InvalidOperationException.</exception>
            <remarks>
            This method is responsible for returning the image based on the parameters passed
            in.
            </remarks>
            <summary>
            This method returns an image based on the worldExtent and image width and
            height.
            </summary>
            <returns>
            This method returns an image based on the worldExtent and image width and
            height.
            </returns>
            <param name="worldExtent">This parameter represents the worldExtent you want to draw.</param>
            <param name="canvasWidth">This parameter represents the width of the image you want to draw.</param>
            <param name="canvasHeight">This parameter represents the height of the image you want to draw.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MrSidRasterSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the RasterSource.</summary>
            <returns>This method returns the bounding box of the RasterSource.</returns>
            <remarks>This method returns the bounding box of the RasterSource.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MrSidRasterSource.PathFilename">
            <summary>
            This property gets or sets the file name and path of the MrSid image you are
            working with.
            </summary>
            <decimalDegreesValue>
            This property returns the file name and path of the MrSid image you are working
            with.
            </decimalDegreesValue>
            <remarks>
            If you wish to change the file the class is working with you would want to change
            it here. You cannot change the file you are working with while the class is in an open
            state.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has been opened it will throw an InvalidOperationException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MrSidRasterSource.SuppressClose">
            <summary>
            Gets or sets the SuppressClose property.
            </summary>
            <remarks>If set the SuppressClose to ture, then the RasterSource will not 
            be closed even you call the Close API.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.TextStyles">
            <summary>
            The class provides commonly-used <strong>TextStyles</strong> and some methods to
            create various kinds of <strong>TextStyles</strong>. A <strong>TextStyle</strong> is a kind of
            sheet used to render a font on the map.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.City1(System.String)">
            <summary>
            Get the commonly-used city <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.City2(System.String)">
            <summary>
            Get the commonly-used city <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.City3(System.String)">
            <summary>
            Get the commonly-used city <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.City4(System.String)">
            <summary>
            Get the commonly-used city <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.City5(System.String)">
            <summary>
            Get the commonly-used city <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.City6(System.String)">
            <summary>
            Get the commonly-used city <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.City7(System.String)">
            <summary>
            Get the commonly-used city <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Capital1(System.String)">
            <summary>
            Get the commonly-used capital <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Capital2(System.String)">
            <summary>
            Get the commonly-used capital <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Capital3(System.String)">
            <summary>
            Get the commonly-used capital <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.NoData1(System.String)">
            <summary>
            Get the commonly-used nodata <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Water1(System.String)">
            <summary>
            Get the commonly-used water <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Water2(System.String)">
            <summary>
            Get the commonly-used water <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Military1(System.String)">
            <summary>
            Get the commonly-used military <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Wildlife1(System.String)">
            <summary>
            Get the commonly-used wildlife <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.State1(System.String)">
            <summary>
            Get the commonly-used state <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.State2(System.String)">
            <summary>
            Get the commonly-used state <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Swamp1(System.String)">
            <summary>
            Get the commonly-used swamp <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Swamp2(System.String)">
            <summary>
            Get the commonly-used swamp <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Urban1(System.String)">
            <summary>
            Get the commonly-used urban <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Urban2(System.String)">
            <summary>
            Get the commonly-used urban <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Country1(System.String)">
            <summary>
            Get the commonly-used country <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Country2(System.String)">
            <summary>
            Get the commonly-used country <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.County1(System.String)">
            <summary>
            Get the commonly-used county <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.County2(System.String)">
            <summary>
            Get the commonly-used county <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Antarctical(System.String)">
            <summary>
            Get the commonly-used antarctical <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Evergreen1(System.String)">
            <summary>
            Get the commonly-used evergreen <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Evergreen2(System.String)">
            <summary>
            Get the commonly-used evergreen <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Grass1(System.String)">
            <summary>
            Get the commonly-used grass <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.WaterIntermittent1(System.String)">
            <summary>
            Get the commonly-used waterIntermittent <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Sand1(System.String)">
            <summary>
            Get the commonly-used sand <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.SeaIce1(System.String)">
            <summary>
            Get the commonly-used seaice <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.SnowIce1(System.String)">
            <summary>
            Get the commonly-used snowice <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Tundra1(System.String)">
            <summary>
            Get the commonly-used tundra <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Crop1(System.String)">
            <summary>
            Get the commonly-used crop <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Forest1(System.String)">
            <summary>
            Get the commonly-used forest <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
            <param name="textColumnName">The column name in the DBF that contains the text you wish to display on the label.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Park1(System.String)">
            <summary>
            Get the commonly-used park <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.LocalRoad1(System.String)">
            <summary>
            Get the commonly-used localroad <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.LocalRoad2(System.String)">
            <summary>
            Get the commonly-used localroad <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.LocalRoad3(System.String)">
            <summary>
            Get the commonly-used localroad <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.LocalRoad4(System.String)">
            <summary>
            Get the commonly-used localroad <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.SecondaryRoad1(System.String)">
            <summary>
            Get the commonly-used secondary road <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.SecondaryRoad2(System.String)">
            <summary>
            Get the commonly-used secondary road <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.MajorStreet1(System.String)">
            <summary>
            Get the commonly-used major street <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.MajorStreet2(System.String)">
            <summary>
            Get the commonly-used major street <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.MajorStreet3(System.String)">
            <summary>
            Get the commonly-used major street <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.MajorRoad1(System.String)">
            <summary>
            Get the commonly-used major road <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.MajorRoad2(System.String)">
            <summary>
            Get the commonly-used major road <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.MajorRoad3(System.String)">
            <summary>
            Get the commonly-used major road <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.MajorRoad4(System.String)">
            <summary>
            Get the commonly-used major road <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Highway1(System.String)">
            <summary>
            Get the commonly-used highway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Highway2(System.String)">
            <summary>
            Get the commonly-used highway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Highway3(System.String)">
            <summary>
            Get the commonly-used highway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Highway4(System.String)">
            <summary>
            Get the commonly-used highway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Highway5(System.String)">
            <summary>
            Get the commonly-used highway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Interstate1(System.String)">
            <summary>
            Get the commonly-used interstate <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Interstate2(System.String)">
            <summary>
            Get the commonly-used interstate <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Interstate3(System.String)">
            <summary>
            Get the commonly-used interstate <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Interstate4(System.String)">
            <summary>
            Get the commonly-used interstate <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.InternationalBorder1(System.String)">
            <summary>
            Get the commonly-used internationalBorder <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.InternationalBorder2(System.String)">
            <summary>
            Get the commonly-used internationalBorder <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Railway1(System.String)">
            <summary>
            Get the commonly-used railway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Railway2(System.String)">
            <summary>
            Get the commonly-used railway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Railway3(System.String)">
            <summary>
            Get the commonly-used railway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Railway4(System.String)">
            <summary>
            Get the commonly-used railway <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.StateBorder1(System.String)">
            <summary>
            Get the commonly-used state border <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.River1(System.String)">
            <summary>
            Get the commonly-used state river <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.River2(System.String)">
            <summary>
            Get the commonly-used state river <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Canal1(System.String)">
            <summary>
            Get the commonly-used state canal <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.ContestedBorder1(System.String)">
            <summary>
            Get the commonly-used state contested border <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.ContestedBorder2(System.String)">
            <summary>
            Get the commonly-used state contested border <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.DegreeLine1(System.String)">
            <summary>
            Get the commonly-used state degree line <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Equator1(System.String)">
            <summary>
            Get the commonly-used state equator <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.RiverIntermittent1(System.String)">
            <summary>
            Get the commonly-used river intermittent <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Pipeline1(System.String)">
            <summary>
            Get the commonly-used pipeline <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Pipeline2(System.String)">
            <summary>
            Get the commonly-used pipeline <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Pipeline3(System.String)">
            <summary>
            Get the commonly-used pipeline <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Utility1(System.String)">
            <summary>
            Get the commonly-used utility <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Utility2(System.String)">
            <summary>
            Get the commonly-used utility <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.Utility3(System.String)">
            <summary>
            Get the commonly-used utility <strong>TextStyle</strong> based on the given columnName point-type data.
            </summary>
            <returns>The desired commonly-used <strong>Textstyle</strong>.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.CreateSimpleTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Core.DrawingFontStyles,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.CreateSimpleTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Core.DrawingFontStyles,ThinkGeo.MapSuite.Core.GeoColor,System.Single,System.Single)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
             <param name="xOffset">The float value stands for the xOffset of the font on the map in pixel</param>
             <param name="yOffset">The float value stands for the yOffset of the font on the map in pixel</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.CreateSimpleTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Core.DrawingFontStyles,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
             <param name="haloPenColor">The <strong>GeoColor</strong> used to set the halopen color.</param>
             <param name="haloPenWidth">The float value to set the halopen width value.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.CreateSimpleTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Core.DrawingFontStyles,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single,System.Single,System.Single)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
             <param name="haloPenColor">The <strong>GeoColor</strong> used to set the halopen color.</param>
             <param name="haloPenWidth">The float value to set the halopen width value.</param>
             <param name="xOffset">The float value stands for the xOffset of the font on the map in pixel</param>
             <param name="yOffset">The float value stands for the yOffset of the font on the map in pixel</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.CreateMaskTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Core.DrawingFontStyles,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
             <param name="maskFillColor">The <strong>GeoColor</strong> used to set the mask fill color.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.CreateMaskTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Core.DrawingFontStyles,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single,System.Single)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
             <param name="maskFillColor">The <strong>GeoColor</strong> used to set the mask fill color.</param>
             <param name="xOffset">The float value stands for the xOffset of the font on the map in pixel</param>
             <param name="yOffset">The float value stands for the yOffset of the font on the map in pixel</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.CreateMaskTextStyle(System.String,ThinkGeo.MapSuite.Core.GeoFont,ThinkGeo.MapSuite.Core.GeoSolidBrush,ThinkGeo.MapSuite.Core.AreaStyle,System.Single,System.Single)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="textFont">The <strong>GeoFont</strong> used to set the font of the text.</param>
             <param name="textBrush">The <strong>GeoSolidBrush</strong> used to set the brush of the text.</param>
             <param name="areaStyle">The areaStyle used as mask of of the TextStyle.</param>
             <param name="xOffset">The float value stands for the xOffset of the font on the map in pixel</param>
             <param name="yOffset">The float value stands for the yOffset of the font on the map in pixel</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.CreateMaskTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Core.DrawingFontStyles,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
             <param name="maskPenColor">The <strong>GeoColor</strong> used to set the mask pen color.</param>
             <param name="maskPenSize">The float value used to set the mask pen size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyles.CreateMaskTextStyle(System.String,System.String,System.Single,ThinkGeo.MapSuite.Core.DrawingFontStyles,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor,System.Single,System.Single,System.Single)">
            <summary>Get simple <strong>TextStyle</strong>.</summary>
            <returns>The desired <strong>TextStyle</strong>.</returns>
             <param name="textColumnName">The string stands for the column name.</param>
             <param name="fontFamilyName">The string stands for the font family name. For example : "Arial".</param>
             <param name="fontSize">The float number stands for the font size.</param>
             <param name="drawingFontStyle">The <strong>DrawingFontStyles</strong> used to set the style of the font.</param>
             <param name="fontColor">The <strong>GeoColor</strong> used to set the font color.</param>
             <param name="maskPenColor">The <strong>GeoColor</strong> used to set the mask pen color.</param>
             <param name="maskPenSize">The float value used to set the mask pen size.</param>
             <param name="xOffset">The float value stands for the xOffset of the font on the map in pixel</param>
             <param name="yOffset">The float value stands for the yOffset of the font on the map in pixel</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoHatchStyle">
            <summary>
            This enumeration defines the various kinds of hatch patterns that can be used to
            fill areas using the GeoHatchBrush.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Horizontal">
            <summary>A Horizontal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Vertical">
            <summary>A Vertical pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.ForwardDiagonal">
            <summary>A Forward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.BackwardDiagonal">
            <summary>A Backward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.LargeGrid">
            <summary>A Large Grid pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.DiagonalCross">
            <summary>A Diagonal Cross pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Percent05">
            <summary>A 05 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Percent10">
            <summary>A 10 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Percent20">
            <summary>A 20 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Percent25">
            <summary>A 25 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Percent30">
            <summary>A 30 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Percent40">
            <summary>A 40 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Percent50">
            <summary>A 50 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Percent60">
            <summary>A 60 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Percent70">
            <summary>A 70 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Percent75">
            <summary>A 75 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Percent80">
            <summary>A 80 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Percent90">
            <summary>A 90 Percent pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.LightDownwardDiagonal">
            <summary>A Light Downward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.LightUpwardDiagonal">
            <summary>A Light Upward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.DarkDownwardDiagonal">
            <summary>A Dark Downward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.DarkUpwardDiagonal">
            <summary>A Dark Upward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.WideDownwardDiagonal">
            <summary>A Wide Downward Diagonal pattern fill.</summary>        
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.WideUpwardDiagonal">
            <summary>A Wide Upward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.LightVertical">
            <summary>A Light Vertical pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.LightHorizontal">
            <summary>A Light Horizontal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.NarrowVertical">
            <summary>A Narrow Vertical pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.NarrowHorizontal">
            <summary>A Narrow Horizontal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.DarkVertical">
            <summary>A Dark Vertical pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.DarkHorizontal">
            <summary>A Dark Horizontal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.DashedDownwardDiagonal">
            <summary>A Dashed Downward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.DashedUpwardDiagonal">
            <summary>A Dashed Upward Diagonal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.DashedHorizontal">
            <summary>A Dashed Horizontal pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.DashedVertical">
            <summary>A Dashed Vertical pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.SmallConfetti">
            <summary>A Small Confetti pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.LargeConfetti">
            <summary>A Large Confetti pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.ZigZag">
            <summary>A Zig Zag pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Wave">
            <summary>A Wave pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.DiagonalBrick">
            <summary>A Diagonal Brick pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.HorizontalBrick">
            <summary>A Horizontal Brick pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Weave">
            <summary>A Weave pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Plaid">
            <summary>A Plaid pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Divot">
            <summary>A Divot pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.DottedGrid">
            <summary>A Dotted Grid pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.DottedDiamond">
            <summary>A Dotted Diamond pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Shingle">
            <summary>A Shingle pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Trellis">
            <summary>A Trellis pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Sphere">
            <summary>A Sphere pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.SmallGrid">
            <summary>A Small Grid pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.SmallCheckerBoard">
            <summary>A Small Checker Board pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.LargeCheckerBoard">
            <summary>A Large Checker Board pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.OutlinedDiamond">
            <summary>A Outlined Diamond pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.SolidDiamond">
            <summary>A Solid Diamond pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Min">
            <summary>A Min pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Max">
            <summary>A Max pattern fill.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoHatchStyle.Cross">
            <summary>A Cross pattern fill.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoTextureBrush">
            <summary>This class is used to fill an area with a image texture.</summary>
            <remarks>
            This class is used to fill an area with a image texture. For example, you may have
            a small bitmap that looks like marble, which you can then use to fill in an area
            feature.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTextureBrush.#ctor(ThinkGeo.MapSuite.Core.GeoImage)">
            <summary>This is a constructor for the class.</summary>
            <overloads>This overload allows you to pass in the image for the texture.</overloads>
            <returns>None</returns>
            <remarks>
            You will use this constructor when you want to use the Tile wrap mode and you
            want the image fill to encompass the entire shape.
            </remarks>
            <param name="image">This parameter is the image you want to use as the texture.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTextureBrush.#ctor(ThinkGeo.MapSuite.Core.GeoImage,ThinkGeo.MapSuite.Core.DrawingRectangleF)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the image as well as a screen rectangle that
            determines how much of the area is filled.
            </overloads>
            <returns>None</returns>
            <remarks>
            This method allows you to pass in a rectangle in screen coordinates to determine
            how much of the area is textured.
            </remarks>
            <param name="image">This parameter is the image you want to use as the texture.</param>
            <param name="rectangleF">
            This parameter is a rectangle (in screen coordinates) that specifies the area you want
            to use for the texture.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTextureBrush.#ctor(ThinkGeo.MapSuite.Core.GeoImage,ThinkGeo.MapSuite.Core.GeoWrapMode)">
            <summary>This is a constructor for the class.</summary>
            <overloads>This constructor allows you to pass in the image and the wrap mode.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="image">This parameter is the image you want to use as the texture.</param>
            <param name="wrapMode">
            This parameter determines the way the texture wraps when the area to fill is
            larger than the texture.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTextureBrush.#ctor(ThinkGeo.MapSuite.Core.GeoImage,ThinkGeo.MapSuite.Core.GeoWrapMode,ThinkGeo.MapSuite.Core.DrawingRectangleF)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the image as well as a screen rectangle that
            determines how much of the area is filled along with the wrap mode.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="image">This parameter is the image you want to use as the texture.</param>
            <param name="wrapMode">
            This parameter determines the way the texture wraps when the area to fill is
            larger than the texture.
            </param>
            <param name="rectangleF">
            This parameter is a rectangle (in screen coordinates) that specifies the area you want
            to use for the texture.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoTextureBrush.GeoImage">
            <summary>This property gets and sets the GeoImage used for the texture fill.</summary>
            <value>This property gets the GeoImage used for the texture fill.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoTextureBrush.DrawingRectangleF">
            <summary>This property gets and sets the screen rectangle used to fill the texture.</summary>
            <value>This property gets the screen rectangle used to fill the texture.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoTextureBrush.GeoWrapMode">
            <summary>
            This property gets and sets the wrap mode that is used to determine how an area
            is filled if the area is larger than the texture.
            </summary>
            <value>
            This property gets the wrap mode that is used to determine how an area is filled
            if the area is larger than the texture.
            </value>
            <remarks>
            This property gets and sets the wrap mode that is used to determine how an area
            is filled if the area is larger than the texture.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RECORDSET_HEADER">
            <summary>
            RecordSet header; must be 8 bytes.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECORDSET_HEADER.Init">
            <summary>
            Init RECORDSET_HEADER
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECORDSET_HEADER.GetSize">
            <summary>
            Return the size of this struct.
            </summary>
            <returns> Size of RECORDSET_HEADER</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECORDSET_HEADER.Read(System.IO.BinaryReader)">
            <summary>
            Read contents from BinaryReader object.
            </summary>
            <param name="r">BinaryReader object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECORDSET_HEADER.Write(System.IO.BinaryWriter)">
            <summary>
            Write contents into BinaryWriter object.
            </summary>
            <param name="w">BinaryWriter object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECORDSET_HEADER.ToString">
            <summary>
            For debugging.
            </summary>
            <returns> dumped string</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Gist_Ext_Id">
            <summary>
            File type Id
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MapEngine">
            <summary>This class is for generating maps.</summary>
            <remarks>
            The MapEngine class is similar to a Map Control in Map Suite Desktop Edition or Web
            Edition.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.#ctor">
            <summary>Create a new instance of the <strong>MapEngine</strong>.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.OnAdornmentLayersDrawing(ThinkGeo.MapSuite.Core.AdornmentLayersDrawingEventArgs)">
            <summary>
            This event is raised before AdornmentLayers are drawn.
            </summary>
            <param name="e">The AdornmentLayersDrawingEventArgs passed for the event raised.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.OnAdornmentLayersDrawn(ThinkGeo.MapSuite.Core.AdornmentLayersDrawnEventArgs)">
            <summary>
            This event is raised after AdornmentLayers are drawn.
            </summary>
            <param name="e">The AdornmentLayersDrawnEventArgs passed for the event raised.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.OnAdornmentLayerDrawing(ThinkGeo.MapSuite.Core.AdornmentLayerDrawingEventArgs)">
            <summary>
            This event is raised before an AdornmentLayer is drawn.
            </summary>
            <param name="e">The AdornmentLayerDrawingEventArgs passed for the event raised.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.OnAdornmentLayerDrawn(ThinkGeo.MapSuite.Core.AdornmentLayerDrawnEventArgs)">
            <summary>
            This event is raised after an AdornmentLayer is drawn.
            </summary>
            <param name="e">The AdornmentLayerDrawnEventArgs passed for the event raised.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.OnLayersDrawing(ThinkGeo.MapSuite.Core.LayersDrawingEventArgs)">
            <summary>
            This event is raised before Layers are drawn.
            </summary>
            <param name="e">The LayersDrawingEventArgs passed for the event raised.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.OnLayersDrawn(ThinkGeo.MapSuite.Core.LayersDrawnEventArgs)">
            <summary>
            This event is raised after Layers are drawn.
            </summary>
            <param name="e">The LayersDrawnEventArgs passed for the event raised.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.OnLayerDrawing(ThinkGeo.MapSuite.Core.LayerDrawingEventArgs)">
            <summary>
            This event is raised before a Layer is drawn.
            </summary>
            <param name="e">The LayerDrawingEventArgs passed for the event raised.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.OnLayerDrawn(ThinkGeo.MapSuite.Core.LayerDrawnEventArgs)">
            <summary>
            This event is raised after a Layer is drawn.
            </summary>
            <param name="e">The LayerDrawnEventArgs passed for the event raised.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.FindStaticFeatureLayer(System.String)">
            <summary>
            Finds a feature layer by key (specified in the "name" parameter) within the collection of
            StaticLayers.
            </summary>
            <returns>The corresponding FeatureLayer with the specified key in the MapControl.</returns>
            <param name="name">The key to find the final result feature layer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.FindStaticRasterLayer(System.String)">
            <summary>
            Find the raster layer by key (specified in the "name" parameter) within the collection of
            StaticLayers.
            </summary>
            <returns>The corresponding RasterLayer with the passing specified in the MapControl.</returns>
            <param name="name">The key to find the final result raster layer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.FindDynamicFeatureLayer(System.String)">
            <summary>
            Find the feature layer by key (specified in the "name" parameter) within the collection of
            DynamicLayers.
            </summary>
            <returns>The corresponding FeatureLayer with the specified key in the MapControl.</returns>
            <param name="name">The key to find the final result feature layer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.FindDynamicRasterLayer(System.String)">
            <summary>
            Find the raster layer by key (specified in the "name" parameter) within the collection of
            DynamicLayers.
            </summary>
            <returns>The corresponding RasterLayer with the specified key in the MapControl.</returns>
            <param name="name">The key to find the final result raster layer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.GetDrawingExtent(System.Single,System.Single)">
            <summary>
            This method returns an adjusted extent based on the ratio of the screen width and
            height.
            </summary>
            <returns>
            This method returns an adjusted extent based on the ratio of the screen width and
            height.
            </returns>
            <remarks>
            This function is used because the extent to draw must be the rame ratio as the screen
            width and height. If they are not, then the image drawn will be stretched or compressed.
            We always adjust the extent upwards to ensure that no matter how we adjust it,
            the original extent will fit within the new extent. This ensures that everything
            you wanted to see in the first extent is visible and maybe a bit more.
            </remarks>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.GetDrawingExtent(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Single)">
            <summary>
            This method returns an adjusted extent based on the ratio of the screen width and
            height.
            </summary>
            <returns>
            This method returns an adjusted extent based on the ratio of the screen width and
            height.
            </returns>
            <remarks>
            This function is used because the extent to draw must be the rame ratio as the screen
            width and height. If they are not, then the image drawn will be stretched or compressed.
            We always adjust the extent upwards to ensure that no matter how we adjust it,
            the original extent will fit within the new extent. This ensures that everything
            you wanted to see in the first extent is visible and maybe a bit more.
            
            This function takes a height and width in screen coordinates, then
            looks at a world extent passed, and returns an adjusted world rectangle
            so that the ratio to height and width in screen and world coordinates match.
            </remarks>
            <param name="worldExtent">This parameter is the world extent you want to adjust for drawing.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.OpenAllLayers">
            <summary>
            This API allows you to open all of the layers (either static or dynamic).
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.CloseAllLayers">
            <summary>
            This API allows you close all of the layers (either static or dynamic).
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.CenterAt(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
             <summary>This is a static function that allows you to pass in a world rectangle, a world point to center on, and a height
             and width in screen units.  The function will center the rectangle based on the point, then adjust the rectangle's 
             ratio based on the height and width in screen coordinates.
            </summary>
             <overloads>This overload allows you to pass in a world point as the center.</overloads>
             <returns>This method returns an adjusted extent centered on a point.</returns>
             <remarks>None</remarks>
             <param name="worldExtent">This parameter is the current extent you want to center.</param>
             <param name="worldPoint">This parameter is the world point you want to center on.</param>
             <param name="screenWidth">This parameter is the width of the screen.</param>
             <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.CenterAt(ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
            <summary>This is a function that allows you to pass a world point to center on and a height
            and width in screen units.  The function will update the current extent by centering on the point and
            adjusting its ratio based on the height and width in screen coordinates.
            </summary>
            <returns>None.</returns>
            <remarks>This API will update the <strong>CurrentExtent</strong>.</remarks>
            <param name="worldPoint">This parameter is the world point you want to center on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.CenterAt(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
             <summary>This is a static function that allows you to pass in a world rectangle, a world point to center on, and a height
             and width in screen units.  The function will center the rectangle based on the point, then adjust the rectangle's 
             ratio based on the height and width in screen coordinates.
            </summary>
             <overloads>This overload allows you to pass in a world point as the center.</overloads>
             <returns>This method returns an adjusted extent centered on a point.</returns>
             <remarks>None</remarks>
             <param name="worldExtent">This parameter is the current extent you want to center.</param>
             <param name="centerFeature">This parameter is the world point feature you want to center on.</param>
             <param name="screenWidth">This parameter is the width of the screen.</param>
             <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.CenterAt(ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
             <summary>This is a function that allows you to pass in a feature to center on, as well as a height
             and width in screen units.  The function will center the CurrentExtent based on the specified feature
             and adjust its ratio based on the height and width in screen coordinates.
            </summary>
             <returns>None.</returns>
             <remarks>This API will update the <strong>CurrentExtent</strong>.</remarks>
             <param name="centerFeature">This parameter is the world point feature you want to center on.</param>
             <param name="screenWidth">This parameter is the width of the screen.</param>
             <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.CenterAt(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Single,System.Single,System.Single)">
             <summary>This is a static function that allows you to pass in a world rectangle, a point in screen coordinates
             to center on, and a height and width in screen units.  The function will center the rectangle based on the
             screen point, then adjust the rectangle's ratio based on the height and width in screen coordinates.
            </summary>
             <overloads>This overload allows you to pass in a screen point as the center.</overloads>
             <returns>This method returns an adjusted extent centered on a point.</returns>
             <remarks>None</remarks>
             <param name="worldExtent">This parameter is the current extent you want to center.</param>
             <param name="screenX">This parameter is the X coordinate on the screen to center to.</param>
             <param name="screenY">This parameter is the Y coordinate on the screen to center to.</param>
             <param name="screenWidth">This parameter is the width of the screen.</param>
             <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.CenterAt(System.Single,System.Single,System.Single,System.Single)">
             <summary>This is a function that allows you to pass a screen point to center on and a height
             and width in screen units.  The function will update the current extent by centering on the point and
             adjusting its ratio based on the height and width in screen coordinates.
            </summary>
             <overloads>This overload allows you to pass in a screen point as the center.</overloads>
             <remarks>This API will update the <strong>CurrentExtent</strong>.</remarks>
             <param name="screenX">This parameter is the X coordinate on the screen to center on.</param>
             <param name="screenY">This parameter is the Y coordinate on the screen to center on.</param>
             <param name="screenWidth">This parameter is the width of the screen.</param>
             <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.GetScreenDistanceBetweenTwoWorldPoints(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
            <summary>This method returns the number of pixels between two world points.</summary>
            <returns>This method returns the number of pixels between two world points.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldPoint1">This parameter is the first point -- the one you want to measure from.</param>
            <param name="worldPoint2">This parameter is the second point -- the one you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.GetScreenDistanceBetweenTwoWorldPoints(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
            <summary>This method returns the number of pixels between two world points using the CurrentExtent as reference.</summary>
            <returns>This method returns the number of pixels between two world points.</returns>
            <remarks>None</remarks>
            <param name="worldPoint1">This parameter is the first point -- the one you want to measure from.</param>
            <param name="worldPoint2">This parameter is the second point -- the one you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.GetScreenDistanceBetweenTwoWorldPoints(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
            <summary>This method returns the number of pixels between two world points using the CurrentExtent as reference.</summary>
            <returns>This method returns the number of pixels between two world points.</returns>
            <remarks>None</remarks>
            <param name="worldPointFeature1">This parameter is the first pointFeture -- the one you want to measure from.</param>
            <param name="worldPointFeature2">This parameter is the second pointFeature -- the one you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.GetScreenDistanceBetweenTwoWorldPoints(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
            <summary>This method returns the number of pixels between two world points.</summary>
            <returns>This method returns the number of pixels between two world points.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldPointFeature1">This parameter is the first point Feature -- the one you want to measure from.</param>
            <param name="worldPointFeature2">This parameter is the second point Feature -- the one you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.GetWorldDistanceBetweenTwoScreenPoints(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.ScreenPointF,ThinkGeo.MapSuite.Core.ScreenPointF,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This method returns the distance in world units between two screen points.</summary>
            <overloads>This overload allows you to pass in ScreenPointF as the points.</overloads>
            <returns>This method returns the distance in wold units between two screen points.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="screenPoint1">This is the screen point you want to measure from.</param>
            <param name="screenPoint2">This is the screen point you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
            <param name="worldExtentUnit">This is the geographic unit of the world extent rectangle.</param>
            <param name="distanceUnit">This is the geographic unit you want the result to show in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.GetWorldDistanceBetweenTwoScreenPoints(ThinkGeo.MapSuite.Core.ScreenPointF,ThinkGeo.MapSuite.Core.ScreenPointF,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This method returns the distance in world units between two screen points by using the CurrentExtent as a reference.</summary>
            <overloads>This overload allows you to pass in ScreenPointF as the points.</overloads>
            <returns>This method returns the distance in world units between two screen points.</returns>
            <remarks>None</remarks>
            <param name="screenPoint1">This is the screen point you want to measure from.</param>
            <param name="screenPoint2">This is the screen point you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
            <param name="mapUnit">This parameter specifies the MapUnit used in the current map.</param>
            <param name="distanceUnit">This is the geographic unit you want the result to show in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.GetWorldDistanceBetweenTwoScreenPoints(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This method returns the distance in wold units between two screen points.</summary>
            <overloads>This overload allows you to pass in the X &amp; Y for each point.</overloads>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="screenPoint1X">This parameter is the X of the point you want to measure from.</param>
            <param name="screenPoint1Y">This parameter is the Y of the point you want to measure from.</param>
            <param name="screenPoint2X">This parameter is the X of the point you want to measure to.</param>
            <param name="screenPoint2Y">This parameter is the Y of the point you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
            <param name="worldExtentUnit">This is the geographic unit of the world extent you passed in.</param>
            <param name="distanceUnit">This is the geographic unit you want the result to show in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.GetCurrentScale(System.Single,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>Get the current Scale responding to the <strong>CurrentExtent</strong>.</summary>
            <returns>The calculated scale based on the CurrentExtent.</returns>
            <param name="screenWidth">
            This parameter specifies the screen width responding to the
            <strong>CurrentExtent</strong>.
            </param>
            <param name="mapUnit">This parameter specifies the MapUnit used in the current map.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.GetCurrentScale(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This Static API is used to calculate the scale based on the specified worldExtent
            and its corresponding ScreenWidth and MapUnit.
            </summary>
            <param name="worldExtent">
            This parameter specifies the worldExtent used to calculate the current
            scale.
            </param>
            <param name="screenWidth">This parameter specifies the screenWidth corresponding to the worldExtent.</param>
            <param name="mapUnit">
            This parameter specifies the unit for the extent, the result will be different if
            choose DecimalDegree as Unit and Meter as Unit.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.GetBoundingBoxOfItems(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.BaseShape})">
            <summary>
            This API gets the BoundingBox of a group of BaseShapes.
            </summary>
            <param name="shapes">The target group of BaseShapes to get the BoundingBox for.</param>
            <returns>The BoundingBox that contains all the shapes you passed in.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.GetBoundingBoxOfItems(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature})">
            <summary>
            This API gets the BoundingBox of a group of Features.
            </summary>
            <param name="features">The target group of Features to get the BoundingBox for.</param>
            <returns>The BoundingBox that contains all the features you passed in.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.Draw(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Layer},ThinkGeo.MapSuite.Core.GeoImage,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            Draw a group of layers on the specified "background" image.
            </summary>
            <param name="layers">This parameter specifies the target layers to be drawn.</param>
            <param name="image">This parameter specifies the "background" image of the returning image.</param>
            <param name="mapUnit">This parameter specifies the MapUnit used in the current map.</param>
            <returns>The resulting image after drawing the target layers on the specified "background" image.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.Draw(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Layer},System.Int32,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            Draw a group of layers and return a new image with the specified width and height.
            </summary>
            <param name="layers">This parameter specifies the target layers to be drawn.</param>
            <param name="width">This parameter specifies the width of the returning image.</param>
            <param name="height">This parameter specifies the height of the returning image.</param>
            <returns>The resulting image after drawing the target layers based on the specified width and height.</returns>
            <param name="mapUnit">This parameter specifies the MapUnit used in the current map.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.DrawStaticLayers(ThinkGeo.MapSuite.Core.GeoImage,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            Draw a group of static layers on the specified "background" image.
            </summary>
            <param name="image">This parameter specifies the "background" image of the returning image.</param>
            <param name="mapUnit">This parameter specifies the MapUnit used in the current map.</param>
            <returns>The resulting image after drawing the group of static layers on the specified "background" image.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.DrawDynamicLayers(ThinkGeo.MapSuite.Core.GeoImage,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            Draw a group of dynamic layers on the specified "background" image.
            </summary>
            <param name="image">This parameter specifies the "background" image of the returning image.</param>
            <param name="mapUnit">This parameter specifies the MapUnit used in the current map.</param>
            <returns>The resulting image after drawing the group of dynamic layers on the specified "background" image.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.DrawAdornmentLayers(ThinkGeo.MapSuite.Core.GeoImage,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            Draw a group of AdornmentLayers on the specified "background" image.
            </summary>
            <param name="image">This parameter specifies the "background" image of the returning image.</param>
            <param name="mapUnit">This parameter specifies the MapUnit used in the current map.</param>
            <returns>The resulting image after drawing the group of AdornmentLayers on the specified "background" image.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.DrawStaticLayers(System.Int32,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            Draw a group of static layers and return a new image with the specified width and height.
            </summary>
            <param name="width">This parameter specifies the width of the returning image.</param>
            <param name="height">This parameter specifies the height of the returning image.</param>
            <param name="mapUnit">This parameter specifies the MapUnit used in the current map.</param>
            <returns>The resulting image after drawing the group of static layers based on the specified width and height.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.DrawDynamicLayers(System.Int32,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            Draw a group of dynamic layers and return a new image with the specified width and height.
            </summary>
            <param name="width">This parameter specifies the width of the returning image.</param>
            <param name="height">This parameter specifies the height of the returning image.</param>
            <param name="mapUnit">This parameter specifies the MapUnit used in the current map.</param>
            <returns>The resulting image after drawing the group of dynamic layers based on the specified width and height.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.DrawAdornmentLayers(System.Int32,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            Draw a group of AdornmentLayers and return a new image with the specified width and height.
            </summary>
            <param name="width">This parameter specifies the width of the returning image.</param>
            <param name="height">This parameter specifies the height of the returning image.</param>
            <param name="mapUnit">This parameter specifies the MapUnit used in the current map.</param>
            <returns>The resulting image after drawing the group of AdornmentLayers based on the specified width and height.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.Draw(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Layer},System.Drawing.Bitmap,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            Draw a group of layers on the specified "background" bitmap.
            </summary>
            <param name="layers">This parameter specifies the target layers to be drawn.</param>
            <param name="gdiPlusBitmap">This parameter specifies the "background" bitmap of the returning bitmap.</param>
            <param name="mapUnit">This parameter specifies the MapUnit used in the current map.</param>
            <returns>The resulting bitmap after drawing the target layers on the specified "background" bitmap.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.DrawStaticLayers(System.Drawing.Bitmap,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            Draw a group of static layers on the specified "background" bitmap.
            </summary>
            <param name="gdiPlusBitmap">This parameter specifies the "background" bitmap of the returning bitmap.</param>
            <param name="mapUnit">This parameter specifies the MapUnit used in the current map.</param>
            <returns>The resulting bitmap after drawing the group of static layers on the specified "background" bitmap.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.DrawDynamicLayers(System.Drawing.Bitmap,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            Draw a group of dynamic layers on the specified "background" bitmap.
            </summary>
            <param name="gdiPlusBitmap">This parameter specifies the "background" bitmap of the returning bitmap.</param>
            <param name="mapUnit">This parameter specifies the MapUnit used in the current map.</param>
            <returns>The resulting bitmap after drawing the group of dynamic layers on the specified "background" bitmap.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.DrawAdornmentLayers(System.Drawing.Bitmap,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            Draw a group of AdornmentLayers on the specified "background" bitmap.
            </summary>
            <param name="gdiPlusBitmap">This parameter specifies the "background" bitmap of the returning bitmap.</param>
            <param name="mapUnit">This parameter specifies the MapUnit used in the current map.</param>
            <returns>The resulting bitmap after drawing the group of AdornmentLayers on the specified "background" bitmap.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomIn(System.Int32)">
            <summary>
            This method updates the CurrentExtent that is zoomed in by the percentage provided.
            </summary>
            <returns>
            This method updates the CurrentExtent that is zoomed in by the percentage provided.
            </returns>
            <remarks>None</remarks>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomIn(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32)">
            <summary>
            This method returns a new extent that is zoomed in by the percentage
            provided.
            </summary>
            <returns>
            This method returns a new extent that is zoomed in by the percentage
            provided.
            </returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to zoom.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomIntoCenter(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed in.</summary>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a world point.
            </overloads>
            <returns>This method returns an extent that is centered and zoomed in.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <param name="worldExtent">This parameter is the world extent that you want centered and zoomed.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
            <param name="worldPoint">This parameter is the world point you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width in screen coordinates.</param>
            <param name="screenHeight">This parameter is the height in screen coordinates.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomIntoCenter(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
            <summary>
            This method returns a new extent that is zoomed in by the percentage
            provided.
            </summary>
            <returns>
            This method returns a new extent that is zoomed in by the percentage
            provided.
            </returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to zoom.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
            <param name="centerFeature">This parameter is the world point feature you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width in screen coordinates.</param>
            <param name="screenHeight">This parameter is the height in screen coordinates.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomIntoCenter(System.Int32,ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
            <summary>This method will update the CurrentExtent by using the ZoomIntoCenter operation.</summary>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a world point.
            </overloads>
            <returns>None.</returns>
            <remarks>
            The CurrentExtent will be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
            <param name="worldPoint">This parameter is the world point you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width in screen coordinates.</param>
            <param name="screenHeight">This parameter is the height in screen coordinates.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomIntoCenter(System.Int32,ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed in.</summary>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a world point.
            </overloads>
            <returns>This method returns an extent that is centered and zoomed in.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
            <param name="centerFeature">This parameter is the world point you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width in screen coordinates.</param>
            <param name="screenHeight">This parameter is the height in screen coordinates.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomIntoCenter(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed in.</summary>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a screen X &amp; Y.
            </overloads>
            <returns>This method returns an extent that is centered and zoomed in.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <param name="worldExtent">This parameter is the world extent you want to center and zoom.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
            <param name="screenX">This parameter is the screen X you want to center on.</param>
            <param name="screenY">This parameter is the screen Y you want to center on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomIntoCenter(System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>This method updates the CurrentExtent based on a calculated rectangle that is centered and zoomed in.</summary>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a screen X &amp; Y.
            </overloads>
            <returns>None.</returns>
            <remarks>
            The CurrentExtent will be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
            <param name="screenX">This parameter is the screen X you want to center on.</param>
            <param name="screenY">This parameter is the screen Y you want to center on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomOut(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32)">
            <summary>
            This method returns a new extent that is zoomed out by the percentage
            provided.
            </summary>
            <returns>
            This method returns a new extent that is zoomed out by the percentage
            provided.
            </returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to zoom.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomOut(System.Int32)">
            <summary>
            This method will update the CurrentExtent by using the ZoomOut operation.
            </summary>
            <returns>None.</returns>
            <remarks>None</remarks>
            <param name="percentage">This parameter is the percentage by which you want to zoom.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomOutToCenter(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed out.</summary>
            <returns>This method returns an extent that is centered and zoomed out.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a world point.
            </overloads>
            <param name="worldExtent">This parameter is the world extent you want to center and zoom.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
            <param name="worldPoint">This parameter is the world point you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomOutToCenter(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed out.</summary>
            <returns>This method returns an extent that is centered and zoomed out.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a feature.
            </overloads>
            <param name="worldExtent">This parameter is the world extent you want to center and zoom.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
            <param name="centerFeature">This parameter is the feature you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomOutToCenter(System.Int32,ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
            <summary>This method updates the CurrentExtent by using the ZoomOutToCenter operation.</summary>
            <returns>None.</returns>
            <remarks>
            The CurrentExtent will be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a world point.
            </overloads>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
            <param name="worldPoint">This parameter is the world point you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomOutToCenter(System.Int32,ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
            <summary>This method updates the CurrentExtent by using the ZoomOutToCenter operation.</summary>
            <returns>None.</returns>
            <remarks>
            The CurrentExtent will be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a world point.
            </overloads>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
            <param name="centerFeature">This parameter is the world point Feature you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomOutToCenter(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed out.</summary>
            <returns>This method returns an extent that is centered and zoomed out.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a screenX and screenY.
            </overloads>
            <param name="worldExtent">This parameter is the world extent you want to center and zoom.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
            <param name="screenX">This parameter is the screen X you want to center on.</param>
            <param name="screenY">This parameter is the screen Y you want to center on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomOutToCenter(System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>This method updates the CurrentExtent by using the ZoomOutToCenter operation.</summary>
            <returns>None.</returns>
            <remarks>
            The CurrentExtent will  be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a screenX and screenY.
            </overloads>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
            <param name="screenX">This parameter is the screen X you want to center on.</param>
            <param name="screenY">This parameter is the screen Y you want to center on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.Pan(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.PanDirection,System.Int32)">
            <summary>This method returns a panned extent.</summary>
            <overloads>
            This overload allows you to pass in a direction and a percentage by which you want to
            pan.
            </overloads>
            <returns>This method returns a panned extent.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to pan.</param>
            <param name="direction">This parameter is the direction you want to pan.</param>
            <param name="percentage">This parameter is the percentage by which you want to pan.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.Pan(ThinkGeo.MapSuite.Core.PanDirection,System.Int32)">
            <summary>Update the CurrentExtent by using a panning operation.</summary>
            <overloads>
            This overload allows you to pass in a direction and a percentage by which you want to
            pan.
            </overloads>
            <returns>None.</returns>
            <remarks>None</remarks>
            <param name="panDirection">This parameter is the direction you want to pan.</param>
            <param name="percentage">This parameter is the percentage by which you want to pan.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.Pan(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Int32)">
            <summary>This method returns a panned extent.</summary>
            <overloads>
            This overload allows you to pass in an angle and a percentage by which you want to
            pan.
            </overloads>
            <returns>This method returns a panned extent.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to pan.</param>
            <param name="degree">This parameter is the angle in degrees in which you want to pan.</param>
            <param name="percentage">This parameter is the percentage by which you want to pan.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.Pan(System.Single,System.Int32)">
            <summary>This method updates the CurrentExtent by using a panning operation.</summary>
            <overloads>
            This overload allows you to pass in an angle and a percentage by which you want to
            pan and update the CurrentExtent.
            </overloads>
            <returns>None.</returns>
            <remarks>None</remarks>
            <param name="degree">This parameter is the angle in degrees in which you want to pan.</param>
            <param name="percentage">This parameter is the percentage by which you want to pan.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ToScreenCoordinate(System.Double,System.Double,System.Single,System.Single)">
            <summary>This method returns screen coordinates from the specified world coordinates, based on the CurrentExtent.</summary>
            <returns>This method returns screen coordinates from the specified world coordinates, based on the CurrentExtent.</returns>
            <remarks>None</remarks>
            <param name="worldX">This parameter is the world point X you want converted to a screen point.</param>
            <param name="worldY">This parameter is the world point Y you want converted to a screen point.</param>
            <param name="screenWidth">This parameter is the width of the screen for the CurrentExtent.</param>
            <param name="screenHeight">This parameter is the height of the screen for the CurrentExtent.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ToScreenCoordinate(ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
            <summary>This method returns screen coordinates from the specified world coordinates, based on the CurrentExtent.</summary>
            <returns>This method returns screen coordinates from the specified world coordinates, based on the CurrentExtent.</returns>
            <remarks>None</remarks>
            <param name="worldPoint">This parameter is the world point you want converted to a screen point.</param>
            <param name="screenWidth">This parameter is the width of the screen for the CurrentExtent.</param>
            <param name="screenHeight">This parameter is the height of the screen for the CurrentExtent.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ToScreenCoordinate(ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
            <summary>This method returns screen coordinates from the specified world coordinate pointFeature, based on the CurrentExtent.</summary>
            <returns>This method returns screen coordinates from the specified world coordinate pointFeature, based on the CurrentExtent.</returns>
            <remarks>None</remarks>
            <param name="worldPointFeature">This parameter is the world coordinate pointFeature you want converted to a screen point.</param>
            <param name="screenWidth">This parameter is the width of the screen for the CurrentExtent.</param>
            <param name="screenHeight">This parameter is the height of the screen for the CurrentExtent.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ToWorldCoordinate(System.Single,System.Single,System.Single,System.Single)">
            <summary>This method returns world coordinates from screen coordinates, based on the CurrentExtent.</summary>
            <returns>This method returns world coordinates from screen coordinates, based on the CurrentExtent.</returns>
            <remarks>None</remarks>
            <param name="screenX">
            This parameter is the X of the point you want converted to world
            coordinates.
            </param>
            <param name="screenY">
            This parameter is the Y of the point you want converted to world
            coordinates.
            </param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ToWorldCoordinate(ThinkGeo.MapSuite.Core.ScreenPointF,System.Single,System.Single)">
            <summary>This method returns world coordinates from screen coordinates, based on the CurrentExtent.</summary>
            <returns>This method returns world coordinates from screen coordinates, based on the CurrentExtent.</returns>
            <remarks>None</remarks>
            <param name="screenPoint"> This parameter is the point you want converted to world coordinates.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ToScreenCoordinate(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,System.Double,System.Single,System.Single)">
            <summary>This method returns screen coordinates from world coordinates.</summary>
            <returns>This method returns screen coordinates from world coordinates.</returns>
            <remarks>None</remarks>
            <overloads>This overload allows you to pass in world X &amp; Y coordinates.</overloads>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldX">This parameter is the world X you want converted to screen points.</param>
            <param name="worldY">This parameter is the world Y you want converted to screen points.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ToScreenCoordinate(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
            <summary>This method returns screen coordinates from world coordinates.</summary>
            <returns>This method returns screen coordinates from world coordinates.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldPoint">This parameter is the world point you want converted to a screen point.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ToScreenCoordinate(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
            <summary>This method returns screen coordinates from world coordinates.</summary>
            <returns>This method returns screen coordinates from world coordinates.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldPointFeature">This parameter is the world point feature you want converted to a screen point.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ToWorldCoordinate(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Single,System.Single,System.Single)">
            <summary>This method returns world coordinates from screen coordinates.</summary>
            <returns>This method returns world coordinates from screen coordinates.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="screenX">
            This parameter is the X coordinate of the point you want converted to world
            coordinates.
            </param>
            <param name="screenY">
            This parameter is the Y coordinate of the point you want converted to world
            coordinates.
            </param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ToWorldCoordinate(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.ScreenPointF,System.Single,System.Single)">
            <summary>This method returns world coordinates from screen coordinates.</summary>
            <returns>This method returns world coordinates from screen coordinates.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="screenPoint">This parameter is the screen point you want converted to a world point.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.SnapToZoomLevel(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Single,System.Single,ThinkGeo.MapSuite.Core.ZoomLevelSet)">
            <summary>
            This method returns an extent that is snapped to a zoom level in the provided
            zoom level set.
            </summary>
            <returns>
            This method returns an extent that is snapped to a zoom level in the provided
            zoom level set.
            </returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want snapped.</param>
            <param name="worldExtentUnit">This parameter is the geographic unit of the world extent parameter.</param>
            <param name="screenWidth">This parameter is the screen width.</param>
            <param name="screenHeight">This parameter is the screen height.</param>
            <param name="zoomLevelSet">This parameter is the set of zoom levels you want to snap to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.SnapToZoomLevel(ThinkGeo.MapSuite.Core.GeographyUnit,System.Single,System.Single,ThinkGeo.MapSuite.Core.ZoomLevelSet)">
            <summary>
            This method updates the CurrentExtent by snapping to a zoom level in the provided
            zoom level set.
            </summary>
            <returns>
            This method updates the CurrentExtent by snapping to a zoom level in the provided
            zoom level set.
            </returns>
            <remarks>None</remarks>
            <param name="worldExtentUnit">This parameter is the geographic unit of the CurrentExtent.</param>
            <param name="screenWidth">This parameter is the screen width.</param>
            <param name="screenHeight">This parameter is the screen height.</param>
            <param name="zoomLevelSet">This parameter is the set of zoom levels you want to snap to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomToScale(System.Double,ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Single,System.Single)">
            <summary>This method returns a extent that has been zoomed into a certain scale.</summary>
            <returns>This method returns a extent that has been zoomed into a certain scale.</returns>
            <remarks>None</remarks>
            <param name="targetScale">This parameter is the scale you want to zoom into.</param>
            <param name="worldExtent">This parameter is the world extent you want zoomed into the scale.</param>
            <param name="worldExtentUnit">This parameter is the geographic unit of the world extent parameter.</param>
            <param name="screenWidth">This parameter is the screen width.</param>
            <param name="screenHeight">This parameter is the screen height.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.ZoomToScale(System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,System.Single,System.Single)">
            <summary>This method updates the CurrentExtent by zooming to a certain scale.</summary>
            <remarks>None</remarks>
            <param name="targetScale">This parameter is the scale you want to zoom into.</param>
            <param name="worldExtentUnit">This parameter is the geographic unit of the CurrentExtent.</param>
            <param name="screenWidth">This parameter is the screen width.</param>
            <param name="screenHeight">This parameter is the screen height.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.GetVersion">
            <summary>
            Get the current MapSuiteCore.dll file version.
            </summary>
            <returns>A string representing the file version of MapSuiteCore.dll.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MapEngine.LoadDataTable(System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.Feature},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method is a static API to get information about a group of passed-in features with the specified
            returningColumns, in the format of a DataTable.
            </summary>
            <param name="features">This parameter specifies the target features.</param>
            <param name="returningColumnNames">This parameter specifies the returning columnNames for the features.</param>
            <returns>A DateTable of information about those passed-in features and the returning columnNames.</returns>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.MapEngine.LayersDrawing">
            <summary>This event is raised before Layers are drawn.</summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.MapEngine.LayersDrawn">
            <summary>This event is raised after Layers are drawn.</summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.MapEngine.LayerDrawing">
            <summary>This event is raised before a Layer is drawn.</summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.MapEngine.LayerDrawn">
            <summary>This event is raised after a Layer is drawn.</summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.MapEngine.AdornmentLayersDrawing">
            <summary>This event is raised before AdornmentLayers are drawn.</summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.MapEngine.AdornmentLayersDrawn">
            <summary>This event is raised after AdornmentLayers are drawn.</summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.MapEngine.AdornmentLayerDrawing">
            <summary>This event is raised before an AdornmentLayer is drawn.</summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.MapEngine.AdornmentLayerDrawn">
            <summary>This event is raised after an AdornmentLayer is drawn.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MapEngine.Canvas">
            <summary>Gets and sets the <strong>GeoCanvas</strong> used to draw the Layers.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MapEngine.ShowLogo">
            <summary>This property specifies whether the logo is shown on the Map or not.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MapEngine.AdornmentLayers">
            <summary>
            This property holds a collection of AdornmentLayers to be drawn on the
            <strong>MapEngine</strong>.
            </summary>
            <remarks>
            This collection of Layers <strong>StaticLayers</strong> will be drawn when
            calling the <strong>DrawAdornmentLayers</strong> API.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MapEngine.CurrentExtent">
            <summary>This property gets or sets the current extent of the MapEngine.</summary>
            <remarks>
            The current extent is the rectangle that is currently being shown on the
            MapEngine.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MapEngine.StaticLayers">
            <summary>
            This property holds a group of Layers to be drawn on the
            <strong>MapEngine</strong>.
            </summary>
            <remarks>
            This collection of Layers <strong>StaticLayers</strong> will be drawn when
            calling the <strong>DrawStaticLayers</strong> API.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MapEngine.DynamicLayers">
            <summary>
            This property holds a group of Layers to be drawn on the
            <strong>MapEngine</strong>.
            </summary>
            <remarks>
            This collection of Layers <strong>StaticLayers</strong> will be drawn when
            calling the <strong>DrawDynamicLayers</strong> API.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MapEngine.BackgroundFillBrush">
            <summary>
            Gets or sets the <strong>GeoBrush</strong> for the background of the
            <strong>MapEngine</strong>.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.IconValueStyle">
            <summary>
            This class allows you to choose different icons based on values in the data of a
            feature.
            </summary>
            <remarks>
            When you create an IconValueStyle, you need to add multiple IconValueItems to its
            collection. You input the column name in the IconValueStyle and it will compare the
            data's value to each IconValueItem's FieldValue. If they match, then it will draw
            the Feature using the properties of the IconValueItem. In this way, you can render
            different data with different icons or text.<br/>
            <br/>
            The MinimumLength and MaximumLength properties are important because they are used
            to ensure that a properly sized icon is used to draw things like road signs. For example,
            you can set the minimum and maximum values so that the sign icon for a single-digit road
            number uses one icon, while a two-digit road uses another, wider sign icon
            in a separate IconValueItem.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconValueStyle.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, then you need to set the required properties
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconValueStyle.#ctor(System.String)">
            <summary>This is the constructor for the class.</summary>
            <overloads>This constructor allows you to pass in the column name.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="columnName">This parameter is the column name you want to match on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconValueStyle.#ctor(System.String,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.IconValueItem})">
            <summary>This is the constructor for the class.</summary>
            <overloads>This constructor allows you to pass in the column name.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="columnName">This parameter is the column name you want to match on.</param>
            <param name="iconValueItems">This parameter is the icon value items you want to match on.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconValueStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconValueStyle.GetRequiredColumnNamesCore">
            <remarks>
             This abstract method is called from the concrete public method
             GetRequiredFieldNames. In this method, we return the column names that are required for
             the style to draw the feature properly. For example, if you have a style that colors
             areas blue when a certain column value is over 100, then you need to be sure you include
             that column name. This will ensure that the column data is returned to you in the
             feature when it is ready to draw.<br/>
             	<br/>
             In many of the styles, we add properties to allow the user to specify which field they
             need; then, in the GetRequiredColumnNamesCore, we read that property and add it to the
             collection.
             </remarks>
             <summary>
             This method returns the column data for each feature that is required for the
             style to properly draw.
             </summary>
             <returns>This method returns a collection of the column names that it needs.</returns>
             <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If columnName is null, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconValueStyle.GetLabelingCandidateCore(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeoCanvas)">
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the feature you passed in and determine if it is a candidate for
            labeling. If it is, then we will add it to the return collection. The algorithm to
            determine whether the label will draw is complex and determined by a number of properties
            and factors.
            </remarks>
            <summary>
            This method determines whether the specified feature is a good candidate to be labeled,
            based on the labeling properties set.
            </summary>
            <param name="feature">
            This parameter is the feature that will be considered as a labeling
            candidate.
            </param>
            <param name="canvas">
            This parameter is the canvas that will be used to draw the feature. This method will not
            draw on this canvas, but rather will use it to determine font size, etc.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueStyle.GridSize">
            <summary>
            This property gets and sets the grid sized used for deterministic
            labeling.
            </summary>
            <value>This property gets the grid sized used for deterministic labeling.</value>
            <remarks>
            The grid size determines how many labels will be considered for candidacy. The
            smaller the grid size, the higher the density of candidates. Making the grid size too small
            may have a performance impact.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueStyle.ColumnName">
            <summary>
            This property gets and sets the column name that will be used for the drawing and
            matching.
            </summary>
            <value>
            This property gets the column name that will be used for the drawing and
            matching.
            </value>
            <remarks>
            This column name will be used to draw the text on the icon (if necessary) and to
            also match the value in the IconStyleItem.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueStyle.DuplicateRule">
            <summary>
            This property gets and sets the rule that determines how duplicate labels are
            handled.
            </summary>
            <value>
            This property gets the rule that determines how duplicate labels are
            handled.
            </value>
            <remarks>
            There are three ways to handle duplicate label names. The first is to suppress
            all duplicates, which means if there are two street segments with the same name then
            only one will be drawn. The second way is to suppress duplicate labels only if they are
            in one quarter of the screen. In this way, the screen will be divided into four
            quadrants, and if the two duplicate labels are in different quadrants, then they will both
            draw. The last way is to draw all duplicates.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueStyle.OverlappingRule">
            <summary>
            This property gets and sets the rule that determines how overlapping labels are
            handled.
            </summary>
            <value>This property gets the rule that determines overlapping labels are handled.</value>
            <remarks>
            This defines the rules for label overlapping. Currently, either we allow overlapping or we
            do not. In the future, we may extend this to allow some percentage of partial
            overlapping.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueStyle.AllowLineCarriage">
            <summary>
            This property gets and sets whether the labeler will allow carriage returns to be
            inserted.
            </summary>
            <value>
            This property gets whether the labeler will allow carriage returns to be
            inserted.
            </value>
            <remarks>
            This property enables the labeler to split long labels into multiple lines if need be.
            For instance, if you have a lake whose name is "Southern Homestead Lake," then the labeler
            may try and break the name onto multiple lines in order to better label the feature.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueStyle.ForceLineCarriage">
            <remarks>
            This property forces the labeler to split long labels into multiple lines. For instance,
            if you have a lake whose name is "Southern Homestead Lake," then the labeler will break
            the name onto multiple lines in order to better label the feature.
            </remarks>
            <summary>
            This property gets and sets whether the labeler will force carriage returns to be
            inserted.
            </summary>
            <value>
            This property gets whether the labeler will force carriage returns to be
            inserted.
            </value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueStyle.FittingPolygon">
            <summary>
            This property gets and sets whether the labeler will try to fit the label as best as
            it can within the boundary of a polygon.
            </summary>
            <value>
            This property gets whether the labeler will try to fit the label as best as
            it can within the boundary of a polygon.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueStyle.LabelAllPolygonParts">
            <summary>
            This property gets and sets whether the labeler will label every part of a multi-part
            polygon.
            </summary>
            <value>
            This property gets whether the labeler will label every part of a multi-part
            polygon.
            </value>
            <remarks>
            In some cases, you may want to label all of the parts of a multi-part polygon, while in
            other cases you may not. For example, you may have a series of lakes where you do want to
            label each polygon. In another case, you may have a country with many small islands and
            in this case you only want to label the largest polygon.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueStyle.FittingPolygonFactor">
            <summary>
            This property gets and sets the factor to which it will keep the label inside of
            the polygon.
            </summary>
            <value>
            This property gets the factor to which it will keep the label inside of the
            polygon.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueStyle.TextLineSegmentRatio">
            <summary>
            This property gets and sets the ratio required for the label length to match the
            line length.
            </summary>
            <value>
            This property gets the ratio required for the label length to match the line
            length.
            </value>
            <remarks>
            This allows you to suppress labels where the label length would greatly exceed
            the line length. For example, if you set the ratio to 1, then the label will be
            suppressed if it is longer than the line. If the ratio is lower, then the label would
            need to be shorter than the line. If higher, then the label is allowed to run past the
            length of the line. This allows you to control the look of things like road labeling.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueStyle.BestPlacement">
            <summary>
            This property gets and sets whether the labeler will attempt to change the label
            position to avoid overlapping for point-based features.
            </summary>
            <value>
            This property gets whether the labeler will attempt to change the label position to
            avoid overlapping for point-based features.
            </value>
            <remarks>
            The positioning of point labels is mainly determined by the PointPlacement
            property. This allows you place the text to the right, top, bottom, etc. of the point. In
            some cases, placing the text in a certain place will cause many labels to be suppressed
            when the points are dense. This property allows you to override the PointPlacement
            property and allow the labeler to try other locations, if the default location would
            cause the label to be suppressed.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueStyle.PointPlacement">
            <summary>
            This property gets and sets the location of the label for point features relative
            to the point.
            </summary>
            <value>
            This property gets the location of the label for point features relative to the
            point.
            </value>
            <remarks>
            This property allows you to choose where the labels are created relative to the
            point. For example, you can set the property to RightCenter, which would ensure that all
            labels are placed to the right of and vertically centered with the point. Different kinds of point layers
            can be positioned differently. If the point layer is dense and position is not a main
            concern, then you can try the BestPlacement property. That property overrides this
            property and tries to fit the label in the best location so that the minimum number of
            labels are suppressed due to overlapping issues.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueStyle.IconValueItems">
            <summary>This property gets the collection of IconValueItems for matching.</summary>
            <value>This property gets the collection of IconValueItems for matching.</value>
            <remarks>
            You should create your IconValueItems and place them in this collection for
            consideration.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueStyle.SuppressPartialLabels">
            <summary>
            This property gets and sets whether a partial label in the current extent will be drawn or not.
            </summary>
            <remarks>This property provides a solution to the "cut off" label issue in Map Suite Web Edition and Desktop Edition, which occurs when multiple
            tiles exist. When you set this property to true, any labels outside of the current extent will not be drawn.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GradientStyle">
            <summary>
            This gradient style is a new style with the concept of GradientBrush. By
            specifying the LowerValue and its color, as well as the UpperValue and its color, we can set
            the color of each feature based on a column value using linear
            interpolation.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GradientStyle.#ctor(System.String,System.Double,ThinkGeo.MapSuite.Core.GeoSolidBrush,System.Double,ThinkGeo.MapSuite.Core.GeoSolidBrush)">
            <summary>
            This constructor creates a new instance by passing the ColumnName (which it will get
            the data from) as well as the lowerValue and its corresponding SolidBrush, and the upperValue
            and its corresponding SolidBrush.
            </summary>
            <remarks>
            In this constructor, the NoDataValue defaults to -9999 and the
            NoDataBrush color is transparent.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GradientStyle.#ctor(System.String,System.Double,ThinkGeo.MapSuite.Core.GeoSolidBrush,System.Double,ThinkGeo.MapSuite.Core.GeoSolidBrush,System.Double,ThinkGeo.MapSuite.Core.GeoSolidBrush)">
            <summary>
            This constructor creates a new instance by passing the ColumnName (which it will get
            the data from) as well as the lowerValue and its corresponding SolidBrush, the upperValue
            and its corresponding SolidBrush, and the NoDataValue and its corresponding
            SolidBrush.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GradientStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When implementing this virtual method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties to
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GradientStyle.GetRequiredColumnNamesCore">
            <remarks>
            This abstract method is called from the concrete public method
            GetRequiredFieldNames. In this method, we return the column names that are required for
            the style to draw the feature properly. For example, if you have a style that colors
            areas blue when a certain column value is over 100, then you need to be sure you include
            that column name. This will ensure that the column data is returned to you in the
            feature when it is ready to draw.<br/>
            	<br/>
            In many of the styles, we add properties to allow the user to specify which field they
            need; then, in the GetRequiredColumnNamesCore we read that property and add it to the
            collection.
            </remarks>
            <summary>
            This method returns the column data for each feature that is required for the
            style to properly draw.
            </summary>
            <returns>This method returns a collection of column names that the style needs.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GradientStyle.ColumnName">
            <summary>This property gets and sets the column name used in the style.</summary>
            <value>This property gets and sets the column name used in the style.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GradientStyle.LowerValue">
            <summary>This property gets and sets the lower value used in the style.</summary>
            <value>This property gets and sets the lower value used in the style.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GradientStyle.LowerGeoSolidBrush">
            <summary>This property gets and sets the solid brush that is used for the style's lower value.</summary>
            <value>This property gets and sets the solid brush that is used for the style's lower value.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GradientStyle.UpperValue">
            <summary>This property gets and sets the upper value used in the style.</summary>
            <value>This property gets and sets the upper value used in the style.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GradientStyle.UpperGeoSolidBrush">
            <summary>This property gets and sets the solid brush that is used for the style's upper value.</summary>
            <value>This property gets and sets the solid brush that is used for the style's upper value.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GradientStyle.NoDataValue">
            <summary>This property gets and sets the no data value used in the style.</summary>
            <value>This property gets and sets the no data value used in the style.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GradientStyle.NoDataSolidBrush">
            <summary>This property gets and sets the solid brush that is used for the style's NoDataValue.</summary>
            <value>This property gets and sets the solid brush that is used for the style's NoDataValue.</value>
            <remarks>None.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WmsRasterLayer">
            <remarks>
            A Web Map Service (WMS) produces maps of spatially referenced data dynamically
            from geographic information. This International Standard defines a "map" to be
            a portrayal of geographic information as a digital image file suitable for
            display on a computer screen. A map is not the data itself. WMS-produced
            maps are generally rendered in a pictorial format such as PNG, GIF or JPEG, or
            occasionally as vector-based graphical elements in Scalable Vector Graphics (SVG)
            or Web Computer Graphics Metafile (WebCGM) formats.
            </remarks>
            <summary>Represents an object that encapsulates a Web Map Service (WMS) layer.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterLayer.#ctor">
            <summary>This is the constructor the for the class. If you use this constructor, then you need to set
            the required properties manually.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterLayer.#ctor(System.Uri)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <remarks>This constructor initializes a new layer, then downloads and parses the service description.
            In an ASP.NET application, the service description is automatically cached for 24 hours when it is not specified.</remarks>
            <param name="uri">URI of the WMS server.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterLayer.#ctor(System.Uri,System.Net.WebProxy)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <remarks>This constructor initializes a new layer, then downloads and parses the service description.
            In an ASP.NET application, the service description is automatically cached for 24 hours when it is not specified.</remarks>
            <param name="uri">URI of the WMS server.</param>
            <param name="proxy">Proxy to use for the current WMS layer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterLayer.GetServerLayerNames">
            <summary>This method returns the names of all layers at the server side.</summary>
            <returns>This method returns the names of all layers at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterLayer.GetServerStyleNames">
            <summary>This method returns the names of all styles at the server side.</summary>
            <returns>This method returns the names of all styles at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterLayer.GetServerOutputFormats">
            <summary>This method returns the output format at the server side.</summary>
            <returns>This method returns the output format at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterLayer.GetServerCrss">
            <summary>
            This method returns the projected or geographic coordinate reference systems to be used.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterLayer.GetServerExceptionFormats">
            <summary>This method returns the exception format at the server side.</summary>
            <returns>This method returns the exception format at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterLayer.GetServiceVersion">
            <summary>
            This API gets the WMS server version of the service.
            </summary>
            <returns>Returning a string reflecting the version of the service in WMS.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WmsRasterLayer.GetRequestUrl(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <summary>
            Get the request URL from the client to the WMS.
            </summary>
            <param name="worldExtent">The world extent requested by the client to get the map.</param>
            <param name="canvasWidth">The returning map width, as well as the drawing canvas width.</param>
            <param name="canvasHeight">The returning map height, as well as the drawing canvas height.</param>
            <returns>The request URL from the client to the WMS.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterLayer.Uri">
            <summary>
            This property specifies the URI of the WMS server.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterLayer.ActiveLayerNames">
            <summary>
            This property represents the available layers that can be requested from the client and shown on the map.
            </summary>
            <remarks>When requesting a map, a client may specify the layers to be shown on the map.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterLayer.ActiveStyleNames">
            <summary>
            This property represents the available styles that can be requested from the client and shown on the map.
            </summary>
            <remarks>When requesting a map, a client may specify the styles to be shown on the map.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterLayer.OutputFormat">
            <summary>
            This property gets or sets the desired output format for the map requested from the WMS.
            </summary>
            <remarks>When requesting a map, a client may specify the output format in which to show the map.
            Format are specified as MIME types such as "image/gif" or "image/png".
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterLayer.Credentials">
            <summary>
            This property gets or sets the base authentication interface for retrieving credentials for Web Client authentication.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterLayer.IsTransparent">
            <summary>
            This property gets or sets whether the response map image's background color is transparent or not.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterLayer.Proxy">
            <summary>
            This property gets or sets the proxy used for requesting a Web Response.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterLayer.Crs">
            <summary>
            This property gets or sets the projected or geographic coordinate reference system to be used.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterLayer.TimeoutInSecond">
            <summary>
            This property specifies the timeout of the web request in seconds.  The default timeout value is 20 seconds.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterLayer.Exceptions">
            <summary>
            This property indicates the format in which the client wishes to be notified of
            service exceptions.
            </summary>
            <remarks>
            Upon receiving a request that is invalid according to the OGC standard, the
            server shall issue a service exception report. The service report is meant to describe
            to the client application or its human user the reason(s) that the request is
            invalid.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterLayer.Parameters">
            <summary>
            This property specifies a dictionary used to update the request sent from the client to
            the WMS server.
            </summary>
            <example>
            	<code lang="CS" title="C# sample" description="This example shows hot to add a cusotmize parameter to update the request url sent from the client to the WMS server.">
            		<![CDATA[
            WmsRasterSource target = new WmsRasterSource(new Uri(localWmsServer));
            target.Parameters.Add("ParameterKey", "ParameterValue");]]>
            	</code>
            	<code lang="VB" title="VB sample" description="This example shows how to update the request url sent from the client to the WMS server by adding some customized parameter.">
            		<![CDATA[
            Dim target As New WmsRasterSource(New Uri(localWmsServer)) 
            target.Parameters.Add("ParameterKey", "ParameterValue")]]>
            	</code>
            </example>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WmsRasterLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs.
            </summary>
            <remarks>The override in the WmsRasterLayer sets it to true.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GridFeatureLayer">
            <summary>
            This class uses the grid file provided.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GridFeatureLayer.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GridFeatureLayer.#ctor(System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename information for the grid
            file.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="gridPathFilename">This parameter is the path and filename of the grid file you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GridFeatureLayer.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureLayer which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the FeatureLayer.</summary>
            <returns>This method returns the bounding box of the FeatureLayer.</returns>
            <remarks>
            This method is called from the concrete public method GetBoundingBox. It returns
            the bounding box of the FeatureLayer.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GridFeatureLayer.PathFilename">
            <summary>
            This property gets and sets the path and filename to the grid file you want to
            use.
            </summary>
            <decimalDegreesValue>This property gets the path and filename to the grid file you want to use.</decimalDegreesValue>
            <remarks>This should be the complete path and filename of a grid file.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GridFeatureLayer.CellSize">
            <summary>
            Gets the cell size from the grid.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GridFeatureLayer.NumberOfColumns">
            <summary>
            Gets the column number from the grid.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GridFeatureLayer.NumberOfRows">
            <summary>
            Gets the row number from the grid.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GridFeatureLayer.NoDataValue">
            <summary>
            Gets the NoDataValue from the grid.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GridFeatureLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In GridFeatureLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GoogleMapsLayer">
            <summary>
            <summary>Represents an object that encapsulates a Google Map layer.</summary>
            </summary>
            <remarks>This clss uses Google Static Maps API to implement url request.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GoogleMapsLayer.#ctor">
            <summary>This is the constructor the for the class. If you use this constructor, then you need to set
            the required properties manually.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GoogleMapsLayer.#ctor(System.String)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <remarks>This constructor initializes a new layer and assgin a license key.
            </remarks>
            <param name="licenseKey">license key of the Google Static Maps API.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GoogleMapsLayer.#ctor(System.String,System.String,System.String)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <param name="cacheDirectory">The cache directory for the GoogleMapLayer.</param>
            <param name="clientId">The clientId for the GoogleMapLayer.</param>
            <param name="privateKey">The privateKey for the GoogleMapLayer.</param>
            <remarks>This constructor initializes a new layer and assgin a license key.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GoogleMapsLayer.#ctor(System.String,System.String)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <remarks>This constructor initializes a new layer and assgin a license key and initilize a cache directory.
            </remarks>
            <param name="licenseKey">license key of the Google Static Maps API.</param>
            <param name="cacheDirectory">cache directory which stored the cache image.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GoogleMapsLayer.#ctor(System.String,System.String,ThinkGeo.MapSuite.Core.GoogleMapsLicenseType)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <remarks>This constructor initializes a new layer and assgin a license key and initilize a cache directory.
            </remarks>
            <param name="licenseKey">license key of the Google Static Maps API. If the license type is premier, it repesents client id, eg "gme-yourclientid".</param>
            <param name="cacheDirectory">cache directory which stored the cache image.</param>
            <param name="licenseType">license type of the Google Maps API.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GoogleMapsLayer.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a Layer which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method opens the Layer so that it is initialized and ready to use.</summary>
            <remarks>
            This abstract method is called from the concrete public method Open. The
            open method plays an important role, as it is responsible for initializing the Layer.
            Most methods on the Layer will throw an exception if the state of the Layer is not
            opened. When the map draws each layer, the layer will be opened as one of its first steps;
            then, after it is finished drawing with that layer, it will close it. In this way, we
            are sure to release all resources used by the Layer.<br/>
            <br/>
            When implementing the abstract method, consider opening the FeatureSource or
            RasterSource. You will get a chance to close these in the Close method of the
            Layer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GoogleMapsLayer.CloseCore">
            <summary>
            This method closes the Layer and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This abstract method is called from the concrete public method Close. The close
            method plays an important role in the life cycle of the Layer. It may be called after
            drawing to release any memory and other resources that were allocated since the Open
            method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed Layer is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GoogleMapsLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the Layer.</summary>
            <remarks>
            This method is the concrete wrapper for the abstract method DrawCore. This
                method draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties that
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter represents the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GoogleMapsLayer.FetchImageInThread(System.Object)">
            <summary>
            Fetch the image from GoogleMaps service in other thread.
            </summary>
            <param name="obj">Represents an object that encapsulates the parameters which will pass in the thread.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GoogleMapsLayer.GetPictureFormat">
            <summary>
            Get picture format string which will use for request url.
            </summary>
            <returns>Get picture format string which will use for request url.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GoogleMapsLayer.PictureFormat">
            <summary>
            Gets or sets a value represents the image format of the image.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GoogleMapsLayer.MapType">
            <summary>
            Gets or sets a value represents the map type of the GoogleMaps.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GoogleMapsLayer.TimeoutInSeconds">
            <summary>
            Gets or sets a value represents the request timeout from the GoogleMaps server.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GoogleMapsLayer.LicenseKey">
            <summary>
            Gets or sets a value represents the license key for GoogleMaps API.
            </summary>
            <remarks>The Google Maps API lets you embed Google Maps in your own application. A single Maps API key is valid for a single "directory" or domain. If the license type is premier, it repesents client id, eg "gme-yourclientid".</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GoogleMapsLayer.ClientId">
            <summary>
            Gets or sets a value to access the special features of Google Maps API Premier, you must provide a client
            ID when accessing any of the Premier API libraries or services. When registering for
            Google Maps API Premier, you will receive this client ID from Google Enterprise Support.
            All client IDs begin with a gme- prefix.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GoogleMapsLayer.PrivateKey">
            <summary>
            Gets or sets a value that is unique to your client ID, please keep your key secure.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GoogleMapsLayer.CacheDirectory">
            <summary>
            Gets or sets a value represents the directory for image cache.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GoogleMapsLayer.NoDataTileImage">
            <summary>
            Gets or sets a value represents the image with 512*512 when no data can access.
            </summary>
            <remarks>If you set the image's size is different from 512*512, it will be compressed or stretched to 512*512.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GoogleMapsLayer.WebProxy">
            <summary>
            This property gets or sets the proxy used for requesting a Web Response.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoTiffRasterLayer">
            <summary>This class represents a TIFF image to be drawn on the map.</summary>
            <remarks>
            The TiffRasterLayer represents a TIFF file for drawing on the map. Simply provide
            the path and filename for the TIFF file, add the layer to the MapEngine class and
            start drawing. You can also draw the layer manually outside of the MapEngine.<br/>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTiffRasterLayer.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the PathFileName property manually before using the layer.
            </overloads>
            <remarks>
            If you use this constructor then, you need to set the PathFileName property
            manually before using the layer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTiffRasterLayer.#ctor(System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename information for the TIFF
            file.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and filename of the TIFF file you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTiffRasterLayer.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename information for both the TIFF file and its world file.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and filename of the TIFF file you want to use.</param>
            <param name="worldfilePathFilename">This parameter is the world file path and filename for the TIFF file you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTiffRasterLayer.#ctor(System.String,ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename for the TIFF file and the
            image extent to use.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="imagePathFilename">This parameter is the path and filename of the TIFF file you want to use.</param>
            <param name="imageExtent">This parameter is the image extent of the TIFF file you want to use.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoTiffRasterLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In GeoTiffRasterLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoTiffRasterLayer.PathFilename">
            <summary>
            This property gets and sets the path and filename of the TIFF file you want to
            use.
            </summary>
            <value>This property gets the path and filename of the image file you want to use.</value>
            <remarks>This should be the complete path and filename for a TIFF file.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WfsNamespace">
            <summary>
            Wfs Name space.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LayerDrawnEventArgs">
            <summary>
            This is the event arguments class for the LayerDrawn event on the MapEngine class. It
            is raised after a layer is drawn.
            </summary>
            <remarks>
            This is the event arguments class for the LayerDrawn event on the MapEngine class. It
            is raised after the layer is drawn. This event allows you to manipulate the
            Layer, or draw something with the canvas after the Layer draws.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LayerDrawnEventArgs.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LayerDrawnEventArgs.#ctor(ThinkGeo.MapSuite.Core.Layer,ThinkGeo.MapSuite.Core.RectangleShape,System.Object)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to set the Layer to be drawn, the world extent, and
            the image you are drawing on.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="currentLayer">This parameter is the layer that has drawn.</param>
            <param name="worldExtent">This parameter is the world extent that has drawn.</param>
            <param name="nativeImage">This parameter is the GeoImage or native map image.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LayerDrawnEventArgs.CurrentLayer">
            <summary>This property gets and sets layer that has drawn.</summary>
            <value>This property gets current layer that has drawn.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LayerDrawnEventArgs.WorldExtent">
            <summary>This property gets and sets the world extent to draw.</summary>
            <value>This property gets the world extent to draw.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LayerDrawnEventArgs.NativeImage">
            <summary>
            This property gets and sets the GeoImage or native image that we are drawing
            on.
            </summary>
            <value>This property gets the GeoImage or native image that we are drawing on.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PolygonShape">
            <summary>
            This class represents a polygon, which is defined as a single outer ring with
            zero-to-many inner rings.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.#ctor">
            <overloads>This overload creates a PolygonShape without any points in the outer ring.</overloads>
            <summary>This constructor creates a PolygonShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.#ctor(ThinkGeo.MapSuite.Core.RingShape)">
            <overloads>This overload creates a PolygonShape by specifying an outer ring.</overloads>
            <summary>This constructor creates a PolygonShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.#ctor(ThinkGeo.MapSuite.Core.RingShape,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.RingShape})">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the outerRing, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the innerRings, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates a PolygonShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates a PolygonShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and the copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.GetPerimeterCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns the perimeter of the shape, defined as the sum of the lengths
            of all its sides.
            </summary>
            <overloads>
            In this overload, the return unit is based on the LengthUnit you specify in the
            returningLengthUnit, parameter regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the LengthUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            You would use this method to find the distance around the area shape.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.GetAreaCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.AreaUnit)">
            <summary>
            This method returns the area of the shape, defined as the size of the region
            enclosed by the figure.
            </summary>
            <overloads>
            In this overload, the return unit is based on the AreaUnit you specify in the
            returningUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the AreaUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>You would use this method to find the area inside the shape.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the AreaUnit you would like to use as the return value. For example, if
            you select square miles as your returningUnit, then the distance will be returned in
            square miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>None</remarks>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.RegisterCore(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another, based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on a DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape 1 unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles to
                on the X axis and 3 miles on the Y axis.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the
                move. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another, based on a
            distance and a direction in degrees.
            </summary>
            <overloads>In this overload, the distance is in the same GeographicUnit as the shape.</overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an
                angleInDegrees and distance parameter. With this overload, it is important to note
                that the distance units are the same GeographicUnit as the shape. For example,
                if your shape is in decimal degrees and you call this method with a distance of 1,
                you're going to move this shape 1 decimal degree in direction of the
                angleInDegrees. In many cases it is more useful to specify the DistanceUnit of movement,
                such as in miles or yards, so for these scenarios there is another overload you may
                want to use instead.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape in the angle specified. The
            distance unit will be the same as the GeographyUnit for the shape. The distance must be
            greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the
                move. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.RotateCore(ThinkGeo.MapSuite.Core.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.GetClosestPointToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.GetDistanceToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <remarks>None</remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.GetWellKnownTextCore">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric shapes.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Core.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe a geometry as a binary array. Well-known
            binary is useful when you want to save a geometry in an efficient format using as little
            space as possible. An alternative to well-known binary is well-known text, which is a
            textual representation of a geometry object. We have methods that work with well-known
            text as well.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies whether the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.LoadFromWellKnownDataCore(System.String)">
            <summary>This method returns the center point of the current shape's bounding box.</summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            A PointShape representing the center point of the current shape's bounding
            box.
            </returns>
            <remarks>
            This method returns the center point of the current shape's bounding box. It is
            important to note that this is the center point of the bounding box. There are numerous
            ways to calculate the "center" of a geometry, such as its weighted center, etc. You can
            find other centers by examining the various methods of the shape itself.<br/>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.ValidateCore(ThinkGeo.MapSuite.Core.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.GetBoundingBoxCore">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates the LineShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.GetCrossingCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.RemoveVertex(ThinkGeo.MapSuite.Core.Vertex,ThinkGeo.MapSuite.Core.PolygonShape)">
            <summary>
            This method removes the selected vertex from polygon shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of polygon shape, otherwise it will return false and polygon shape will keep the same.</param>
            <param name="polygonShape">The polygon shape will be removed one vertex.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PolygonShape.RemoveVertex(ThinkGeo.MapSuite.Core.Vertex)">
            <summary>
            This method removes the selected vertex from polygon shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of polygon shape, otherwise it will return false and polygon shape will keep the same.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PolygonShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <value>This property specifies whether the shape can be rotated.</value>
            <remarks>
            If this property returns false and you attempt call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PolygonShape.OuterRing">
            <summary>This property is the outer RingShape of the polygon.</summary>
            <value>This property is the outer RingShape of the polygon.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PolygonShape.InnerRings">
            <summary>This property is the collection of RingShapes that make up the inner rings.</summary>
            <value>This property is the collection of RingShapes that make up the inner rings.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.EllipseShape">
            <summary>
            This class represents an ellipse that is defined with a center point,
            a height and a width.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.#ctor">
            <overloads>This overload creates the EllipseShape with no area.</overloads>
            <summary>This constructor creates the EllipseShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.#ctor(ThinkGeo.MapSuite.Core.PointShape,System.Double)">
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point along with the radius in the
            shape's unit. This overload will create a circle.
            </overloads>
            <remarks>Using this overload will create a circle.</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid radius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="center">This parameter is the center PointShape for the EllipseShape.</param>
            <param name="radius">This parameter allows you to set the radius of the EllipseShape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.#ctor(ThinkGeo.MapSuite.Core.Feature,System.Double)">
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point feature along with the radius in the
            shape's unit. This overload will create a circle.
            </overloads>
            <remarks>Using this overload will create a circle.</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid radius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="centerPointFeature">This parameter is the center PointFeature for the EllipseShape.</param>
            <param name="radius">This parameter allows you to set the radius of the EllipseShape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.#ctor(ThinkGeo.MapSuite.Core.PointShape,System.Double,System.Double)">
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point along with the horizontal and
            vertical radius in the unit of the shape.
            </overloads>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid horizonalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid verticalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="center">This parameter is the center PointShape for the EllipseShape.</param>
            <param name="horizontalRadius">
            This parameter allows you to set the horizontal radius of the EllipseShape in the
            unit of the shape.
            </param>
            <param name="verticalRadius">
            This parameter allows you to set the vertical radius of the EllipseShape in the
            unit of the shape.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.#ctor(ThinkGeo.MapSuite.Core.Feature,System.Double,System.Double)">
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point feature along with the horizontal and
            vertical radius in the unit of the shape.
            </overloads>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid horizonalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid verticalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="centerPointFeature">This parameter is the center PointFeature for the EllipseShape.</param>
            <param name="horizontalRadius">
            This parameter allows you to set the horizontal radius of the EllipseShape in the
            unit of the shape.
            </param>
            <param name="verticalRadius">
            This parameter allows you to set the vertical radius of the EllipseShape in the
            unit of the shape.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>This constructor allows you to create the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to create the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>This constructor allows you to create the shape from well-known binary.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to create the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.#ctor(ThinkGeo.MapSuite.Core.PointShape,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <remarks>This overload will create a circle.</remarks>
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point along with the radius in the
            unit specified by the unitOfRadius parameter. This overload will create a
            circle.
            </overloads>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid radius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfRadius that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="center">This parameter is the center PointShape for the EllipseShape.</param>
            <param name="radius">
            This parameter allows you to set the radius of the EllipseShape in the unit
            specified by the unitOfRadius parameter.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="unitOfRadius">
            This is the DistanceUnit you would like to use for the radius value. For example, if
            you select miles as your unitOfRadius, then it will use miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.#ctor(ThinkGeo.MapSuite.Core.Feature,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <remarks>This overload will create a circle.</remarks>
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point feature along with the radius in the
            unit specified by the unitOfRadius parameter. This overload will create a
            circle.
            </overloads>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid radius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfRadius that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="centerPointFeature">This parameter is the center Point Feature for the EllipseShape.</param>
            <param name="radius">
            This parameter allows you to set the radius of the EllipseShape in the unit
            specified by the unitOfRadius parameter.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="unitOfRadius">
            This is the DistanceUnit you would like to use for the radius value. For example, if
            you select miles as your unitOfRadius, then it will use miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.#ctor(ThinkGeo.MapSuite.Core.PointShape,System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <remarks>None</remarks>
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point along with the horizontal and
            vertical radius in the unit specified by the unitOfRadius parameter.
            </overloads>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid horizonalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid verticalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfRadius that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="center">This parameter is the center PointShape for the EllipseShape.</param>
            <param name="horizontalRadius">
            This parameter allows you to set the horizontal radius of the EllipseShape in the
            unit specified by the unitOfRadius parameter.
            </param>
            <param name="verticalRadius">
            This parameter allows you to set the vertical radius of the EllipseShape in the
            unit specified by the unitOfRadius parameter.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="unitOfRadius">
            This is the DistanceUnit you would like to use for the radius value. For example, if
            you select miles as your unitOfRadius, then it will use miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.#ctor(ThinkGeo.MapSuite.Core.Feature,System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <remarks>None</remarks>
            <summary>This constructor creates the EllipseShape.</summary>
            <overloads>
            This overload allows you to specify the center point along with the horizontal and
            vertical radius in the unit specified by the unitOfRadius parameter.
            </overloads>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the center, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid horizonalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid verticalRadius which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfRadius that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="centerPointFeature">This parameter is the center Point Feature for the EllipseShape.</param>
            <param name="horizontalRadius">
            This parameter allows you to set the horizontal radius of the EllipseShape in the
            unit specified by the unitOfRadius parameter.
            </param>
            <param name="verticalRadius">
            This parameter allows you to set the vertical radius of the EllipseShape in the
            unit specified by the unitOfRadius parameter.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="unitOfRadius">
            This is the DistanceUnit you would like to use for the radius value. For example, if
            you select miles as your unitOfRadius, then it will use miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.SetWidthByUnit(System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method allows you to set the width of the EllipseShape in the unit specified in the
            unitOfWidth parameter.
            </summary>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid width which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfWidth that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="newWidth">This parameter is the newWidth of the ellipse shape.</param>
            <param name="shapeUnit">This parameter is the unit of the current shape.</param>
            <param name="unitOfWidth">
            This is the unit you would like to use as the setting value. For example, if you
            select miles as your unitOfWidth, then the distance will be set in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.GetWidthByUnit(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns the width of the EllipseShape in the unit specified in the
            returningUnit parameter.
            </summary>
            <returns>
            This method returns the width of the EllipseShape in the unit specified in the
            returningUnit parameter.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="shapeUnit">This parameter is the unit of the current shape.</param>
            <param name="returningUnit">
            This is the unit you would like to use for the return value. For example, if you
            select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.SetHeightByUnit(System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method allows you to set the height of the EllipseShape in the unit specified in the
            unitOfWidth.
            </summary>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid height which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfHeight that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="newHeight"> This parameter is the newHeight of the ellipse shape.</param>
            <param name="shapeUnit">This parameter is the unit of the current shape.</param>
            <param name="unitOfHeight">
            This is the unit you would like to use for the setting value. For example, if you
            select miles as your unitOfHeight, then the distance will be set in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.GetHeightByUnit(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns the height of the EllipseShape in the unit specified in the
            returningUnit parameter.
            </summary>
            <returns>
            This method returns the height of the EllipseShape in the unit specified in the
            returningUnit parameter.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="shapeUnit">This parameter is the unit of the current shape.</param>
            <param name="returningUnit">
            This is the unit you would like to use for the return value. For example, if you
            select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.ToPolygon">
            <summary>This method returns the current shape as a PolygonShape.</summary>
            <returns>This method returns the current shape as a PolygonShape.</returns>
            <remarks>
            This method is mainly used to convert this non GIS standard shape to a GIS
            standard shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.ToPolygon(System.Int32)">
            <summary>This method returns the current shape as a PolygonShape.</summary>
            <returns>This method returns the current shape as a PolygonShape.</returns>
            <remarks>
            This method is mainly used to convert a GIS non-standard shape to a GIS
            standard shape.
            </remarks>
            <param name="vertexCountInQuarter">This parameter specifies how many points will make up each quarter of the ellipse.</param>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid vertexCountInQuarter which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.GetTangents(ThinkGeo.MapSuite.Core.EllipseShape)">
            <summary>
            This method returns the tangent points of the current ellipse in relation to the
            target ellipse you specify.
            </summary>
            <returns>
            This method returns the tangent points of the current ellipse in relation to the
            target ellipse you specify.
            </returns>
            <remarks>
            This operation is useful for finding the corridor between two
            ellipses. It would be handy in a buffering type of scenario.
            </remarks>
            <param name="targetEllipse">
            This parameter represents the other ellipse you wish to find the tangent points
            to.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.GetPerimeterCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns the perimeter of the shape, which is defined as the sum of the lengths
            of all its sides.
            </summary>
            <overloads>
            In this overload, the return unit is based on the LengthUnit you specify in the
            returningLengthUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the LengthUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            	<para>You would use this method to find the distance around the area shape.</para>
            	<para><br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use for the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.GetAreaCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.AreaUnit)">
            <summary>
            This method returns the area of the shape, which is defined as the size of the region
            enclosed by the figure.
            </summary>
            <overloads>
            In this overload, the return unit is based on the AreaUnit you specify in the
            returningUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the AreaUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            	<para>You would use this method to find the area inside of a shape.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the AreaUnit you would like to use for the return value. For example, if
            you select square miles as your returningUnit, then the distance will be returned in
            square miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method is useful when you would like to increase the size of the shape.
                Note that a larger percentage will scale the shape up faster, as you are applying the
                operation multiple times. There is also a ScaleDown method that will shrink the
                shape.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take a significant amount of time (the larger the objects, the more time the operation will take).</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.RegisterCore(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on the DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another based on an X
                and Y offset distance. It is important to note that with this overload the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of one and a Y
                offset of one, you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles to
                on the X axis and 3 miles on the Y axis.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified by
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified by
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measurement for the move.
                For example, if you select miles as your distanceUnit, then the xOffsetDistance and yOffsetDistance
                will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on a
            direction in degrees and distance.
            </summary>
            <overloads>
            In this overload, the distance unit is based on a DistanceUnit you specify in the
            distanceUnit parameter, regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another based on
                angleInDegrees and distance parameter. It is important to note that with this
                overload the distance units are based on the distanceUnit parameter. For
                example, if your shape is in decimal degrees and you call this method with a
                distanceUnit in miles, you're going to move this shape a number of miles based on
                the distance and the angleInDegrees. In this way, you can easily move a shape in decimal
                degrees five miles to the north.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the DistanceUnit specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape with zero being up.</para>
            </param>
            <param name="shapeUnit">
            This is the GeographicUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use as the measurement for the move. For
            example, if you select miles as your distanceUnit, then the distance will be calculated
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.RotateCore(ThinkGeo.MapSuite.Core.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape by a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can acheive in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further away from
                the center will make the circular area larger.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.GetClosestPointToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the point of the current shape that is closest to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            	<para>This method returns point of the current shape that is closest to the target
                shape. It is often the case that the point returned is not a point of the object
                itself. An example would be a line with two points that are far apart from each other. If
                you set the targetShape to be a point midway between the points but a short
                distance away, the method would return a point that is on the line, but not one of the two
                points that make up the line.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.GetDistanceToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>The distance returned will be in the unit specified in the distanceUnit parameter.</overloads>
            <returns>
            The return type is the distance between this shape and the targetShape in the
            GeographyUnit of the shape.
            </returns>
            <remarks>
            	<para>In this method, we compute the closest distance between two shapes. The
                returned unit will be in the unit of distance specified in the distanceUnit parameter.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use as the return value. For example,
            if you select miles as your distanceUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.GetWellKnownTextCore">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe geometries as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or
                when you simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We also have methods that work with well-known binary.
                Below are some samples of what well-known text might look like for various kinds of
                geometries.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.GetWellKnownTextCore(System.Int32)">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a stringthat represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe geometries as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or
                when you simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We also have methods that work with well-known binary.
                Below are some samples of what well-known text might look like for various kinds of
                geometries.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on this shape which has invalid upper left and lower right points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid vertexCountInQuarter which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="vertexCountInQuarter">
            This parameter specifies how many points will make up each quarter of the
            ellipse.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Core.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            	<para>This method returns a byte array that represents the shape in well known
                binary. Well-known binary allows you to describe geometries as a binary array.
                Well-known binary is useful when you want to save a geometry in an efficient format
                using as little space as possible. An alternative to well-known binary is well-known
                text, which is a textual representation of a geometry object. We also have methods
                that work with well-known text.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies whether the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Core.WkbByteOrder,System.Int32)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            	<para>This method returns a byte array that represents the shape in well known
                binary. Well-known binary allows you to describe geometries as a binary array.
                Well-known binary is useful when you want to save a geometry in an efficient format
                using as little space as possible. An alternative to well-known binary is well-known
                text, which is a textual representation of a geometry object. We also have methods
                that work with well-known text.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid vertexCountInQuarter which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="byteOrder">This parameter specifies whether the byte order is big- or little-endian.</param>
            <param name="vertexCountInQuarter">
            This parameter specifies how many points will make up each quarter of the
            ellipse.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.ValidateCore(ThinkGeo.MapSuite.Core.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            	<para>We use this method, with the simple enumeration, internally before doing any kind
                of other methods on the shape. In this way, we are able to verify the integrity of the
                shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
                you to call this method with the advanced ShapeValidationMode. One thing to consider is
                that for complex polygon shapes this operation could take some time, which is why we
                only run the basic, faster test. If you are dealing with polygon shapes that are
                suspect, we suggest you run the advanced test.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.ContainsCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns whether the targetShape lies within the interior of the current
            shape.
            </summary>
            <returns>
            This method returns whether the targetShape lies within the interior of the current
            shape.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.IntersectsCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns whether the current shape and the targetShape have at least one
            point in common.
            </summary>
            <returns>
            This method returns whether the current shape and the targetShape have at least one
            point in common.
            </returns>
            <remarks>
            	<br/>
            	<br/>
            Overriding:<br/>
            	<br/>
            Please ensure that you validate the parameters being passed in and raise the exceptions defined
            above.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The shape you wish to compare the current one to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.EllipseShape.GetCrossingCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns the crossing points of the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points of the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.EllipseShape.Width">
            <summary>
            This property returns the width of the EllipseShape in the unit of the
            shape.
            </summary>
            <value>
            This property returns the width of the EllipseShape in the unit of the
            shape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.EllipseShape.Height">
            <summary>
            This property returns the height of the EllipseShape in the unit of the
            shape.
            </summary>
            <value>
            This property returns the height of the EllipseShape in the unit of the
            shape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.EllipseShape.Center">
            <summary>
            This property allows you to get or set the center PointShape of the
            EllipseShape.
            </summary>
            <value>
            This property allows you to get or set the center PointShape of the
            EllipseShape.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.EllipseShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <value>This property specifies whether the shape can be rotated.</value>
            <remarks>
            If this property returns false and you attempt call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoPen">
            <summary>This class represents a GeoPen, which is used to draw lines on a GeoCanvas.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoPen.#ctor">
            <summary>This constructor creates a GeoPen.</summary>
            <overloads>This overload creates a GeoPen with its default values.</overloads>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoPen.#ctor(ThinkGeo.MapSuite.Core.GeoBrush)">
            <summary>This constructor creates a GeoPen.</summary>
            <overloads>This overload creates a GeoPen by specifying a GeoBrush.</overloads>
            <remarks>None</remarks>
            <param name="brush">This parameter represents the brush that will be used to draw the line.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null value as the brush, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoPen.#ctor(ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>This constructor creates a GeoPen.</summary>
            <overloads>This overload creates a GeoPen by specifying a GeoColor.</overloads>
            <remarks>None</remarks>
            <param name="color">This parameter represents the color that will be used to draw the line.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null value as the color, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoPen.#ctor(ThinkGeo.MapSuite.Core.GeoColor,System.Single)">
            <summary>This constructor creates a GeoPen.</summary>
            <overloads>This overload creates a GeoPen by specifying a GeoColor and a line width.</overloads>
            <remarks>None</remarks>
            <param name="color">This parameter represents the color that will be used to draw the line.</param>
            <param name="width">This parameter represents the width of the line.</param>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a width value that is not greater than zero, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoPen.#ctor(ThinkGeo.MapSuite.Core.GeoBrush,System.Single)">
            <summary>This constructor creates a GeoPen.</summary>
            <overloads>This overload creates a GeoPen by specifying a GeoBrush and a line width.</overloads>
            <remarks>None</remarks>
            <param name="brush">This parameter represents the brush that will be used to draw the line.</param>
            <param name="width">This parameter represents the width of the line.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null value as the brush, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a width value that is not greater than zero, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoPen.SetLineCap(ThinkGeo.MapSuite.Core.DrawingLineCap,ThinkGeo.MapSuite.Core.DrawingLineCap,ThinkGeo.MapSuite.Core.GeoDashCap)">
            <summary>This method allows you to set the start, end and dash caps at one time.</summary>
            <remarks>None</remarks>
            <param name="startCap">This parameter specifies the start cap to be used.</param>
            <param name="endCap">This parameter specifies the end cap to be used.</param>
            <param name="dashCap">This parameter specifies the dash cap to be used.</param>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startCap that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a endCap that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a dashCap that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoPen.CloneDeep">
            <summary>Create a copy of GeoPen using the deep clone process.</summary>
            <returns>A cloned GeoPen.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoPen.CloneDeepCore">
            <summary>Create a copy of GeoPen using the deep clone process. The default implementation uses serialization.</summary>
            <returns>A cloned GeoPen.</returns>
            <remarks>
            The difference between deep clone and shallow clone is as follows: In shallow cloning,
            only the object is copied; the objects within it are not. By contrast, deep cloning
            copies the cloned object as well as all the objects within.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoPen.Brush">
            <summary>This property gets and sets the brush for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the brush for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null value as the brush, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoPen.Color">
            <summary>This property gets and sets the GeoColor for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the GeoColor for this GeoPen.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoPen.DashCap">
            <summary>This property gets and sets the dash cap for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the dash cap for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a DashCap that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoPen.DashPattern">
            <summary>This property gets the dash pattern for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the dash pattern for this GeoPen.</decimalDegreesValue>
            <remarks>Assigning a value other than null (Nothing in Visual Basic) to this property will set the DashStyle property for this GeoPen to Custom.
            The elements in the dashArray array set the length of each dash and space in the dash pattern. The first element sets the length of a dash, the second element sets the length of a space, the third element sets the length of a dash, and so on. 
            The length of each dash and space in the dash pattern is the product of the element value in the array and the width of the GeoPen.</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null value as the DashPattern, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoPen.DashStyle">
            <summary>This property gets and sets the dash style for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the dash style for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a DashStyle that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoPen.EndCap">
            <summary>This property gets and sets the end cap for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the end cap for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a EndCap that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoPen.LineJoin">
            <summary>This property gets and sets the line join for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the line join for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a LineJoin that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoPen.MiterLimit">
            <summary>This property gets and sets the miter limit for this GeoPen.</summary>
            <decimalDegreesValue>This property gets set the miter limit for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoPen.StartCap">
            <summary>This property gets and sets the start cap for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the start cap for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a StartCap that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoPen.Width">
            <summary>This property gets and sets the width for this GeoPen.</summary>
            <decimalDegreesValue>This property gets the width for this GeoPen.</decimalDegreesValue>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a width value that is not greater than zero, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoPen.Id">
            <summary>
            The id of the GeoBrush. This is always used as a key when in the cached brushes.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.CommittedTransactionEventArgs">
            <summary>
            This class represents the parameters passed in through the CommittedTransaction
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.CommittedTransactionEventArgs.#ctor(ThinkGeo.MapSuite.Core.TransactionBuffer)">
            <summary>This is the constructor of the event arguments.</summary>
            <overloads>This is the constructor that allows you to pass in a transaction buffer.</overloads>
            <returns>None</returns>
            <param name="transactionBuffer">This parameter represents the transaction buffer that has been committed.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.CommittedTransactionEventArgs.#ctor">
            <summary>This is the constructor of the event arguments.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.CommittedTransactionEventArgs.TransactionBuffer">
            <summary>This property returns the transaction buffer that has been committed.</summary>
            <decimalDegreesValue>This property returns the transaction buffer that has been committed.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.POINT">
            <summary>
            Point struct.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.POINT.#ctor(System.Double,System.Double)">
            <summary>
             Constructor.
            </summary>
            <param name="x"> x coordinate</param>
            <param name="y"> y coordinate</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.POINT.IsEquals(ThinkGeo.MapSuite.Core.POINT)">
            <summary>
            Test if current point is equal to pt.
            </summary>
            <param name="pt">Point to test</param>
            <returns>
            true for yes
            false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.POINT.GetSize(System.Boolean)">
            <summary>
            Return the size of the this struct.
            </summary>
            <returns> Size of POINT</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.POINT.Read(System.IO.BinaryReader,System.Boolean)">
            <summary>
            Read contents from BinaryReader object.
            </summary>
            <param name="r"> BinaryReader object</param>
            <param name="isFloat">True to mark it as float or single.</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.POINT.Write(System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write contents into BinaryWriter object.
            </summary>
            <param name="w">BinaryWriter object</param>
            <param name="isFloat">True if we want to save it as float or single.</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.POINT.ToString">
            <summary>
            For debugging.
            </summary>
            <returns> dumped string</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RECTANGLE_D">
            <summary>
            RECTANGLE_D stores a rectangle and independent functions.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructor for constructing based on coordinates.
            </summary>
            <param name="x1"> First point's x coordinate</param>
            <param name="y1"> First point's y coordinate</param>
            <param name="x2"> Second point's x coordinate</param>
            <param name="y2"> Second point's y coordinate</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.GetMinDist(ThinkGeo.MapSuite.Core.POINT)">
            <summary>
            GetMinDist
            </summary>
            <param name="p">Query point</param>
            <returns>Min distance</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.Normalize">
            <summary>
            Normalize the data to RECTANGLE_D coordinates.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.GetSize(System.Boolean)">
            <summary>
            Return the size of this struct.
            </summary>
            <returns> Size of RECTANGLE_D</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.Read(System.IO.BinaryReader,System.Boolean)">
            <summary>
            Read contents from BinaryReader object.
            </summary>
            <param name="r"> BinaryReader object</param>
            <param name="isFloat"> </param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.Write(System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write contents into BinaryWriter object.
            </summary>
            <param name="w"> BinaryWriter object</param>
            <param name="isFloat"></param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.IsContains(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Test if this RECTANGLE_D contains testRect.
            </summary>
            <param name="testRect"> RECTANGLE_D object</param>
            <returns>	
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.IsContains(ThinkGeo.MapSuite.Core.POINT)">
            <summary>
            Test if this RECTANGLE_D contains testPoint.
            </summary>
            <param name="testPoint">POINT object</param>
            <returns>	
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.IsContained(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Test if this RECTANGLE_D is contained by testRect.
            </summary>
            <param name="testRect">RECTANGLE_D object</param>
            <returns>	
            	true for yes 
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.IsOverlaps(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Test if this RECTANGLE_D overlaps with testRect.
            </summary>
            <param name="testRect">RECTANGLE_D object</param>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.Width">
            <summary>
            Get the rectangle's width.
            </summary>
            <returns> rectangle's width</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.Height">
            <summary>
            Get the rectangle's height.
            </summary>
            <returns> rectangle's height</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.GetArea">
            <summary>
            Get the rectangle's area.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.IsEquals(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Test if the current rectangle is equal to testRt.
            </summary>
            <param name="testRt">Rectangle to test</param>
            <returns>
            true for yes
            false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.GetRectangleF">
            <summary>
            Get rectangle object.
            </summary>
            <returns> rectangle object</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.GetUnionMbb(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Return a new RECTANGLE_D representing the mbb of the union of this RECTANGLE_D and rt.
            </summary>
            <param name="rt">Specific RECTANGLE_D</param>
            <returns>new RECTANGLE_D representing the mbb of their union</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.GetUnionMbbArea(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Return a new RECTANGLE_D representing the mbb of the union of this RECTANGLE_D and rt.
            </summary>
            <param name="rt">Specific RECTANGLE_D</param>
            <returns>new RECTANGLE_D representing the mbb of their union</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RECTANGLE_D.ToString">
            <summary>
            For debugging.
            </summary>
            <returns> dumped string</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IdsEngine.IdsHeader.ReadIntFromBytes(System.Byte[],System.Int32)">
            <summary>
            Read the int value from a bytes array.
            </summary>
            <param name="bytes">The bytes array to read from.</param>
            <param name="iStart">The start index (in bytes) to use when reading.</param>
            <returns>The int decimalDegreesValue read from the bytes array.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.TiledWmsLayer">
            <summary>
            This class is use for tiled WMS Server, and you also can get map from ThinkGeo world map kit server.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.#ctor">
            <summary>This is the constructor the for the class. If you use this constructor, then you need to set
            the required properties manually.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.#ctor(System.String)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <param name="serverUri">URI of the Tiled WMS server.</param>
            <remarks>This constructor initializes a new layer, then downloads and parses the service description.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.#ctor(System.Uri)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <param name="serverUri">URI of the Tiled WMS server.</param>
            <remarks>This constructor initializes a new layer, then downloads and parses the service description.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.#ctor(System.Uri,System.Net.WebProxy)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <param name="serverUri">URI of the Tiled WMS server.</param>
            <param name="webProxy">Proxy to use for the current Tiled WMS layer.</param>
            <remarks>This constructor initializes a new layer, then downloads and parses the service description.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.#ctor(System.Uri,System.String,System.String)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <param name="serverUri">URI of the Tiled WMS server.</param>
            <param name="clientId">The clientId for the WMS Server.</param>
            <param name="privateKey">The privateKey for the WMS Server.</param>
            <remarks>This constructor initializes a new layer and assgin a client id and a private key.
            </remarks>  
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.#ctor(System.Uri,System.Net.WebProxy,System.String,System.String)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <param name="serverUri">URI of the Tiled WMS server.</param>
            <param name="webProxy">Proxy to use for the current Tiled WMS layer.</param>
            <param name="clientId">The clientId for the WMS Server.</param>
            <param name="privateKey">The privateKey for the WMS Server.</param>
            <remarks>This constructor initializes a new layer and assgin a license key.
            </remarks>      
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.ClearCache">
            <summary>
            This method clears the tile cache of client.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a Layer which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method opens the Layer so that it is initialized and ready to use.</summary>
            <remarks>
            This abstract method is called from the concrete public method Open. The
            open method plays an important role, as it is responsible for initializing the Layer.
            Most methods on the Layer will throw an exception if the state of the Layer is not
            opened. When the map draws each layer, the layer will be opened as one of its first steps;
            then, after it is finished drawing with that layer, it will close it. In this way, we
            are sure to release all resources used by the Layer.<br/>
            <br/>
            When implementing the abstract method, consider opening the FeatureSource or
            RasterSource. You will get a chance to close these in the Close method of the
            Layer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.GetServerLayerNames">
            <summary>This method returns the names of all layers at the server side.</summary>
            <returns>This method returns the names of all layers at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.GetServerStyleNames">
            <summary>This method returns the names of all styles at the server side.</summary>
            <returns>This method returns the names of all styles at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.GetServerOutputFormats">
            <summary>This method returns the output format at the server side.</summary>
            <returns>This method returns the output format at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.GetServerCrss">
            <summary>
            This method returns the projected or geographic coordinate reference systems to be used.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.GetServerExceptionFormats">
            <summary>This method returns the exception format at the server side.</summary>
            <returns>The exception format at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.GetServiceVersion">
            <summary>
            This API gets the WMS server version of the service.
            </summary>
            <returns>Returns a string reflecting the version of the service in WMS.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.GetRequestUrl(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <summary>
            Get the request URLs from the client to the WMS servers.
            </summary>
            <param name="worldExtent">The world extent requested by the client to get the map.</param>
            <param name="canvasWidth">The returning map width, as well as the drawing canvas width.</param>
            <param name="canvasHeight">The returning map height, as well as the drawing canvas height.</param>
            <returns>The request URLs from the client to the WMS servers.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.CloseCore">
            <summary>
            This method closes the Layer and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This abstract method is called from the concrete public method Close. The close
            method plays an important role in the life cycle of the Layer. It may be called after
            drawing to release any memory and other resources that were allocated since the Open
            method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed Layer is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.DrawImage(ThinkGeo.MapSuite.Core.GeoCanvas)">
             <summary>
             This method draws image on the canvas with specified labelsInAllLayers
             </summary>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.
             This parameter represents the labels used for collision detection and duplication
             checking.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the Layer.</summary>
            <remarks>
            This method is the concrete wrapper for the abstract method DrawCore. This
                method draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties that
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter represents the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.IsExtentWithinThreshold(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,System.Double,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit,System.Single)">
            <summary>
            This method retures a value represents whether the currentExtent is within the passing in thresholds.
            </summary>
            <param name="currentExtent">The RectangleShape represents the current extent.</param>
            <param name="upperThreshold">The upper threshold for scale.</param>
            <param name="lowerThreshold">The lower threshold for scale.</param>
            <param name="canvasWidth">The width of canvas which will use to draw.</param>
            <param name="mapUnit">The GeographyUnit represents map unit for currentExtent</param>
            <param name="dpi">This parameter is the dpi of the current extent.</param>
            <returns>This method retures a value represents whether the currentExtent is within the passing in thresholds. If returns true, is within. otherwise out of thresholds.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TiledWmsLayer.DrawExceptionCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Exception)">
            <summary>
            This method will draw on the canvas when the layer.Draw throw exception and 
            the DrawExceptionMode is set to DrawException instead of ThrowException.
            </summary>
            <param name="canvas">The target canvas to draw the layer.</param>
            <param name="e">The exception thrown when layer.Draw().</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.ClientId">
            <summary>
            Gets or sets a value that is your Client Id.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.PrivateKey">
            <summary>
            Gets or sets a value that is unique to your client ID, please keep your key secure.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.ServerUri">
            <summary>
            Gets or sets a server uri of Tiled WMS Server.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.WebProxy">
            <summary>
            This property gets or sets the proxy used for requesting a Web Response.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.OutputFormat">
            <summary>
            This property gets or sets the desired output format for the map requested from the WMS.
            </summary>
            <remarks>When requesting a map, a client may specify the output format in which to show the map.
            Format are specified as MIME types such as "image/gif" or "image/png".
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.Crs">
            <summary>
            This property gets or sets the projected or geographic coordinate reference system to be used.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.TileCache">
            <summary>
            Gets or sets a BitmapTileCache represents which tile cache will be used.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.UpperScale">
            <summary>
            Gets or sets a value represents upper threshold for scale.
            </summary>
            <remarks>Is the current scale is beyond this value, the map will not render.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.LowerScale">
            <summary>
            Gets or sets a value represents lower threshold for scale.
            </summary>
            <remarks>Is the current scale is less than this value, the map will not render.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.ActiveLayerNames">
            <summary>
            This property represents the available layers that can be requested from the client and shown on the map.
            </summary>
            <remarks>When requesting a map, a client may specify the layers to be shown on the map.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.ActiveStyleNames">
            <summary>
            This property represents the available styles that can be requested from the client and shown on the map.
            </summary>
            <remarks>When requesting a map, a client may specify the styles to be shown on the map.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.TimeoutInSeconds">
            <summary>
            This property specifies the timeout of the web request in seconds.  The default timeout value is 20 seconds.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.Exceptions">
            <summary>
            This property indicates the format in which the client wishes to be notified of
            service exceptions.
            </summary>
            <remarks>
            Upon receiving a request that is invalid according to the OGC standard, the
            server shall issue a service exception report. The service report is meant to describe
            to the client application or its human user the reason(s) that the request is
            invalid.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.Parameters">
            <summary>
            This property specifies a dictionary used to update the request sent from the client to
            the WMS server.
            </summary>
            <example>
            	<code lang="CS" title="C# sample" description="This example shows hot to add a cusotmize parameter to update the request url sent from the client to the WMS server.">
            		<![CDATA[
            WmsRasterSource target = new WmsRasterSource(new Uri(localWmsServer));
            target.Parameters.Add("ParameterKey", "ParameterValue");]]>
            	</code>
            	<code lang="VB" title="VB sample" description="This example shows how to update the request url sent from the client to the WMS server by adding some customized parameter.">
            		<![CDATA[
            Dim target As New WmsRasterSource(New Uri(localWmsServer)) 
            target.Parameters.Add("ParameterKey", "ParameterValue")]]>
            	</code>
            </example>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.HasBoundingBox">
            <summary>
            This property indicates whether a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs.
            </summary>
            <remarks>The value of TileWmsLayer is false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TiledWmsLayer.IsOpenCore">
            <summary>This property returns true if the Layer is open and false if it is not.</summary>
            <decimalDegreesValue>This property returns true if the Layer is open and false if it is not.</decimalDegreesValue>
            <remarks>
            Various methods on the Layer require that it be in an open state. If one of those
            methods is called when the state is not open, then the method will throw an exception.
            To enter the open state, you must call the Layer Open method. The method will raise an
            exception if the current Layer is already open.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.VirtualEarthZoomLevelSet">
            <summary>This class represents the zoom levels used by Virtual Earth maps.</summary>
            <returns>None</returns>
            <remarks>
            If you want to create some layers that match up with Virtual Earth map layers, you
            should use this ZoomSet.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.VirtualEarthZoomLevelSet.#ctor">
            <summary>This class represents the zoom levels used by Virtual Earth.</summary>
            <returns>None</returns>
            <remarks>
            If you want to create some layers that match up with Virtual Earth layers, you
            should use this ZoomSet.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RestrictionStyle">
            <summary>This enumeration specifies the type of restriction zone display style.</summary>
            <example>
            	<code lang="CS" title="C# sample" description="The example below shows how to use RestrictionStyle.">
            RestrictionLayer restrictionLayer1 = new RestrictionLayer(); 
            restrictionLayer1.RestrictionStyle = RestrictionStyle.HatchPattern; 
             
            RestrictionLayer restrictionLayer2 = new RestrictionLayer(); 
            restrictionLayer2.RestrictionStyle = RestrictionStyle.CircleWithSlashImage; 
             
            RestrictionLayer restrictionLayer3 = new RestrictionLayer(); 
            restrictionLayer3.RestrictionStyle = RestrictionStyle.UseCustomStyles; 
            AreaStyle customStyle = new AreaStyle(new GeoSolidBrush(new GeoColor(150, GeoColor.StandardColors.Gray)));
            restrictionLayer3.CustomStyles.Add(customStyle);
            </code>
            	<code lang="VB" title="VB sample" description="The example below shows how to use RestrictionStyle.">
            Dim restrictionLayer1 As RestrictionLayer =  New RestrictionLayer() 
            restrictionLayer1.RestrictionStyle = RestrictionStyle.HatchPattern 
             
            Dim restrictionLayer2 As RestrictionLayer =  New RestrictionLayer() 
            restrictionLayer2.RestrictionStyle = RestrictionStyle.CircleWithSlashImage 
             
            Dim restrictionLayer3 As RestrictionLayer =  New RestrictionLayer() 
            restrictionLayer3.RestrictionStyle = RestrictionStyle.UseCustomStyles 
            Dim customStyle As AreaStyle =  New AreaStyle(New GeoSolidBrush(New GeoColor(150,GeoColor.StandardColors.Gray))) 
            restrictionLayer3.CustomStyles.Add(customStyle)
            </code>
            </example>
            <seealso cref="T:ThinkGeo.MapSuite.Core.RestrictionLayer">RestrictionLayer Class</seealso>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.RestrictionStyle.HatchPattern">
            <summary>Hatch pattern. Can be used to represent "no data" in this zone.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.RestrictionStyle.CircleWithSlashImage">
            <summary>A tiled circle with slash (strikeout) image.  Can be used to represent restriction or lack of viewing permissions.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.RestrictionStyle.UseCustomStyles">
            <summary>Will use a custom style instead of default style.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LogoAdornmentLayer">
            <summary>
            This is the sub base class of <strong>AdornmentLayer</strong>. The <strong>LogoAdornmentLayer</strong> is
            taken as Logo map of the Map Control.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LogoAdornmentLayer.#ctor">
            <summary>This method is the default constructor for the LogoAdornmentLayer.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LogoAdornmentLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the LogoAdornmentLayer.</summary>
            <remarks>
            This virtual method is called from the concreate public method Draw. In this
            method draw the representation of the layer based on the extent you provided.<br/>
            	<br/>
            You can use the full power of the AdornmentLayer to do the drawing.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the geoCanvas we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the labelsInAllLayers we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a mapUnit that is not defined in the enumeration it will throw a ArgumentOutOfRangeException.</exception>
            <param name="labelsInAllLayers">This parameter are the labels used for collision detection and duplication check</param>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GroupLayer">
            <summary>This class represents a Layer backed by a group of layers.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GroupLayer.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GroupLayer.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Layer})">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the path and filename information for the group.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="layers">This parameter represents the layers in this class that you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GroupLayer.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a Layer which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method opens the Layer so that it is initialized and ready to use.</summary>
            <remarks>
            This abstract method is called from the concrete public method Open. The open
            method plays an important role, as it is responsible for initializing the Layer. Most
            methods on the Layer will throw an exception if the state of the Layer is not opened.
            When the map draws each layer, it will open the layer as one of its first steps; then, after it
            is finished drawing with that layer, it will close it. In this way, we are sure to
            release all resources used by the Layer.<br/>
            	<br/>
            When implementing the abstract method, consider opening the FeatureSource or
            RasterSource. You will get a chance to close these in the Close method of the
            Layer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GroupLayer.CloseCore">
            <summary>
            This method closes the FeatureSource and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This abstract method is called from the concrete public method Close. The close
            method plays an important role in the life cycle of the Layer. It may be called after
            drawing to release any memory and other resources that were allocated since the Open
            method was called.<br/>
            	<br/>
            If you override the Core version of this method, it is recommended that you take
            the following things into account: This method may be called multiple times, so we
            suggest you write the method so that that a call to a closed Layer is ignored and does not
            generate an error. We also suggest that in the Close you free all resources that have
            been opened. Remember that the object will not be destroyed, but will be re-opened
            possibly in the near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GroupLayer.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a layer which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the Layer.</summary>
            <returns>This method returns the bounding box of the Layer.</returns>
            <remarks>This method returns the bounding box of the Layer.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GroupLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the Layer.</summary>
            <remarks>
            This abstract method is called from the concrete public method Draw. This
            method draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties to
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter are the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GroupLayer.Layers">
            <summary>
            This property gets the layers you want to use.
            </summary>
            <decimalDegreesValue>This property gets the layers you want to use.</decimalDegreesValue>
            <remarks>This property gets the layers you want to use.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GroupLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In GroupLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:ThinkGeo.MapSuite.Core.GoogleMapsLicenseType" -->
        <member name="F:ThinkGeo.MapSuite.Core.GoogleMapsLicenseType.Standard">
            <summary>
            Google Maps API standard license.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GoogleMapsLicenseType.Premier">
            <summary>
            Google Maps API premier license.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MatrixReferenceCorner">
            <summary>
            This enum specifies the Reference corner when caculating the Matrix from Matrix boundingBox.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.MatrixReferenceCorner.UpperLeft">
            <summary>
            This items specifies the reference corner should be the UpperLeft of the Matrix boundingBox.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.MatrixReferenceCorner.UpperRight">
            <summary>
            This items specifies the reference corner should be the UpperRight of the Matrix boundingBox.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.MatrixReferenceCorner.LowerLeft">
            <summary>
            This items specifies the reference corner should be the LowerLeft of the Matrix boundingBox.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.MatrixReferenceCorner.LowerRight">
            <summary>
            This items specifies the reference corner should be the LowerRight of the Matrix boundingBox.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeocentricInfo">
            <summary>
            definition of class GeocentricInfo
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.FeatureCache">
            <summary>
            FeatureCache is a cache system used in FeatureSource to speed up the fetching
            data system.
            </summary>
            <remarks>
            The FeatureCache system uses the BoundingBox as the "Key" to cache the features.
            For example, if I first get data for a BoundingBox(BoundingBox1) and cache the
            features within the BoundingBox, in the future if I want to get the features within
            another BoundingBox(BoundingBox2) which is within BoundingBox1, I will get the
            features directly from the FeatureCache instead of from FileSystem or DBSystem.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureCache.#ctor">
            <summary>
            This is the default constructor that will create a new instance of the
            FeatureCache.
            </summary>
            <returns>None</returns>
            <remarks>
            The cache system is not used by default.  If you want to use it, you must set
            the <strong>IsActive</strong> property to true.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureCache.GetFeatures(ThinkGeo.MapSuite.Core.RectangleShape)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">In the event you attempt to call this method by passing a null, it will throw an ArgumentNullException.</exception>
            <summary>
            This method returns a Collection of Features cached in the FeatureCache system. All of the returning features 
            are within the BoundingBox and were fetched from FileSystem or DBSystem in a previous operation.
            </summary>
            <returns>
            This method returns a Collection of Features cached in the FeatureCache system.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method GetFeaturesCore. It
            will return whatever is returned by the GetBoundingBoxCore method. 
            To determine what the default implementation of the abstract
            GetBoundingBoxCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureCache.GetFeaturesCore(ThinkGeo.MapSuite.Core.RectangleShape)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">In the event you attempt to call this method by passing a null, it will throw an ArgumentNullException.</exception>
            <summary>
            This method returns a Collection of Features cached in the FeatureCache system. All of the returning features 
            are within the BoundingBox and were fetched from FileSystem or DBSystem in a previous operation.
            </summary>
            <returns>
            This method returns a Collection of Features cached in the FeatureCache system.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method GetFeaturesCore. It
            will return whatever is returned by the GetBoundingBoxCore method. 
            To determine what the default implementation of the abstract
            GetBoundingBoxCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureCache.Clear">
            <summary>
            This method clears all of the CachedItems in this FeatureCache.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureCache.Add(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.Feature})">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">In the event you attempt to call this method by passing a null for the WorldExtent, it will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method by passing a Invalid RectangleShape for the WorldExtent, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">In the event you attempt to call this method by passing a null for the Collection of features, it will throw an ArgumentNullException.</exception>
            <summary>
            This method will add an item to the FeatureCache system by passing a WorldExtent as "Key"
            and a collection of features as its corresponding cached features.
            </summary>
            <returns>
            None.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method AddCore. It
            will return whatever is returned by the AddCore method. 
            To determine what the default implementation of the abstract
            AddCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureCache.AddCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.Feature})">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">In the event you attempt to call this method by passing a null for the WorldExtent, it will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method by passing a Invalid RectangleShape for the WorldExtent, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">In the event you attempt to call this method by passing a null for the Collection of features, it will throw an ArgumentNullException.</exception>
            <summary>
            This method will add an item to the FeatureCache system by passing a WorldExtent as "Key"
            and a collection of features as its corresponding cached features.
            </summary>
            <returns>
            None.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method AddCore. It
            will return whatever is returned by the AddCore method. 
            To determine what the default implementation of the abstract
            AddCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureCache.Open">
            <summary>
            The default implementation is to do nothing.
            </summary>
            <returns>
            None.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method OpenCore. It
            will return whatever is returned by the OpenCore method. 
            To determine what the default implementation of the abstract
            OpenCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureCache.OpenCore">
            <summary>
            The default implementation is to do nothing.
            </summary>
            <returns>
            None.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method OpenCore. It
            will return whatever is returned by the OpenCore method. 
            To determine what the default implementation of the abstract
            OpenCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureCache.Close">
            <summary>
            The default implementation is to do nothing.
            </summary>
            <returns>
            None.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method CloseCore. It
            will return whatever is returned by the CloseCore method. 
            To determine what the default implementation of the abstract
            CloseCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureCache.CloseCore">
            <summary>
            The default implementation is to do nothing.
            </summary>
            <returns>
            None.
            </returns>
            <remarks>
            This method is the concrete wrapper for the virtual method CloseCore. It
            will return whatever is returned by the CloseCore method. 
            To determine what the default implementation of the abstract
            CloseCore method is, please see the documentation for it.<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureCache.IsExtentCached(ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>
            This method determines whether the WorldExtent is already cached in the FeatureCache System.
            </summary>
            <param name="worldExtent">The target WorldExtent which will be determined as already cached or not.</param>
            <returns>True if the specified WorldExtent is already cached. Otherwise, returns false.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureCache.IsActive">
            <summary>This boolean property sepcifies whether cache system is active or not.</summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureCache.CachedItems">
             <summary>
             This property specifies the Cached dictionary items in the FeatureCache system.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ExtentHelper">
            <summary>
            This static class exposes a number of helpful methods when dealing with
            extents.    
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.GetDrawingExtent(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Single)">
            <summary>
            This method returns an adjusted extent based on the ratio of the screen width and
            height.
            </summary>
            <returns>
            This method returns an adjusted extent based on the ratio of the screen width and
            height.
            </returns>
            <remarks>
            This function is used because the extent to draw must be the rame ratio as the screen
            width and height. If they are not, then the image drawn will be stretched or compressed.
            We always adjust the extent upwards to ensure that no matter how we adjust it,
            the original extent will fit within the new extent. This ensures that everything
            you wanted to see in the first extent is visible and maybe a bit more.
            </remarks>
            <param name="worldExtent">This parameter is the world extent you want to adjust for drawing.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.CenterAt(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
             <summary>This is a static function that allows you to pass in a world rectangle, a world point to center on, and a height
             and width in screen units.  The function will center the rectangle based on the point, then adjust the rectangle's 
             ratio based on the height and width in screen coordinates.
            </summary>
             <overloads>This overload allows you to pass in a world point as the center.</overloads>
             <returns>This method returns an adjusted extent centered on a point.</returns>
             <remarks>None</remarks>
             <param name="worldExtent">This parameter is the current extent you want to center.</param>
             <param name="worldPoint">This parameter is the world point you want to center on.</param>
             <param name="screenWidth">This parameter is the width of the screen.</param>
             <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.CenterAt(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
             <summary>This is a static function that allows you to pass in a world rectangle, a world point to center on, and a height
             and width in screen units.  The function will center the rectangle based on the point, then adjust the rectangle's 
             ratio based on the height and width in screen coordinates.
            </summary>
             <overloads>This overload allows you to pass in a world point as the center.</overloads>
             <returns>This method returns an adjusted extent centered on a point.</returns>
             <remarks>None</remarks>
             <param name="worldExtent">This parameter is the current extent you want to center.</param>
             <param name="centerFeature">This parameter is the world point you want to center on.</param>
             <param name="screenWidth">This parameter is the width of the screen.</param>
             <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.CenterAt(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Single,System.Single,System.Single)">
            <summary>This method returns an adjusted extent centered on a point.</summary>
            <overloads>This overload allows you to pass in a screen point as the center.</overloads>
            <returns>This method returns an adjusted extent centered on a point.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the current extent you want to center.</param>
            <param name="screenX">This parameter is the X coordinate on the screen to center on.</param>
            <param name="screenY">This parameter is the Y coordinate on the screen to center on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.GetScreenDistanceBetweenTwoWorldPoints(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
            <summary>This method returns the number of pixels between two world points.</summary>
            <returns>This method returns the number of pixels between two world points.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldPoint1">This parameter is the first point -- the one you want to measure from.</param>
            <param name="worldPoint2">This parameter is the second point -- the one you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.GetScreenDistanceBetweenTwoWorldPoints(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
            <summary>This method returns the number of pixels between two features.</summary>
            <returns>This method returns the number of pixels between two features.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldPointFeature1">This parameter is the first feature -- the one you want to measure from.</param>
            <param name="worldPointFeature2">This parameter is the second feature -- the one you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.GetWorldDistanceBetweenTwoScreenPoints(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.ScreenPointF,ThinkGeo.MapSuite.Core.ScreenPointF,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This method returns the distance in world units between two screen points.</summary>
            <overloads>This overload allows you to pass in ScreenPointF as the points.</overloads>
            <returns>This method returns the distance in world units between two screen points.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="screenPoint1">This is the screen point you want to measure from.</param>
            <param name="screenPoint2">This is the screen point you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
            <param name="worldExtentUnit">This is the geographic unit of the world extent rectangle.</param>
            <param name="distanceUnit">This is the geographic unit you want the result to show in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.GetWorldDistanceBetweenTwoScreenPoints(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This method returns the distance in world units between two screen points.</summary>
            <overloads>This overload allows you to pass in the X &amp; Y for each point.</overloads>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="screenPoint1X">This parameter is the X of the point you want to measure from.</param>
            <param name="screenPoint1Y">This parameter is the Y of the point you want to measure from.</param>
            <param name="screenPoint2X">This parameter is the X of the point you want to measure to.</param>
            <param name="screenPoint2Y">This parameter is the Y of the point you want to measure to.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
            <param name="worldExtentUnit">This is the geographic unit of the world extent you passed in.</param>
            <param name="distanceUnit">This is the geographic unit you want the result to show in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.GetScale(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>This method returns the current scale.</summary>
            <returns>This method returns the current scale.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to find the scale for.</param>
            <param name="screenWidth">This parameter is the screen width.</param>
            <param name="worldExtentUnit">This parameter is the unit of the world extent.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.GetScale(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,ThinkGeo.MapSuite.Core.GeographyUnit,System.Single)">
            <summary>This method returns the current scale.</summary>
            <returns>This method returns the current scale.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to find the scale for.</param>
            <param name="screenWidth">This parameter is the screen width.</param>
            <param name="worldExtentUnit">This parameter is the unit of the world extent.</param>
            <param name="dpi">This parameter is the dpi of the world extent.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.GetBoundingBoxOfItems(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.BaseShape})">
            <summary>
            This API gets the BoundingBox of a group of BaseShapes.
            </summary>
            <param name="shapes">The target group of BaseShapes to get the BoundingBox for.</param>
            <returns>The BoundingBox that contains all of the shapes you passed in.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.GetBoundingBoxOfItems(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature})">
            <summary>
            This API gets the BoundingBox of a group of Features.
            </summary>
            <param name="features">The target group of Features to get the BoundingBox for.</param>
            <returns>The BoundingBox that contains all the features you passed in.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ZoomIn(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32)">
            <summary>
            This method returns a new extent that is zoomed in by the percentage
            provided.
            </summary>
            <returns>
            This method returns a new extent that is zoomed in by the percentage
            provided.
            </returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to zoom to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ZoomIntoCenter(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed in.</summary>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a world point.
            </overloads>
            <returns>This method returns an extent that is centered and zoomed in.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <param name="worldExtent">This parameter is the world extent that you want centered and zoomed to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
            <param name="worldPoint">This parameter is the world point you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width in screen coordinates.</param>
            <param name="screenHeight">This parameter is the height in screen coordinates.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ZoomIntoCenter(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed.</summary>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinatesm
            as well as a feature.
            </overloads>
            <returns>This method returns an extent that is centered and zoomed in.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <param name="worldExtent">This parameter is the world extent that you want centered and zoomed to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
            <param name="centerFeature">This parameter is the feature you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width in screen coordinates.</param>
            <param name="screenHeight">This parameter is the height in screen coordinates.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ZoomIntoCenter(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed in.</summary>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a screen X &amp; Y.
            </overloads>
            <returns>This method returns an extent that is centered and zoomed in.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <param name="worldExtent">This parameter is the world extent you want to center and zoom to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom in.</param>
            <param name="screenX">This parameter is the screen X you want to center on.</param>
            <param name="screenY">This parameter is the screen Y you want to center on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ZoomOut(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32)">
            <summary>
            This method returns a new extent that is zoomed out by the percentage
            provided.
            </summary>
            <returns>
            This method returns a new extent that is zoomed out by the percentage
            provided.
            </returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to zoom out to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ZoomOutToCenter(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed out.</summary>
            <returns>This method returns an extent that is centered and zoomed out.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a world point.
            </overloads>
            <param name="worldExtent">This parameter is the world extent you want to center and zoom out to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
            <param name="worldPoint">This parameter is the world point you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ZoomOutToCenter(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed out.</summary>
            <returns>This method returns an extent that is centered and zoomed out.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterwards.
            </remarks>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a feature.
            </overloads>
            <param name="worldExtent">This parameter is the world extent you want to center and zoom out to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
            <param name="centerFeature">This parameter is the feature you want the extent to be centered on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ZoomOutToCenter(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>This method returns an extent that is centered and zoomed out.</summary>
            <returns>This method returns an extent that is centered and zoomed out.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to call GetDrawingExtent afterward.
            </remarks>
            <overloads>
            This overload allows you to pass in the height and width in screen coordinates,
            as well as a screen X &amp; Y.
            </overloads>
            <param name="worldExtent">This parameter is the world extent you want to center and zoom out to.</param>
            <param name="percentage">This parameter is the percentage by which you want to zoom out.</param>
            <param name="screenX">This parameter is the screen X you want to center on.</param>
            <param name="screenY">This parameter is the screen Y you want to center on.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.Pan(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.PanDirection,System.Int32)">
            <summary>This method returns a panned extent.</summary>
            <overloads>
            This overload allows you to pass in a direction and a percentage by which you want to
            pan.
            </overloads>
            <returns>This method returns a panned extent.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to pan.</param>
            <param name="direction">This parameter is the direction in which you want to pan.</param>
            <param name="percentage">This parameter is the percentage by which you want to pan.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.Pan(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Int32)">
            <summary>This method returns a panned extent.</summary>
            <overloads>
            This overload allows you to pass in an angle and a percentage by which you want to
            pan.
            </overloads>
            <returns>This method returns a panned extent.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want to pan.</param>
            <param name="degree">This parameter is the degree you want to pan.</param>
            <param name="percentage">This parameter is the percentage by which you want to pan.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ToScreenCoordinate(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,System.Double,System.Single,System.Single)">
            <summary>This method returns screen coordinates from world coordinates.</summary>
            <returns>This method returns screen coordinates from world coordinates.</returns>
            <remarks>None</remarks>
            <overloads>This overload allows you to pass in world X &amp; Y coordinates.</overloads>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldX">This parameter is the world X you want converted to screen points.</param>
            <param name="worldY">This parameter is the world Y you want converted to screen points.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ToScreenCoordinate(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Single)">
            <summary>This method returns Rectangle in screen coordinates from RectangleShape in world coordinates.</summary>
            <returns>This method returns Rectangle in screen coordinates from RectangleShape in world coordinates.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="targetExtent">This parameter is the rectangle shape in world coordinate you want converted to a rectangle in screen coordinate.</param>
            <param name="currentExtentWidth">This parameter is the width of the screen.</param>
            <param name="currentExtentHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ToScreenCoordinate(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.PointShape,System.Single,System.Single)">
            <summary>This method returns screen coordinates from world coordinates.</summary>
            <returns>This method returns screen coordinates from world coordinates.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldPoint">This parameter is the world point you want converted to a screen point.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ToScreenCoordinate(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.Feature,System.Single,System.Single)">
            <summary>This method returns screen coordinates from world coordinates.</summary>
            <returns>This method returns screen coordinates from world coordinates.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="worldPointFeature">This parameter is the feature you want converted to a screen point.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ToWorldCoordinate(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Single,System.Single,System.Single)">
            <summary>This method returns world coordinates from screen coordinates.</summary>
            <returns>This method returns world coordinates from screen coordinates.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="screenX">
            This parameter is the X of the point you want converted to world
            coordinates.
            </param>
            <param name="screenY">
            This parameter is the Y of the point you want converted to world
            coordinates.
            </param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ToWorldCoordinate(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.ScreenPointF,System.Single,System.Single)">
            <summary>This method returns world coordinates from screen coordinates.</summary>
            <returns>This method returns world coordinates from screen coordinates.</returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent.</param>
            <param name="screenPoint">This parameter is the screen point you want converted to a world point.</param>
            <param name="screenWidth">This parameter is the width of the screen.</param>
            <param name="screenHeight">This parameter is the height of the screen.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.SnapToZoomLevel(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Single,System.Single,ThinkGeo.MapSuite.Core.ZoomLevelSet)">
            <summary>
            This method returns an extent that is snapped to a zoom level in the provided
            zoom level set.
            </summary>
            <returns>
            This method returns an extent that is snapped to a zoom level in the provided
            zoom level set.
            </returns>
            <remarks>None</remarks>
            <param name="worldExtent">This parameter is the world extent you want snapped.</param>
            <param name="worldExtentUnit">This parameter is the geographic unit of the world extent parameter.</param>
            <param name="screenWidth">This parameter is the screen width.</param>
            <param name="screenHeight">This parameter is the screen height.</param>
            <param name="zoomLevelSet">This parameter is the set of zoom levels you want to snap to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ZoomToScale(System.Double,ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Single,System.Single)">
            <summary>This method returns a extent that has been zoomed into a certain scale.</summary>
            <returns>This method returns a extent that has been zoomed into a certain scale.</returns>
            <remarks>None</remarks>
            <param name="targetScale">This parameter is the scale you want to zoom into.</param>
            <param name="worldExtent">This parameter is the world extent you want zoomed into the scale.</param>
            <param name="worldExtentUnit">This parameter is the geographic unit of the world extent parameter.</param>
            <param name="screenWidth">This parameter is the screen width.</param>
            <param name="screenHeight">This parameter is the screen height.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ZoomToScale(System.Double,ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Single,System.Single,ThinkGeo.MapSuite.Core.ScreenPointF)">
            <summary>This method returns a extent that has been zoomed into a certain scale.</summary>
            <returns>This method returns a extent that has been zoomed into a certain scale.</returns>
            <remarks>None</remarks>
            <param name="targetScale">This parameter is the scale you want to zoom into.</param>
            <param name="worldExtent">This parameter is the world extent you want zoomed into the scale.</param>
            <param name="worldExtentUnit">This parameter is the geographic unit of the world extent parameter.</param>
            <param name="screenWidth">This parameter is the screen width.</param>
            <param name="screenHeight">This parameter is the screen height.</param>
            <param name="offsetScreenPoint">This parameter is the offsetScreenPoint.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ZoomIntoOffsetPoint(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Single,ThinkGeo.MapSuite.Core.ScreenPointF,System.Int32)">
            <summary>This method returns an extent that is keeping the offsetScreenPoint constant and zoomed.</summary>
            <returns>This method returns an extent that is keeping the offsetScreenPoint constant and zoomed.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to afterward call GetDrawingExtent.
            </remarks>
            <param name="worldExtent">This parameter is the world extent that you want centered and zoomed.</param>
            <param name="percentage">This parameter is the percentage you want to zoom.</param>
            <param name="offsetScreenPoint">This parameter is the screen point you want to keep it constant.</param>
            <param name="screenWidth">This parameter is the width in screen coordinates.</param>
            <param name="screenHeight">This parameter is the height in screen coordinates.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ZoomOutToOffsetPoint(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Single,ThinkGeo.MapSuite.Core.ScreenPointF,System.Int32)">
            <summary>This method returns an extent that is keeping the offsetScreenPoint constant and zoomed.</summary>
            <returns>This method returns an extent that is keeping the offsetScreenPoint constant and zoomed.</returns>
            <remarks>
            The resulting rectangle will already be adjusted for the ratio of the screen. You
            do not need to afterward call GetDrawingExtent.
            </remarks>
            <param name="worldExtent">This parameter is the world extent that you want centered and zoomed.</param>
            <param name="percentage">This parameter is the percentage you want to zoom.</param>
            <param name="offsetScreenPoint">This parameter is the screen point you want to keep it constant.</param>
            <param name="screenWidth">This parameter is the width in screen coordinates.</param>
            <param name="screenHeight">This parameter is the height in screen coordinates.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ExtentHelper.ResizeExtent(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Single,System.Single,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.MapResizeMode)">
            <summary>
            This method returns a RectangleShape by resize parameters.
            </summary>
            <param name="sourceExtent">The rectangle shape before rezise</param>
            <param name="sourceScreenWidth">The width of the source rectangle shape in screen coordinate</param>
            <param name="targetScreenWidth">The width of the target rectangle shape in screen coordinate</param>
            <param name="targetScreenHeight">The height of the target rectangle shape in screen coordinate</param>
            <param name="mapUnit">map unit which this rectangle shape used</param>
            <param name="resizeType">Represents resize type which can decide to use which way to resize.</param>
            <returns>This method returns a RectangleShape by resize parameters.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PointSymbolType">
            <summary>This enumeration defines the different types of PointSymbols that can be drawn.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointSymbolType.Circle">
            <summary>
            Draws a circle.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointSymbolType.Square">
            <summary>
            Draws a square.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointSymbolType.Triangle">
            <summary>
            Draws a triangle.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointSymbolType.Cross">
            <summary>
            Draws an equal-legged cross.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointSymbolType.Diamond">
            <summary>Draws a diamond.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointSymbolType.Diamond2">
            <summary>Draws a variation of a diamond.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointSymbolType.Star">
            <summary>Draws a star.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PointSymbolType.Star2">
            <summary>Draws a variation of a star.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer">
            <summary>This class represents a Layer backed by a Shape File.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you should set
            the required methods manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you should set
            the required methods manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.#ctor(System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a path and filename to a shape
            file.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="shapePathFilename">This parameter is the Shape File path and filename.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.#ctor(System.String,ThinkGeo.MapSuite.Core.ShapeFileReadWriteMode)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a path and filename to a Shape File and
            the read/write mode for the files.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="shapePathFilename">This parameter is the Shape File path and filename.</param>
            <param name="readWriteMode">This parameter specifies whether the file will be opened in read-only or read/write mode.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a path and filename to a Shape File and its
            spatial index file.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="shapePathFilename">This parameter is the Shape File path and filename.</param>
            <param name="indexPathFilename">This parameter is the index file path and filename.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.#ctor(System.String,System.String,ThinkGeo.MapSuite.Core.ShapeFileReadWriteMode)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a path and filename to a Shape File, its
            index file, and to specify the read/write mode for the files.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="shapePathFilename">This parameter is the Shape File path and filename.</param>
            <param name="indexPathFilename">This parameter is the index file path and filename.</param>
            <param name="readWriteMode">This parameter specifies whether the file will be opened in read-only or read/write mode.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.#ctor(System.String,System.String,ThinkGeo.MapSuite.Core.ShapeFileReadWriteMode,System.Text.Encoding)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a path and filename to a Shape File, the
            index file, and to specify the read/write mode and the encoding for the files.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="shapePathFilename">This parameter is the Shape File path and filename.</param>
            <param name="indexPathFilename">This parameter is the index file path and filename.</param>
            <param name="readWriteMode">This parameter specifies whether the file will be opened in read-only or read/write mode.</param>
            <param name="encoding">This parameter specifies the encoding of the data.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.Rebuild(System.String)">
            <summary>
            This method rebuilds the SHP, SHX, DBF, IDX and IDS files for the given shape
            file.
            </summary>
            <returns>None</returns>
            <remarks>
            This method rebuilds the SHP, SHX, DBF, IDX and IDS files for the given shape
            file. When we do editing we have optimized the updates so that we do not need to
            rebuild the entire shape file. This leads to the shape file being out of order which
            may cause it not to open in other tools. One optimization is if you update a record
            instead of rebuilding a new shape file we mark the old record as null and add the
            edited record at the end of the shape file. This greatly increases the speed of
            committing shape file changes but will over time unorder the shape file. In addition we
            do a delete the DBF file will simply mark the record deleted and not compact the space.
            Rebuilding the shape file will correctly order the SPX and SHX along with compacting
            the DBF file and rebuild any index with the same any of the shape file if it
            exists.<br/>
            	<br/>
            Note that if you have build custom index files where the name of the index differs from
            that of the shape file you will need to rebuild those manually using the BuildIndex
            methods.
            </remarks>
            <param name="shapePathFilename">This parameter is the shape file you want to rebuild.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.CreateShapeFile(ThinkGeo.MapSuite.Core.ShapeFileType,System.String,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.DbfColumn})">
            <summary>
            Static API to create a new Shape File.
            </summary>
            <param name="shapeType">This parameter specifies the the Shape File type for the target Shape File.</param>
            <param name="pathFilename">This parameter specifies the Shape filename for the target Shape File.</param>
            <param name="databaseColumns">This parameter specifies the DBF column information for the target Shape File.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.CreateShapeFile(ThinkGeo.MapSuite.Core.ShapeFileType,System.String,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.DbfColumn},System.Text.Encoding)">
            <summary>
            Static API to create a new Shape File.
            </summary>
            <param name="shapeType">This parameter specifies the the Shape File type for the target Shape File.</param>
            <param name="pathFilename">This parameter specifies the Shape filename for the target Shape File.</param>
            <param name="databaseColumns">This parameter specifies the DBF column information for the target Shape File.</param>
            <param name="encoding">This parameter specifies the DBF encoding infromation for the target Shape File.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.CreateShapeFile(ThinkGeo.MapSuite.Core.ShapeFileType,System.String,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.DbfColumn},System.Text.Encoding,ThinkGeo.MapSuite.Core.OverwriteMode)">
            <summary>
            Static API to create a new Shape File.
            </summary>
            <param name="shapeType">This parameter specifies the the Shape File type for the target Shape File.</param>
            <param name="pathFilename">This parameter specifies the Shape filename for the target Shape File.</param>
            <param name="databaseColumns">This parameter specifies the DBF column information for the target Shape File.</param>
            <param name="encoding">This parameter specifies the DBF encoding infromation for the target Shape File.</param>
            <param name="overwriteMode">This parameter specifies the override mode when the target Shape File exists.</param>
            <remarks>An exception will be thown when the target Shape File does not exist while the overwrite mode is set to DoNotOverwrite.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.BuildIndexFile(System.String)">
            <summary>This method builds a spatial index for the layer.</summary>
            <overloads>
            This overload allows you to pass in the Shape filename.
            </overloads>
            <returns>None</returns>
            <remarks>This overload allows you to pass in the Shape File.</remarks>
            <param name="pathFilename">The path and filename to the Shape File.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.BuildIndexFile(System.String,System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>
            This method build a spatial index for the shape file which increases accessspeed.
            </summary>
            <overloads>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. You can also specify if you want to rebuild an existing
            index file.
            </overloads>
            <remarks>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="shapePathFilename">
            This parameter is the shape file name and path that you want to build an index
            for.
            </param>
            <param name="indexPathFilename">
            This parameter specifies the index file name.
            </param>
            <param name="buildIndexMode">
            This parameter determines what will happen if there is an existing index
            file.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.BuildIndexFile(System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>This method builds a spatial index for the layer.</summary>
            <overloads>
            This overload allows you to pass in the Shape File and determines if we
            rebuild an index file that already exists.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in the Shape File and determines if we
            rebuild an index file that already exists.
            </remarks>
            <param name="pathFilename">This parameter is the matching pattern that defines which Shape Files to include.</param>
            <param name="rebuildExistingIndexMode">This parameter determines whether an index file will be rebuilt if it already exists.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},System.String)">
            <summary>This method builds a spatial index for the specified group of features.</summary>
            <overloads>
            This overload allows you to pass in a group of features and specify the index filename to use.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a group of features and specify the index filename to use.
            </remarks>
            <param name="features">This parameter specifies the features for which to build the index.</param>
            <param name="indexPathFilename">This parameter specifies the target index path and filename.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},System.String,ThinkGeo.MapSuite.Core.Projection)">
            <summary>This method builds a spatial index for the specified group of features and target projection.</summary>
            <overloads>
            This overload allows you to pass in a group of features and specify a target projection and the index filename to use.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a group of features and specify a target projection and the index filename to use.
            </remarks>
            <param name="features">This parameter specifies the features for which to build the index.</param>
            <param name="indexPathFilename">This parameter specifies the target index path and filename.</param>
            <param name="projection">This parameter specifies the projection to build index against those features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>This method builds a spatial index for the specified group of features.</summary>
            <overloads>
            This overload allows you to pass in a group of features and specify the index filename to use.
            You can also pass in a Shape File and specify whether to rebuild an index file if it already exists.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a group of features and specify the index filename to use.
            </remarks>
            <param name="features">This parameter specifies the features for which to build the index.</param>
            <param name="indexPathFilename">This parameter determines the target index path filename.</param>
            <param name="buildIndexMode">This parameter determines whether an index file will be rebuilt if it already exists.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},System.String,ThinkGeo.MapSuite.Core.Projection,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>This method builds a spatial index for the specified group of features.</summary>
            <overloads>
            This overload allows you to pass in a group of features and specify a target projection and the index filename to use.
            You can also pass in a Shape File and specify whether to rebuild an index file if it already exists.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a group of features and specify a target projection and the index filename to use.
            </remarks>
            <param name="features">This parameter specifies the features for which to build the index.</param>
            <param name="indexPathFilename">This parameter determines the target index path filename.</param>
            <param name="projection">This parameter determines the Projection to build index against those features.</param>
            <param name="buildIndexMode">This parameter determines whether an index file will be rebuilt if it already exists.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.BuildIndexFile(System.String,System.String,System.String,System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>This method builds a spatial index only for those features that satisfy a regular expression.</summary>
            <overloads>
            This overload allows you to pass in a Shape File and only build an index for those features that satisfy the 
            regularExpression parameter.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a Shape File and specify the index filename to use.
            </remarks>
            <param name="shapePathFilename">This parameter specifies the Shape File for which to build the index.</param>
            <param name="indexPathFilename">This parameter determines the target index path filename.</param>
            <param name="columnName">This parameter determines the column name whose values will be tested against the regular expression.</param>
            <param name="regularExpression">This parameter represents the regular expression to test against each feature for inclusion in the index.</param>
            <param name="buildIndexMode">This parameter determines whether an index file will be rebuilt if it already exists.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.BuildIndexFile(System.String,System.String,ThinkGeo.MapSuite.Core.Projection,System.String,System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>This method builds a spatial index only for those features that satisfy a regular expression, based on a passed-in projection.</summary>
            <overloads>
            This overload allows you to pass in a Shape File and only build an index for those features that satisfy the 
            regularExpression parameter.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a Shape File and specify the index filename to use.
            </remarks>
            <param name="shapePathFilename">This parameter specifies the Shape File for which to build the index.</param>
            <param name="indexPathFilename">This parameter determines the target index path filename.</param>
            <param name="projection">This parameter determines the projection that will be used to build the index against those features that satisfy the regular expression.</param>
            <param name="columnName">This parameter determines the column name whose values will be tested against the regular expression.</param>
            <param name="regularExpression">This parameter represents the regular expression to test against each feature for inclusion in the index.</param>
            <param name="buildIndexMode">This parameter determines whether an index file will be rebuilt if it already exists.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.BuildIndexFile(System.String,System.String,ThinkGeo.MapSuite.Core.Projection,System.String,System.String,ThinkGeo.MapSuite.Core.BuildIndexMode,System.Text.Encoding)">
            <summary>This method builds a spatial index only for those features that satisfy a regular expression, based on a passed-in projection.</summary>
            <overloads>
            This overload allows you to pass in a Shape File and only build an index for those features that satisfy the 
            regularExpression parameter.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a Shape File and specify the index filename to use.
            </remarks>
            <param name="shapePathFilename">This parameter specifies the Shape File for which to build the index.</param>
            <param name="indexPathFilename">This parameter determines the target index path filename.</param>
            <param name="projection">This parameter determines the projection that will be used to build the index against those features that satisfy the regular expression.</param>
            <param name="columnName">This parameter determines the column name whose values will be tested against the regular expression.</param>
            <param name="regularExpression">This parameter represents the regular expression to test against each feature for inclusion in the index.</param>
            <param name="buildIndexMode">This parameter determines whether an index file will be rebuilt if it already exists.</param>
            <param name="encoding">This parameter specifies the encoding information used in the source DBF file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.CloneShapeFileStructure(System.String,System.String)">
            <summary>
            Clone the structure from the source ShapeFile to the target ShapeFile. After cloning the structure, 
            the target ShapeFile will have the same type and the same DBF columns as the source ShapeFile, but without any records in it.
            </summary>
            <param name="sourceShapePathFilename">The source Shape File to be cloned.</param>
            <param name="targetShapePathFilename">The target Shape File, which will have the same structure as the source Shape File after cloning operation is complete.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.CloneShapeFileStructure(System.String,System.String,ThinkGeo.MapSuite.Core.OverwriteMode)">
            <summary>
            Clone the structure from the source ShapeFile to the target ShapeFile. After cloning the structure, 
            the target ShapeFile will have the same type and the same DBF columns as the source ShapeFile, but without any records in it.
            </summary>
            <param name="sourceShapePathFilename">The source Shape File to be cloned.</param>
            <param name="targetShapePathFilename">The target Shape File, which will have the same structure as the source Shape File after cloning operation is complete.</param>
            <param name="overwriteMode">This parameter specifies the overwrite mode when the target ShapeFile already exists.</param>
            <remarks>An exception will be thown when the target ShapeFile does not exist and the overwrite mode is set to DoNotOverwrite.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.CloneShapeFileStructure(System.String,System.String,ThinkGeo.MapSuite.Core.OverwriteMode,System.Text.Encoding)">
            <summary>
            Clone the structure from the source ShapeFile to the target ShapeFile. After cloning the structure, 
            the target ShapeFile will have the same type and the same DBF columns as the source ShapeFile, but without any records in it.
            </summary>
            <param name="sourceShapePathFilename">The source Shape File to be cloned.</param>
            <param name="targetShapePathFilename">The target Shape File, which will have the same structure as the source Shape File after cloning operation is complete.</param>
            <param name="overwriteMode">This parameter specifies the overwrite mode when the target ShapeFile already exists.</param>
            <param name="encoding"> This parameter specifies the encoding information in the source Shape File.</param>
            <remarks>An exception will be thown when the target ShapeFile does not exist and the overwrite mode is set to DoNotOverwrite.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.BuildRecordIdColumn(System.String,System.String,ThinkGeo.MapSuite.Core.BuildRecordIdMode)">
            <summary>
            Static API used to build RecordId. The Id will start from 0.
            </summary>
            <param name="shapeFilename">The name of the target ShapeFile on which to base the newly built RecordId.</param>
            <param name="fieldname">The field name for the RecordId.</param>
            <param name="rebuildNeeded">The RecordId build mode.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.BuildRecordIdColumn(System.String,System.String,ThinkGeo.MapSuite.Core.BuildRecordIdMode,System.Int32)">
            <summary>
            Static API used to build RecordId from the specified starting Id number.
            </summary>
            <param name="shapeFilename">The name of the target ShapeFile on which to base the newly built RecordId.</param>
            <param name="fieldname">The field name for the RecordId.</param>
            <param name="rebuildNeeded">The RecordId build mode.</param>
            <param name="startNumber">The starting Id number of the RecordId.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.BuildRecordIdColumn(System.String,System.String,ThinkGeo.MapSuite.Core.BuildRecordIdMode,System.Int32,System.Text.Encoding)">
            <summary>
            Static API used to build RecordId from the specified starting Id number.
            </summary>
            <param name="shapeFilename">The name of the target ShapeFile on which to base the newly built RecordId.</param>
            <param name="fieldname">The field name for the RecordId.</param>
            <param name="rebuildNeeded">The RecordId build mode.</param>
            <param name="startNumber">The starting Id number of the RecordId.</param>
            <param name="encoding"> This parameter specifies the encoding information in the DBF.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.GetShapeFileType">
            <summary>
            Get the Shape File type for the Shape File FeatureSource.
            </summary>
            <returns>The ShapeFileType for the ShapeFile FeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.SaveToProjection(System.String,System.String,ThinkGeo.MapSuite.Core.Projection,ThinkGeo.MapSuite.Core.OverwriteMode)">
            <summary>
            This API provide a easy way to project features in a shape file into another projection and save it to shape file.
            </summary>
            <param name="sourceShapeFile">This parameter specifies the source shape file to be projected.</param>
            <param name="targetShapeFile">This parameter specifies the target shape file to be saved for the projected features. </param>
            <param name="projection">This parameter is the projection to project the source shape file to target shape file. The source 
            Shape file should be in the FromProjection of the Projection prameter, and the targetShapeFile will be in the ToProjection 
            of the Projection.</param>
            <param name="overwriteMode">This parameter specifies the override mode when the target shape file exists.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.Validate">
            <summary>
            This method checks all features in a shapefile is supported by Mapsuite or not.
            </summary>
            <returns>A dictionary which contains all the unsupported features. The key is the Indexs which 
            failed to pass the check, the value contains the reason for its failure.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In ShapeFileFeatureLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.UsingSpatialIndex">
            <summary>
            This property gets whether the Shape File FeatureSource has an index or not.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.Encoding">
            <summary>
            This property gets and sets the encoding information for the DBF.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.ShapePathFileName">
            <summary>
            This property returns the path and filename of the Shape File you want to
            represent.
            </summary>
            <value>
            This property returns the path and filename of the Shape File you want to
            represent.
            </value>
            <remarks>
            None
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Setting an invalid PathFileName structure will throw an ArgumentException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.IndexPathFileName">
            <summary>
            This property returns the path and filename of the index file you want to
            represent.
            </summary>
            <value>
            This property returns the path and filename of the index file you want to
            represent.
            </value>
            <remarks>
            None
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Setting an invalid PathFileName structure will throw an ArgumentException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeFileFeatureLayer.RequireIndex">
            <summary>
            This property gets and sets whether an index is required when reading data. The default value is true.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LineShape">
            <summary>
            This class represents a LineShape, which is defined as a single line with two or
            more points.
            </summary>
            <remarks>
            The LineShape is one of the more commonly used shapes. Typically it is used for
            representing roads in GIS data files.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.#ctor">
            <overloads>This overload creates the LineShape without any points.</overloads>
            <summary>This constructor creates the LineShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Vertex})">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the points, we will throw an ArgumentNullException.</exception>
            <overloads>This overload creates the LineShape with a vertex collection.</overloads>
            <summary>This constructor creates the LineShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the LineShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates the LineShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.ReversePoints">
            <summary>This method reverses the order of the points in the line.</summary>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.ReversePointsCore">
            <summary>This method reverses the order of the points in the line.</summary>
            <remarks>None</remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and the copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.IsClosed">
            <summary>
            This method determines whether the line is closed, meaning that the last point and
            first point are the same.
            </summary>
            <remarks>None</remarks>
            <returns>The return value indicating whether the line is closed.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.IsClosedCore">
            <summary>
            This method determines whether the line is closed, meaning that the last point and
            first point are the same.
            </summary>
            <remarks>None</remarks>
            <returns>The return value indicating whether the line is closed.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetLengthCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>This method returns the length of the LineShape.</summary>
            <overloads>
            This overload returns the length in the unit of your choice, based on
            returningUnit you specify.
            </overloads>
            <returns>
            This overload returns the length in the unit of your choice, based on
            returningUnit you specify.
            </returns>
            <remarks>
            This is a useful method when you want to know the total length of a line-based
            shape. If the shape is a MultiLineShape, then the length is the sum of all of its
            lines.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetPointOnALine(ThinkGeo.MapSuite.Core.StartingPoint,System.Single)">
            <summary>
            	<para>This method returns a PointShape on the line, based on a percentage of the
                length of the line from the first or last vertex defined in the startingPoint
                parameter.</para>
            </summary>
            <returns>
            	<para>This method returns a PointShape on the line, based on a percentage of the
                length of the line from the first or last vertex defined in the startingPoint
                parameter.</para>
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<para>If you pass 100 or 0 as the percentage of the line, it will return either the
                first or last vertex, depending on the value of the startingPoint argument.</para>
            </remarks>
            <overloads>
            This overload allows you to pass a percentage determining how far you want to
            move along the line, as well as the option for starting from either the beginning or the end
            of the line.
            </overloads>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="percentageOfLine">
            This parameter defines the percentage into the line. Valid values are between 0
            and 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetPointOnALineCore(ThinkGeo.MapSuite.Core.StartingPoint,System.Single)">
            <summary>
            	<para>This method returns a PointShape on the line, based on a percentage of the
                length of the line from the first or last vertex defined in the startingPoint
                parameter.</para>
            </summary>
            <returns>
            	<para>This method returns a PointShape on the line, based on a percentage of the
                length of the line from the first or last vertex defined in the startingPoint
                parameter.</para>
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not between 0 and 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <remarks>
            	<para>If you pass 100 or 0 as the percentage of the line, it will return either the
                first or last vertex, depending on the value of the startingPoint argument.</para>
            </remarks>
            <overloads>
            This overload allows you to pass a percentage determining how far you want to
            move along the line, as well as the option for starting from either the beginning or the end
            of the line.
            </overloads>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="percentageOfLine">
            This parameter defines the percentage into the line. Valid values are between 0
            and 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetPointOnALine(ThinkGeo.MapSuite.Core.StartingPoint,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex defined in the startingPoint parameter.</para>
            </summary>
            <overloads>
            This overload allows you to pass a distance determining how far you want to move
            along the line using your unit of choice, as well as the option to start from
            the beginning or the end of the line.
            </overloads>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex defined in the startingPoint parameter.</para>
            </returns>
            <remarks>
            	<para>Passing in a 0 distance will return either the first or last point on the
                line, depending upon the value of the startingPoint parameter.</para>
            </remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="distance">
            This parameter specifies the distance into the line you wish to move in the unit
            specified by the distanceUnit parameter. Valid values must be greater than or equal to 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetPointOnALineCore(ThinkGeo.MapSuite.Core.StartingPoint,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex defined in the startingPoint parameter.</para>
            </summary>
            <overloads>
            This overload allows you to pass a distance determining how far you want to move
            along the line using your unit of choice, as well as the option to start from
            the beginning or the end of the line.
            </overloads>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <returns>
            	<para>This method returns a PointShape on the line, based on a distance on the
                line from the first or last vertex defined in the startingPoint parameter.</para>
            </returns>
            <remarks>
            	<para>Passing in a 0 distance will return either the first or last point on the
                line, depending on the value of the startingPoint parameter.</para>
            </remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="distance">
            This parameter specifies the distance into the line you wish to move in the unit
            specified by the distanceUnit parameter. Valid values must be greater than or equal to 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetLineOnALine(ThinkGeo.MapSuite.Core.StartingPoint,System.Single,System.Single)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass the starting point, starting percentage of the
            line and percentage of the line.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not greater than 0 and less than or equal to 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="startingPercentageOfTheLine">
            This parameter defines the starting percentage into the line. Valid values must be greater
            than 0 and less than or equal to 100.
            </param>
            <param name="percentageOfTheLine">
            This parameter defines the percentage into the line. Valid values must be greater
            than 0 and less than or equal to 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetLineOnALine(ThinkGeo.MapSuite.Core.StartingPoint,System.Single)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass the starting point and percentage of the
            line.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not greater than 0 and less than or equal to 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="percentageOfLine">
            This parameter defines the percentage into the line. Valid values must be greater
            than 0 and less than or equal to 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetLineOnALineCore(ThinkGeo.MapSuite.Core.StartingPoint,System.Single)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass the starting point and percentage of the
            line.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid number for the percentageOfLine which is not greater than 0 and less than or equal to 100 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <remarks>None</remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="percentageOfLine">
            This parameter defines the percentage into the line. Valid values must be greater
            than 0 and less than or equal to 100.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetLineOnALine(ThinkGeo.MapSuite.Core.StartingPoint,System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid startingDistance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to specify the starting point along with the starting
            distance. This allows you to get a certain distance of the line after the starting
            distance.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <remarks>None</remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="startingDistance">
            The starting distance from which you will start getting the line. For example, if
            the line is 3 units long and you have a starting distance of 1 unit, the result will
            be the last two units of the line. Valid values must be greater than 0. The starting
            distance will be in the GeographyUnit of the shape.
            </param>
            <param name="distance">
            The amount of the line you want to get after the startingDistance. Valid values
            must be greater than 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetLineOnALineCore(ThinkGeo.MapSuite.Core.StartingPoint,System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid startingDistance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than 0 will throw an ArgumentOutOfRangeException.</exception>
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to specify the starting point along with the starting
            distance. This allows you to get a certain distance of the line after the starting
            distance.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <remarks>None</remarks>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="startingDistance">
            The starting distance from which you will start getting the line. For example, if
            the line is 3 units long and you have a starting distance of 1 unit, the result will
            be the last two units of the line. Valid values must be greater than 0. The starting
            distance will be in the GeographyUnit of the shape.
            </param>
            <param name="distance">
            The amount of the line you want to get after the startingDistance. Valid values
            must be greater than 0.
            </param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetLineOnALine(ThinkGeo.MapSuite.Core.StartingPoint,ThinkGeo.MapSuite.Core.PointShape)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to specify the starting point and another point.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null endPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="endPointShape">
            The BaseLineShape returned will be between the startingPoint and the endPointShape
            specified in this parameter.
            </param>       
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetLineOnALineCore(ThinkGeo.MapSuite.Core.StartingPoint,ThinkGeo.MapSuite.Core.PointShape)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to specify the starting point and another point.
            </overloads>
            <returns>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a startingPoint that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null endPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="startingPoint">
            The startingPoint defines whether the method starts at the beginning or the end of the
            line.
            </param>
            <param name="endPointShape">
            The BaseLineShape returned will be between the startingPoint and the endPointShape
            specified in this parameter.
            </param>       
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetLineOnALine(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass in two points to get a BaseLineShape from the original LineShape.
            </overloads>
            <returns>
            This method returns a BaseLineShape based on a start PointShape and an end PointShape.        
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null startPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null endPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="startPointShape">
            The startPointShape defines where you will start to get the line. If it does not stand on this 
            LineShape, the closest point on the LineShape will be the start PointShape.
            </param>
            <param name="endPointShape">
            The endPointShape defines where you will stop getting the line. If it does not stand on this 
            LineShape, the closest point on the LineShape will be the end PointShape.
            </param>    
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetLineOnALineCore(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape)">
            <summary>
            This method returns a BaseLineShape, based on a starting position and other
            factors.
            </summary>
            <overloads>
            This overload allows you to pass in two points to get a BaseLineShape from the original LineShape.
            </overloads>
            <returns>
            This method returns a BaseLineShape based on a start PointShape and an end PointShape.        
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null startPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null endPointShape will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
            <param name="startPointShape">
            The startPointShape defines where you will start to get the line. If it does not stand on this 
            LineShape, the closest point on the LineShape will be the start PointShape.
            </param>
            <param name="endPointShape">
            The endPointShape defines where you will stop getting the line. If it does not stand on this 
            LineShape, the closest point on the LineShape will be the end PointShape.
            </param>    
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetDistanceToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>The distance returned will be in the unit of the shape.</overloads>
            <returns>
            The return type is the distance between this shape and the targetShape in the
            GeographyUnit of the shape.
            </returns>
            <remarks>
            	<para>In this method, we compute the closest distance between the two shapes. The
                returned unit will be in the unit of distance specified.</para>
            	<para>Overriding:</para>
            	<para>Please ensure that you validate the parameters being passed in and raise the
                exceptions defined above.</para>
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use as the return value. For example,
            if you select miles as your distanceUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.ScaleUpCore(System.Double)">
            <summary>
            This method increases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the LineShape by the percentage given in the
            percentage parameter.
            </summary>
            <remarks>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.RegisterCore(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another, based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another, based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.<br/></para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on a DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method returns a shape repositioned from one location to another based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles
                on the X axis and 3 miles on the Y axis.<br/></para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of vertical units of movement in the distance unit specified in
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the distance unit you would like to use as the measure for the
                move. For example, if you select miles as your distance unit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on a
            distance and a direction in degrees.
            </summary>
            <overloads>
            In this overload, the distance unit is based on a DistanceUnit you specify in the
            distanceUnit parameter, regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method returns a shape repositioned from one location to another based on
                angleInDegrees and distance parameter. With this overload, it is important to note that
                the distance is based on the supplied distanceUnit parameter. For example,
                if your shape is in decimal degrees and you call this method with a
                distanceUnit of miles, you're going to move this shape a number of miles based on
                the distance value and the angleInDegrees. In this way, you can easily move a shape in decimal
                degrees five miles to the north.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape using the angle specified.
            The distance unit will be the one specified in the distanceUnit parameter. The
            distance must be greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            This is the GeographicUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use as the measure for the move. For
            example, if you select miles as your distanceUnit, then the distance will be calculated
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.RotateCore(ThinkGeo.MapSuite.Core.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, than the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetClosestPointToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetWellKnownTextCore">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric figures.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has less than two points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Core.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe a geometry as a binary array. Well-known
            binary is useful when you want to save a geometry in an efficient format using as little
            space as possible. An alternative to well-known binary is well-known text, which is a
            textual representation of a geometry object. We have methods that work with well-known
            text as well.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies whether the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.ValidateCore(ThinkGeo.MapSuite.Core.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.GetCrossingCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.RemoveVertex(ThinkGeo.MapSuite.Core.Vertex,ThinkGeo.MapSuite.Core.LineShape)">
            <summary>
            This method removes the selected vertex from line shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of line shape, otherwise it will return false and line shape will keep the same.</param>
            <param name="lineShape">The line shape will be removed one vertex.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineShape.RemoveVertex(ThinkGeo.MapSuite.Core.Vertex)">
            <summary>
            This method removes the selected vertex from line shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of line shape, otherwise it will return false and line shape will keep the same.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineShape.Vertices">
            <summary>This property is the collection of points that make up the LineShape.</summary>
            <decimalDegreesValue>This property is the collection of points that make up the LineShape.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <decimalDegreesValue>This property specifies whether the shape can be rotated.</decimalDegreesValue>
            <remarks>
            If this property returns false and you attempt call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.StartingPoint">
            <summary>
            An enumeration describing the place to start on a line when doing certain
            operations.
            </summary>
            <remarks>
            Certain kinds of mathematical line operations need to know if the operation
            will start at the beginning or the end of the line. Whenever this is the case, you'll
            need to use this enumeration.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.StartingPoint.FirstPoint">
            <summary>The first point of the line.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.StartingPoint.LastPoint">
            <summary>The last point of the line.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ShapeValidationResult">
            <summary>This structure represents the result of the validation method performed on a shape.</summary>
            <remarks>
            This is used to determine if an validation rule was broken for a shape. This
            structure also returns the description of the violation.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeValidationResult.#ctor(System.Boolean,System.String)">
            <summary>
            This constructor allows you to set the IsValid and ValidationErrors
            properties.
            </summary>
            <remarks>None</remarks>
            <param name="isValid">This parameter describes whether the object has passed its validation method.</param>
            <param name="validationErrors">
            This parameter describes the list of errors if the object did not pass its
            validation method. The errors are separated by semicolons.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeValidationResult.op_Equality(ThinkGeo.MapSuite.Core.ShapeValidationResult,ThinkGeo.MapSuite.Core.ShapeValidationResult)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeValidationResult.op_Inequality(ThinkGeo.MapSuite.Core.ShapeValidationResult,ThinkGeo.MapSuite.Core.ShapeValidationResult)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeValidationResult.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeValidationResult.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeValidationResult.IsValid">
            <summary>This property describes whether the object has passed its validation method.</summary>
            <value>
            This property returns either true or false, depending on whether the object has passed its
            validation method.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ShapeValidationResult.ValidationErrors">
            <summary>
            This property describes the list of errors if the object did not pass its
            validation method.
            </summary>
            <remarks>
            If there are multiple errors, they will be separated by semicolons. If the object
            passed its validations, then this string will be empty.
            </remarks>
            <value>
            This property returns the list of errors if the object did not pass its
            validation method.
            </value>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.AreaUnit">
            <summary>Units describing various ways you can measure areas.</summary>
            <remarks>
            	<para>Area units are most commonly used when calling APIs that measure areas.
                Regardless of the unit of measure your shapes are in, many of our APIs allow you to
                specify what unit of measure you want the result of the method call to be in. For
                example, you may have a PolygonShape whose points are in decimal degrees; however, you
                want to know the area in square miles. This is easy to accomplish. Simply call the GetArea
                method on the PolygonShape, passing in the first parameter of decimal degrees (which
                defines what unit the shape is in), and then square miles as the area unit you would
                like the result to be in.</para>
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AreaUnit.SquareMeters">
            <summary>Square Meters</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AreaUnit.Acres">
            <summary>Acres</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AreaUnit.Hectares">
            <summary>Hectares</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AreaUnit.SquareFeet">
            <summary>Square Feet</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AreaUnit.SquareKilometers">
            <summary>Square Kilometers</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AreaUnit.SquareMiles">
            <summary>Square Miles</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AreaUnit.SquareUsSurveyFeet">
            <summary>Square US Survey Feet</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.AreaUnit.SquareYards">
            <summary>Square Yards</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoSolidBrush">
            <summary>
            	<para>This class defines a GeoBrush of a single color. Brushes are used to fill
                area shapes on a GeoCanvas.</para>
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoSolidBrush.#ctor">
            <summary>This is the constructor used to create a new GeoSolidBrush.</summary>
            <overloads>This constructor creates a GeoSolidBrush in the color black.</overloads>
            <remarks>None</remarks>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoSolidBrush.#ctor(ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>This is the constructor used to create a new GeoSolidBrush.</summary>
            <overloads>This constructor creates a GeoSolidBrush by passing in a GeoColor.</overloads>
            <remarks>None</remarks>
            <param name="color">This parameter represent the color of the GeoSolidBrush.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoSolidBrush.Color">
            <summary>This property gets or sets the color of the GeoSolidBrush.</summary>
            <decimalDegreesValue>This property gets the color of the GeoSolidBrush.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoColor">
            <summary>This structure represents a color for drawing on a GeoCanvas.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>This constructor creates a new color.</summary>
            <overloads>This constructor allows you to specify the red, green, and blue component.</overloads>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a red value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a green value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a blue value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="red">This parameter specifies the red component of the color.</param>
            <param name="green">This parameter specifies the green component of the color.</param>
            <param name="blue">This parameter specifies the blue component of the color.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>This constructor creates a new color.</summary>
            <overloads>
            This constructor allows you to specify the red, green, blue, and alpha
            component.
            </overloads>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a red value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a blue value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a green value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a alpha value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="alpha">
            This parameter specifies the alpha, or transparent, component of the
            color.
            </param>
            <param name="red">This parameter specifies the red component of the color.</param>
            <param name="green">This parameter specifies the green component of the color.</param>
            <param name="blue">This parameter specifies the blue component of the color.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.#ctor(System.Int32,ThinkGeo.MapSuite.Core.GeoColor)">
            <overloads>This overload creates a transparent version of another color.</overloads>
            <summary>This constructor creates a new color.</summary>
            <returns>None</returns>
            <remarks>
            You can use this overload to create a transparent version of another
            color.
            </remarks>
            <param name="alpha">
            This parameter specifies the alpha component. An alpha of 0 is totally
            transparent.
            </param>
            <param name="color">This parameter specifies the base color.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.GetColorsInHueFamily(ThinkGeo.MapSuite.Core.GeoColor,System.Int32)">
            <summary>
            This method returns a collection of GeoColors based on the same hue that is
            passed in.
            </summary>
            <remarks>
            This method is useful when you want to get a number of colors that have the same
            hue. For example, you can use this in maps that represent class breaks. If you passed in a red hue,
            then the method would return variations such as light red, dark red, pastel red, etc.
            </remarks>
            <returns>
            This method returns a collection of GeoColors based on the same hue that is
            passed in.
            </returns>
            <param name="baseColor">This parameter is the color on which you want to base the color collection.</param>
            <param name="numbersOfColors">
            This parameter represents the number of colors you want returned from the
            method.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfColors value that is not between 1 and 255, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.GetColorsInQualityFamily(ThinkGeo.MapSuite.Core.GeoColor,System.Int32)">
            <summary>
            This method returns a collection of GeoColors based on the same quality (luminosity and saturation) that is
            passed in.
            </summary>
            <returns>
            This method returns a collection of GeoColors based on the same quality (luminosity and saturation) that is
            passed in.
            </returns>
            <remarks>
            This method is useful when you want to get a number of different colors that have the same
            quality. For example, you can use this in maps that represent countries or connected places. If you
            passed in bright red, then the method would return variants such as bright blue, bright green,
            etc. If you passed in dark red, you would get dark blue, dark green, etc.
            </remarks>
            <param name="baseColor">This parameter is the color on which you want to base the color collection.</param>
            <param name="numberOfColors">
            This parameter represents the number of colors you want returned from the
            method.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfColors value that is not between 1 and 255, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.FromArgb(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This method returns a GeoColor based on the Alpha, Red, Green, and Blue
            components.
            </summary>
            <returns>
            This method returns a GeoColor based on the Alpha, Red, Green, and Blue
            components.
            </returns>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a alpha value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a red value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a green value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a blue value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This overload lets you specify each component.</overloads>
            <param name="alpha">
            This parameter specifies the alpha, or transparent, component of the
            color.
            </param>
            <param name="red">This parameter specifies the red component of the color.</param>
            <param name="green">This parameter specifies the green component of the color.</param>
            <param name="blue">This parameter specifies the blue component of the color.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.FromArgb(System.Int32,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>
            This method returns a GeoColor based on the Alpha, Red, Green, and Blue
            components.
            </summary>
            <overloads>This method creates a transparent version of another color.</overloads>
            <returns>
            You can use this overload to create a transparent version of another
            color.
            </returns>
            <param name="alpha">
            This parameter determines how transparent the color is. An alpha of 0 means it is
            totally transparent.
            </param>
            <param name="baseColor">This parameter is the color you want to apply the transparency to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.FromAhsl(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            This parameter specifies the red component of the color. This method returns a
            GeoColor based on the Alpha, Hue, Saturation, and Luminosity components.
            </summary>
            <remarks>None</remarks>
            <param name="alpha">
            This parameter specifies the alpha, or transparent, component of the
            color.
            </param>
            <param name="hue">This parameter specifies the hue component of the color.</param>
            <param name="saturation">This parameter specifies the saturation component of the color.</param>
            <param name="luminance">This parameter specifies the luminance component of the color.</param>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a alpha value which is not between 0 and 255, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a hue value which is not between 0 and 360, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a saturation value which is not between 0 and 100, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a luminance value which is not between 0 and 100, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.FromOle(System.Int32)">
            <summary>This method returns a GeoColor from an OLE color.</summary>
            <returns>This method returns a GeoColor from an OLE color.</returns>
            <remarks>None</remarks>
            <param name="oleColor">This parameter represents the OLE color you want to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.FromHtml(System.String)">
            <summary>This method returns a GeoColor from an HTML color (either in hexadecimal or a named color).</summary>
            <returns>This method returns a GeoColor from an HTML color (either in hexadecimal or a named color).</returns>
            <remarks>None</remarks>
            <param name="htmlColor">This parameter represents the HTML color that you want to convert.</param>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a htmlColor value which is not valid, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.GetRandomGeoColor(ThinkGeo.MapSuite.Core.RandomColorType)">
            <summary>
            Creates a random <strong>GeoColor</strong> structure based on the specific
            ColorType
            </summary>
            <overloads>Creates a GeoColor structure with random color</overloads>
            <param name="colorType">A <strong>ColorType</strong> defines types of color.</param>
            <returns>A <strong>GeoColor</strong> structure the method created.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.GetRandomGeoColor(System.Int32,ThinkGeo.MapSuite.Core.RandomColorType)">
            <summary>Creates a random <strong>GeoColor</strong> structure</summary>
            <overloads>Creates a <strong>GeoColor</strong> structure with random color</overloads>
            <returns>A <strong>GeoColor</strong> structure the method created.</returns>
            <param name="alpha"><para>The alpha component. Valid values are 0 through 
            255.</para></param>
            <param name="colorType">A <strong>ColorType</strong> defines types of color.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.FromWin32(System.Int32)">
            <summary>This method returns a GeoColor from a Win32 color.</summary>
            <returns>This method returns a GeoColor from a Win32 color.</returns>
            <remarks>None</remarks>
            <param name="win32Color">This parameter represents the Win32 color you want to convert.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.ToOle(ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>This method returns an OLE color from a GeoColor.</summary>
            <remarks>None</remarks>
            <returns>This method returns an OLE color from a GeoColor.</returns>
            <param name="color">This parameter represents the GeoColor you want to convert.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the drawingColor, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.ToHtml(ThinkGeo.MapSuite.Core.GeoColor)">
            <remarks>None</remarks>
            <summary>This method returns an HTML color from a GeoColor.</summary>
            <returns>This method returns an HTML color from a GeoColor.</returns>
            <param name="color">This parameter represents the GeoColor you want to convert.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the drawingColor, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.ToWin32(ThinkGeo.MapSuite.Core.GeoColor)">
            <example>
            None
            </example>
            <summary>This method returns a Win32 color from a GeoColor.</summary>
            <returns>This method returns a Win32 color from a GeoColor.</returns>
            <param name="color">This parameter represents the GeoColor you want to convert.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the drawingColor, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.op_Equality(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <returns>This method returns the equality of the two instances.</returns>
            <param name="geoColor1">This parameter represents the first GeoColor to compare.</param>
            <param name="geoColor2">This parameter represents the second GeoColor to compare.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetGeoColor, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the sourceGeoColor, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.op_Inequality(ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <returns>This method returns the inequality of the two instances.</returns>
            <param name="geoColor1">This parameter represents the first GeoColor to compare.</param>
            <param name="geoColor2">This parameter represents the second GeoColor to compare.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetGeoColor, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the sourceGeoColor, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <returns>This method returns the Equals functionality.</returns>
            <remarks>None</remarks>
            <param name="obj">
            This parameter is the object you want to check to see if it is equal to the current
            instance.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the obj, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoColor.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <returns>This method returns the hash code.</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoColor.IsTransparent">
            <summary>
            Verify if the GeoColor is transparent, it is considered to be transparent if the Alpha Value is 0.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoColor.AlphaComponent">
            <summary>This property returns the alpha component of the GeoColor.</summary>
            <decimalDegreesValue>This property returns the alpha component of the GeoColor.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoColor.RedComponent">
            <summary>This property returns the red component of the GeoColor.</summary>
            <decimalDegreesValue>This property returns the red component of the GeoColor.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoColor.GreenComponent">
            <summary>This property returns the green component of the GeoColor.</summary>
            <decimalDegreesValue>This property returns the green component of the GeoColor.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoColor.BlueComponent">
            <summary>This property returns the blue component of the GeoColor.</summary>
            <decimalDegreesValue>This property returns the blue component of the GeoColor.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoColor.Hue">
            <summary>This property returns the hue component of the GeoColor.</summary>
            <decimalDegreesValue>This property returns the hue component of the GeoColor.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoColor.Saturation">
            <summary>This property returns the saturation component of the GeoColor.</summary>
            <decimalDegreesValue>This property returns the saturation component of the GeoColor.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoColor.Luminance">
            <summary>This property returns the luminance component of the GeoColor.</summary>
            <decimalDegreesValue>This property returns the luminance component of the GeoColor.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoColor.GeographicColors">
            <summary>This method returns a list of commonly-used predefined geographic colors.</summary>
            <decimalDegreesValue>This method returns a list of commonly-used predefined geographic colors.</decimalDegreesValue>
            <remarks>
            You can use these as colors to represent many different types of geographic
            features.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoColor.StandardColors">
            <summary>This method returns a list of commonly-used predefined colors.</summary>
            <decimalDegreesValue>This method returns a list of commonly-used predefined colors.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoColor.SimpleColors">
            <summary>This method returns a list of simple predefined colors.</summary>
            <decimalDegreesValue>This method returns a list of simple predefined colors.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoImage">
            <summary>This class represents an image you want to use on the GeoCanvas.</summary>
            <remarks>
            This class was designed so that it can be used for any type of stream while still
            being easy to use. For example, you can specify a path and filename in the constructor and the
            class will hold this. When the GeoCanvas needs the image, it will get its stream and
            then pass it off for drawing. After drawing, it disposes of the stream so there are no
            wasted resources.<br/>
            	<br/>
            You can also pass in a path and filename that does not actually exist on disk.  In that
            case we will raise an event where you can provide a stream on demand. With this
            function, you can use compressed streams, isolated storage and many other stream-related
            storage machanisms.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoImage.#ctor">
            <overloads>
            This constructor allows you to create a drawing image without specifying a
            PathFileName.
            </overloads>
            <remarks>You need to set the PathFileName if you intend to use this constructor.</remarks>
            <summary>This is the constructor used to create a new GeoImage.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoImage.#ctor(System.String)">
            <overloads>
            This constructor allows you to create a drawing image by specifying a
            PathFileName.
            </overloads>
            <summary>This is the constructor to create a new GeoImage</summary>
            <remarks>
            When you specify the path and filename, it should be in the correct format as
            such; however, the file does not need to exist on the file system. This is to allow us
            to accept streams supplied by the developer at runtime. If you choose to provide a file
            that exists, then we will attempt to use it. If we cannot find it, then we will raise the
            SteamLoading event and allow you to supply the stream. For example, you can pass in
            "C:\NotARealPath\File1.ecw", which does not exist on the file system. When we raise the
            event for you to supply a stream, we will pass to you the path and filename so you can
            differentiate the files.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing an invalid PathFileName structure will throw an ArgumentException.</exception>
            <param name="pathFileName">
            The path and filename of the image file. Note that this need not actually exisit on the file
            system; see remarks below.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoImage.#ctor(System.IO.Stream)">
            <summary>This is the constructor to create a new GeoImage.</summary>
            <overloads>
            This overload allows you to pass in a stream, as long as it is in TIFF
            format.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you have a stream or an image in TIFF format, you can use this constructor to
            create a GeoImage from it.
            </remarks>
            <param name="imageStream">This parameter must be a stream in TIFF format.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoImage.#ctor(System.Int32,System.Int32)">
            <summary>This is the constructor to create a new GeoImage</summary>
            <overloads>
            This constructor allows you to create a GeoImage by specifying a width, height
            and a GeoCanvas.
            </overloads>
            <returns>None</returns>
            <remarks>
            You can use this overload when you want to create a new GeoImage and only want to
            specify the width and height. You also need to pass in a GeoCanvas that will be used to
            create the GeoImage.
            </remarks>
            <param name="width">This parameter is the width in pixels for the new GeoImage.</param>
            <param name="height">This parameter is the height in pixels for the new GeoImage.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoImage.OnStreamLoading(ThinkGeo.MapSuite.Core.StreamLoadingEventArgs)">
            <summary>
            This method raises the StreamLoading event, allowing you to specify your own
            stream.
            </summary>
            <remarks>None</remarks>
            <param name="e">This parameter represents the event arguments for the StreamLoading event.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoImage.GetImageStream(ThinkGeo.MapSuite.Core.GeoCanvas)">
            <summary>This method returns the stream of the GeoImage.</summary>
            <returns>This method returns the stream of the GeoImage.</returns>
            <remarks>
            This method will raise the event that allows the user to supply their own stream.
            The event is also raised if they do not attempt to open the file specified in the PathFileName
            property.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoImage stream is invalid, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoImage.GetImageStreamCore(ThinkGeo.MapSuite.Core.GeoCanvas)">
            <remarks>
            This method will raise the event that allows the user to supply their own stream.
            The event is also raised if they do not attempt to open the file specified in the PathFileName
            property.
            </remarks>
            <summary>This method returns the stream of the GeoImage.</summary>
            <returns>This method returns the stream of the GeoImage.</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoImage stream is invalid it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoImage.GetWidth">
            <summary>This method gets the width (in pixels) of this image.</summary>
            <returns>This method returns the width (in pixels) of this image.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoImage.GetHeight">
            <summary>This method gets the height (in pixels) of this image.</summary>
            <returns>This method returns the height (in pixels) of this image.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoImage.Close">
            <summary>This method closes the GeoImage. It is the same as calling the Dispose.</summary>
            <returns>None</returns>
            <remarks>This method closes the GeoImage. It is the same as calling the Dispose.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoImage.Finalize">
            <summary>
            This is the Dispose method for the class.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoImage.Dispose">
            <summary>This is the Dispose for the class.</summary>
            <overloads>
            This overload will dispose of the stream in the GeoImage and release its
            resources.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload will dispose of the stream in the GeoImage and release its
            resources.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.GeoImage.StreamLoading">
            <summary>
            This event allows you to pass in your own stream to represent the
            GeoImage.
            </summary>
            <remarks>
            If you choose, you can pass in your own stream to represent the GeoImage. The
            stream can come from a variety of places, such as isolated storage, a compressed file,
            or an encrypted stream. When the GeoImage is finished with the stream it will dispose
            of it, so be sure to keep this in mind when passing the stream in. If you do not pass in
            an alternate stream, the GeoImage will attempt to load the file from the file system
            using the PathFileName property.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoImage.PathFilename">
            <summary>
            This property returns the path and filename of the image you want to
            represent.
            </summary>
            <decimalDegreesValue>
            This property returns the path and filename of the image you want to
            represent.
            </decimalDegreesValue>
            <remarks>
            When you specify the path and filename, it should be in the correct format as
            such; however, the file does not need to exist on the file system. This is to allow us
            to accept streams supplied by the developer at runtime. If you choose to provide a file
            that exists, then we will attempt to use it. If we cannot find it, then we will raise the
            SteamLoading event and allow you to supply the stream. For example, you can pass in
            "C:\NotARealPath\File1.ecw", which does not exist on the file system. When we raise the
            event for you to supply a stream, we will pass to you the path and filename so you can
            differentiate the files.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Setting an invalid PathFileName structure will throw an ArgumentException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoImage.PathName">
            <summary>This property returns the path part of the PathFileName.</summary>
            <decimalDegreesValue>This property returns the path part of the PathFileName.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoImage.FileName">
            <summary>This property returns the filename part of the PathFileName.</summary>
            <decimalDegreesValue>This property returns the filename part of the PathFileName.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoImage.CanvasImageFormat">
            <summary>This property returns the image format.</summary>
            <decimalDegreesValue>This property returns the image format.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.OpenedFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in the OpenedFeatureSource
            event.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.OpenedFeatureSourceEventArgs.#ctor">
            <summary>This is the default constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.FeatureSourceColumn">
            <summary>This class represents a column contained within a FeatureSource.</summary>
            <remarks>
            A FeatureSource is typically represented by a number of InternalFeatures and their column
            data. This column represents the characteristics of that data.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSourceColumn.#ctor">
            <summary>This is the constructor to create a FeatureSourceColumn.</summary>
            <overloads>This overload creates a FeatureSourceColumn that is empty.</overloads>
            <returns>None</returns>
            <remarks>This constructor is the default, but should not be used.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSourceColumn.#ctor(System.String)">
            <summary>This is the constructor to create a FeatureSourceColumn.</summary>
            <overloads>
            This overload creates a FeatureSourceColumn by specifying the column's name only.
            </overloads>
            <returns>None</returns>
            <remarks>This is the constructor that should be used.</remarks>
            <param name="columnName">This parameter represents the name of the column.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSourceColumn.#ctor(System.String,System.String,System.Int32)">
            <summary>This is the constructor to create a FeatureSourceColumn.</summary>
            <overloads>
            This overload creates a FeatureSourceColumn by specifying the column's name, type
            and max length.
            </overloads>
            <returns>None</returns>
            <remarks>This is the constructor that should be used.</remarks>
            <param name="columnName">This parameter represents the name of the column.</param>
            <param name="typeName">This parameter represents the type name of the column.</param>
            <param name="maxLength">This parameter represents the maximum length of the column.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FeatureSourceColumn.ToString">
            <summary>
            Returns column name of FeatureSourceColumn
            </summary>
            <returns>Returns column name of FeatureSourceColumn</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSourceColumn.ColumnName">
            <summary>This property returns the name of the column.</summary>
            <decimalDegreesValue>This property returns the name of the column.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSourceColumn.TypeName">
            <summary>This property returns the type name of the column.</summary>
            <decimalDegreesValue>This property returns the type name of the column.</decimalDegreesValue>
            <remarks>
            This property is freeform and the type name is not tied to anything. It is wise
            to try and use familiar type names such as string, integer, date, etc., although it may
            not fit every different type of FeatureSource. We suggest thar you avoid using this property
            unless you know the types beforehand or simply want them for display purposes.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.FeatureSourceColumn.MaxLength">
            <summary>This property returns the maximum length of the column.</summary>
            <decimalDegreesValue>This property returns the maximum length of the column.</decimalDegreesValue>
            <remarks>
            The maximum length is user defined and not in any way enforced in our default
            FeatureSource implementation. It is mainly for display purposes or when dealing with a
            known Feature Source type.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource">
            <summary>This class represents a FeatureSource backed by multiple ESRI Shape Files.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.#ctor(System.String)">
             <summary>This is the constructor for the class.</summary>
             <overloads>
             This is the  constructor for this class. 
             </overloads>
             <returns>None</returns>
             <remarks>
             This is the constructor for this class. You can pass in a
             multipleShapeFilePattern like C:\MapData\??lka.shp to use all the shp files in the
             C:\MapData\ folder with a five letters as its file name without extentsion, the last three
            should be "lka". And also you can use c:\MapData\USRoad??.shp as the parameter to
             use all the file which the file name begin with "USRoad" and end with any 2 character
             shape file; like "USRoadA1.shap" or "USRoad_1.shp".
             </remarks>
             <param name="multipleShapeFilePattern">
             This parameter represents the shape file path pattern. The format of it should be
             "C:\MapData\USRoad??.Shp".
             </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.#ctor(System.String,System.String)">
             <summary>This is the constructor for the class.</summary>
             <overloads>
             This is the constructor for this class. It allows you passing the shape file
             pattern and index file pattern to create this class.
             </overloads>
             <returns>None</returns>
             <remarks>
             This is the constructor for this class. You can pass in a
             multipleShapeFilePattern like C:\MapData\??lka.shp to use all the shp files in the
             C:\MapData\ folder with a five letters as its file name without extentsion, the last three
            should be "lka". And also you can use c:\MapData\USRoad??.shp as the parameter to
             use all the file which the file name begin with "USRoad" and end with any 2 character
             shape file; like "USRoadA1.shap" or "USRoad_1.shp".
             </remarks>
             <param name="multipleShapeFilePattern">
             This parameter represents the shape file path pattern. The format of it should be
             "C:\MapData\USRoad??.Shp".
             </param>
             <param name="indexFilePattern">
             This parameter represents the index file path pattern. The format of it should be
             "C:\MapData\USRoad??.idx".
             </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.#ctor(System.String[],System.String[])">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This is the  constructor for this class. 
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the constructor for this class. You can pass in a group of shapes and its corresponding indexs 
            like string[] shapeFiles = new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" };
                 string[] indexFiles = new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" };
            In this way, the MultipleShapeFileFeatureSource will construct from the passing 2 shapes.
            </remarks>
            <param name="multipleShapeFiles">
            This parameter represents the shape files to construct the ShapeFileFeatureSource. The format of it should be
            new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" }.
            </param>
            <param name="multipleShapeFileIndexes">
            This parameter represents the shape files to construct the ShapeFileFeatureSource. The format of it should be
             new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" }.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.GetShapePathFileNames">
            <summary>
            This method gets all the shape's path and filenames are using in this class based
            on the pass in MultipleShapeFilePattern.
            </summary>
            <returns>
            This method gets all the shape's path and filenames are using in this class based
            on the pass in MultipleShapeFilePattern.
            </returns>
            <remarks>
            	<para>This method gets all the shape's path and filenames are using in this class
                based on the pass in MultipleShapeFilePattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.shp" as the MultipleShapeFilePattern,
                this method will return a collection which contains all the shape file in folder
                "C:\MapData\" which filename only has 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.shp" as the
                MultipleShapeFilePattern, this method will return a collection which contains all
                the shape file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.shp or USRoad_A.shp.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.GetIndexPathFileNames">
            <remarks>
            	<para>This method gets all the index's path and filenames are using in this class
                based on the pass in MultipleIndexFilePattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.idx" as the MultipleIndexFilePattern,
                this method will return a collection which contains all the index file in folder
                "C:\MapData\" which filename has only 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.idx" as the
                MultipleIndexFilePattern, this method will return a collection which contains all
                the index file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.idx or USRoad_A.idx. By the way, the file named
                <strong>A</strong>USRoadA1.idx and USRoadA1<strong>A</strong>.idx will NOT included
                in the returning collection.</para>
            </remarks>
            <summary>
            This method gets all the index's path and filenames are using in this class based
            on the pass in MultipleIndexFilePattern.
            </summary>
            <returns>
            This method gets all the index's path and filenames are using in this class based
            on the pass in MultipleIndexFilePattern.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.BuildIndex(System.String)">
            <summary>This method build spatial index for a passed group of shape files.</summary>
            <overloads>
            This method build spatial index for a passed group of shape files based on the
            pass in parameter.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">
            	<para>This parameter reprensents the shape file's name in the pattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.shp" as the MultipleShapeFilePattern,
                this method will return a collection which contains all the .shp file in folder
                "C:\MapData\" which filename has only 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.shp" as the
                MultipleShapeFilePattern, this method will return a collection which contains all
                the shape file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.shp or USRoad_A.shp.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.BuildIndex(System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>This method build spatial index for a passed group of shape files.</summary>
            <overloads>
            This method build spatial index for a passed group of shape files based on the
            pass in parameter.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">
            	<para>This parameter reprensents the shape file's name in the pattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.shp" as the MultipleShapeFilePattern,
                this method will return a collection which contains all the .shp file in folder
                "C:\MapData\" which finename has only 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.shp" as the
                MultipleShapeFilePattern, this method will return a collection which contains all
                the shape file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.shp or USRoad_A.shp.</para>
            </param>
            <param name="buildIndexMode">
            This parameter determines what will happen if there is an existing index
            file.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.BuildIndex(System.String,System.String)">
            <summary>This method build spatial index for a passed group of shape files.</summary>
            <overloads>
            This method build spatial index for a passed group of shape files based on the
            pass in parameter; and the spatial index file name will be in the
            indexFilePattern.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">
            	<para>This parameter reprensents the shape file's name in the pattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.shp" as the MultipleShapeFilePattern,
                this method will return a collection which contains all the .shp file in folder
                "C:\MapData\" which finename has only 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.shp" as the
                MultipleShapeFilePattern, this method will return a collection which contains all
                the shape file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.shp or USRoad_A.shp.</para>
            </param>
            <param name="indexFilePattern">
            	<para>This parameter reprensents the dindex file's name in the pattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.idx" as the MultipleIndexFilePattern,
                this method will return a collection which contains all the .idx file in folder
                "C:\MapData\" which finename has only 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.idx" as the
                MultipleIndexFilePattern, this method will return a collection which contains all
                the index file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.idx or USRoad_A.idx.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.BuildIndex(System.String,System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>This method build spatial index for a passed group of shape files.</summary>
            <overloads>
            This method build spatial index for a passed group of shape files based on the
            pass in parameter; and the spatial index file name will be in the
            indexFilePattern.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">
            	<para>This parameter reprensents the shape file's name in the pattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.shp" as the MultipleShapeFilePattern,
                this method will return a collection which contains all the .shp file in folder
                "C:\MapData\" which finename has only 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.shp" as the
                MultipleShapeFilePattern, this method will return a collection which contains all
                the shape file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.shp or USRoad_A.shp.</para>
            </param>
            <param name="indexFilePattern">
            	<para>This parameter reprensents the dindex file's name in the pattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.idx" as the MultipleIndexFilePattern,
                this method will return a collection which contains all the .idx file in folder
                "C:\MapData\" which finename has only 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.idx" as the
                MultipleIndexFilePattern, this method will return a collection which contains all
                the index file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.idx or USRoad_A.idx.</para>
            </param>
            <param name="buildIndexMode">
            This parameter determines what will happen if there is an existing index
            file.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.BuildIndex(System.String,System.String,System.String,System.String)">
            <summary>
            This method build spatial index for a passed group of shape files.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression,besides this, this overloads will pass in a target index projection.
            You can also specify if you want to rebuild an existing index file.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">This parameter is the shape file name pattern that you want to build an index for. </param>
            <param name="columnName"> The columnName to be used to get the value to match the regex expression.</param>
            <param name="regularExpression">This parameter specifies the regex expression to filter out thoese records to build index with.</param>
            <param name="indexFilename">This parameter specifies the index file name.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.BuildIndex(System.String,System.String,System.String,System.String,ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>
            This method build spatial index for a passed group of shape files.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression,besides this, this overloads will pass in a target index projection.
            You can also specify if you want to rebuild an existing index file.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">This parameter is the shape file name pattern that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="columnName"> The columnName to be used to get the value to match the regex expression.</param>
            <param name="regularExpression">This parameter specifies the regex expression to filter out thoese records to build index with.</param>
            <param name="buildIndexMode">This parameter determines what will happen if there is an existing index file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.BuildIndex(System.String[],System.String[])">
            <summary>
            This method build spatial index for a passed group of shape files.
            </summary>
            <param name="multipleShapeFiles">
            This parameter represents the shape files to construct the MultipleShapeFileFeatureLayer. The format of it should be
            new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" }.
            </param>
            <param name="multipleShapeFileIndexes">
            This parameter represents the shape files to construct the ShapeFileFeatureLayer. The format of it should be
             new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" }.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.BuildIndex(System.String[],System.String[],ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>
            This method build spatial index for a passed group of shape files.
            </summary>
            <param name="multipleShapeFiles">
            This parameter represents the shape files to construct the MultipleShapeFileFeatureLayer. The format of it should be
            new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" }.
            </param>
            <param name="multipleShapeFileIndexes">
            This parameter represents the shape files to construct the ShapeFileFeatureLayer. The format of it should be
             new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" }.
            </param>
            <param name="buildIndexMode">
            This parameter determines whether the index file will be rebuilt if it already
            exists.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.GetColumnsCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the columns available for the FeatureSource.</summary>
            <remarks>
            As this is the virtual core version of the Columns method it is intended to
            be overridden in inherited version of the class. When overriding you will be
            responsible for getting a list of all of the columns supported by the FeatureSource. In
            this way the FeatureSource will know what columns are available and will remove any
            extra columns when making calls to other core methods. For example if you have a
            FeatureSource that has three columns of information and the user calls a method and
            requests four columns of information, something they can do with custom fields, we will
            first compare what they are asking for to the results of the GetColumnsCore. In this
            way we can strip out custom columns before calling other Core methods which are only
            responsible for returning data in the FeatureSource. For more information on custom
            fields you can see the documentation on the OnCustomFieldsFetch.
            </remarks>
            <returns>This method returns the columns available for the FeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has already been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concreate public method Open.
            The open method play an important role as it is responsible for initializing the
            FeatureSource. Most methods on the FeatureSource will throw an exception if the state
            of the FeatureSource is not opened. When the map draws each layer it will open the
            FeatureSource as one of its first steps, then after it is finished drawing with that
            layer it will close it. In this way we are sure to release all resources used by the
            FeatureSource.<br/>
            	<br/>
            When implementing this virtual method consider opening files for file based source,
            connecting to databases in the database based sources and so on. You will get a chance
            to close these in the Close method of the FeatureSource.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.CloseCore">
            <summary>
            This method closes the FeatureSource and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concreate public method Close.
            The close method plays an important role in the life cycle of the FeatureSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            It is recommended that if you override this method that you take the following things
            into account. This method may be called multiple times so we suggest you write the so
            that that a call to a closed FeatureSource is ignored and does not generate an error.
            We also suggest that in the close you free all resources that have been opened.
            Remember that the object will not be destroyed but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.CommitTransactionCore(ThinkGeo.MapSuite.Core.TransactionBuffer)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction it will throw an InvalidOperationException.</exception>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
            <remarks>
            	<para>This method will commit the existing transaction to its underlying source of
                data. It will pass back the results of how the commit went to include any error
                received. If you are implementing your own FeatureSource then this is one of the
                crucial methods you must create. It should be fairly straight forward that you will
                loop through the transaction buffer and add, edit or delete the InternalFeatures in your
                underlying data source. Remember to build and pass back the TransactionResult class
                so that users of your FeatureSource can respond to failures you may encounter
                committing the InternalFeatures. We will handle the end of the transaction and also the
                cleanup of the transaction buffer. Your task will be to commit the records and
                produce a TransactionResult return.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited
                implementation of any specific source such as Oracle Spatial or Shape files. In
                this way it functions the same way for every FeatureSource. You start by calling
                the BeginTransaction. This allocates a collection of in memory change buffers that
                are used to store changes until you commit the transaction. So for example when you
                call the Add, Delete or Update method the changes to the feature are stored in
                memory only. If for any reason you choose to abandon the transaction you can call
                RollbackTransaction at any time and the in memory buffer will be deleted and the
                changes will be lost. When you are ready to commit the transaction you call the
                CommitTransaction and the collections of changes are then passed to the
                CommitTransactionCore method and the implementer of the specific FeatureSource is
                responsible for integrating your changes into the underlying FeatureSource. By
                default the IsLiveTransaction property is set to false which means that until you
                commit the changes the FeatureSource API will not reflect any changes that are in
                the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true then things function
                slightly differently. The live transaction concept means that all of the
                modification you perform during a transaction are live from the standpoint of the
                querying methods on the object.</para>
            	<para>To setup an example imagine that you have a FeatureSource that has 10 records
                in it. Next you begin a transaction and then call GetAllFeatures, the result would
                be 10 records. After that you call a delete on one of the records and call the
                GetAllFeatures again, this time you only get nine records. You receive nine records
                even though the transaction has not yet been committed. In the same sense you could
                have added a new record or modified an existing one and those changes are
                considered live though not committed.</para>
            	<para>In the case where you modify records such as expanding the size of a polygon
                those changes as well are reflected. So for example you expand a polygon by
                doubling its size and then do a spatial query that would not normally return the
                smaller record but would return the larger records, in this case the larger record
                is returned. You can set this property to be false as well in which case all of the
                spatial related methods would ignore anything that is currently in the transaction
                buffer waiting to be committed. In this case only after committing the transaction
                would the FeatureSource reflect the changes.</para>
            </remarks>
            <returns>
            The return decimalDegreesValue of this method is a TransactionResult class which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful and any error that were encountered during the
            committing of the transaction.
            </returns>
            <param name="transactions">
            This parameter encapsulates all of the adds, edits and deleted that make up the
            transaction. You will use this data to write the changes to your underlying data
            source.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.GetAllFeaturesCore(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. You will not need
            to consider anything about pending transactions as this will be handled in the non Core
            version of the method.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We wanted as the framework developers to provide you
            the user with as much default virtual implementation as possible. To do this we needed
            a way to get access to all of the features. For example, we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all the records then we can brute force
            the answer. In this way if you inherited form this class and only implemented this one
            method we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource
            it comes with a price. The price is that it is very inefficient. In the case we just
            discussed about finding all of the InternalFeatures in a bounding box we would not want to look
            at every record to fulfil this method. Instead we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be fast. For
            example in Oracle Spatial there is a specific SQL statement to do this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. It will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.
            </remarks>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetBoundingBox. It does not take into account any transaction activity as this is
                the responsibility of the concreate public method GetBoundingBox. In this way as a
                developer if you choose to override this method you do not have to consider
                transaction at all.<br/>
            		<br/>
                The default implementation of GetBoundingBoxCore uses the GetAllRecordsCore method
                to calculate the bounding box of the FeatureSource. We strongly recommend that you
                provide your own implementation for this method that will be more efficient<br/>
            		<br/>
                If you do not override this method the means it gets the BoundingBox is by calling
                the GetAllFeatureCore method and deriving it from each feature. This is a very
                inefficient way to get the BoundingBox in most data sources. It is highly
                recommended that you override this method and replace it with a highly optimized
                version. For example in a ShapeFile the BoundingBox is in the main header of the
                file. Similarly if you are using Oracle Spatial you can execute a simple query to
                get the BoundingBox of all of the record without returning them. In these ways you
                can greatly improve the performance of this method.</para>
            </remarks>
            <summary>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </summary>
            <returns>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.GetCountCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <summary>
            This method returns the count of the number of records in this
            FeatureSource.
            </summary>
            <returns>
            This method returns the count of the number of records in this
            FeatureSource.
            </returns>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetCount. It does not take into account any transaction activity as this is the
                responsibility of the concreate public method GetCount. In this way as a developer
                if you choose to override this method you do not have to consider transaction at
                all.<br/>
            		<br/>
                The default implementation of GetCountCore uses the GetAllRecordsCore method to
                calculate how many records there are in the FeatureSource. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient<br/>
            		<br/>
                If you do not override this method the means it gets the count is by calling the
                GetAllFeatureCore method and counting each feature. This is a very inefficient way
                to get the count in most data sources. It is highly recommended that you override
                this method and replace it with a highly optimized version. For example in a
                ShapeFile the record count is in the main header of the file. Similarly if you are
                using Oracle Spatial you can execute a simple query to get the count of all of the
                record without returning them. In these ways you can greatly improve the
                performance of this method.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.GetFeaturesByIdsCore(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns a collection of InternalFeatures by providing a group of Ids.</summary>
            <returns>This method returns a collection of InternalFeatures by providing a group of Ids.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetAllFeaturesCore. Because of this if you want an
            efficient version of this method then we high suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids which uniquely identified the InternalFeatures
            in the FeatureSource.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the ids we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.GetFeaturesInsideBoundingBoxCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box.
            </summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions as this is handled by the concreate version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesInsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding box. We
            strongly recommend that you provide your own implementation for this method that will
            be more efficient. It is especially important for this method as many other default
            virtual methods use this for their calculations. We highly recommend when you override
            this method that you use any spatial indexes you have at your disposal to make this
            method as fast as possible.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.GetFeaturesOutsideBoundingBoxCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </returns>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </summary>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box. If you are in a transaction and that transaction is live then
            it will also take that into consideration.<br/>
            	<br/>
            	<br/>
            The default implementation of GetFeaturesOutsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are outside of the bounding box.
            We strongly recommend that you provide your own implementation for this method that
            will be more efficient
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.GetFeaturesWithinDistanceOfCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape. It is important to note that the TargetShape and the FeatureSource
            use the same unit such as feet or meters. If they do not then the results will not be
            predictable or correct. If there is a current transaction and it is marked as live then
            the results will include any transaction Feature that applies.<br/>
            	<br/>
            The implementation we provided create a bounding box around the TargetShape using the
            distance supplied and then queries the features inside of it. This may not the most
            efficient method for this operation. If you underlying data provider exposes a more
            efficient way we recommend you override the Core version of this method and implement
            it.<br/>
            	<br/>
            The default implementation of GetFeaturesWithinDistanceOfCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient. We
            recommend when you override GetFeaturesInsideBoundingBoxCore method that you use any
            spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetShape">The shape you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the unit of the distance parameter such as feet, miles
            or kilometers etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.GetFeaturesNearestToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape. It is important to note that the TargetShape and the FeatureSource use the
            same unit such as feet or meters. If they do not then the results will not be
            predictable or correct. If there is a current transaction and it is marked as live then
            the results will include any transaction Feature that applies.<br/>
            	<br/>
            The implementation we provided create a small bounding box around the TargetShape and
            then queries the features inside of it. If we reach the number of items to find then we
            measure the returned InternalFeatures to find the nearest. If we do not find enough records we
            scale up the bounding box and try again. As you can see this is not the most efficient
            method. If you underlying data provider exposes a more efficient way we recommend you
            override the Core version of this method and implement it.<br/>
            	<br/>
            The default implementation of GetFeaturesNearestCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient. We
            recommend when you override GetFeaturesInsideBoundingBoxCore method that you use any
            spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetShape">This parameter is the shape you should to find close InternalFeatures to.</param>
            <param name="unitOfData">
            This parameter is the unit of what the TargetShape and the FeatureSource is in
            such as feet, meters etc.
            </param>
            <param name="numberOfItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfItemsToFind that is not greater than 0 it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid we will throw an ArgumentException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.MultipleShapeFilePattern">
            <summary>This parameter gets and sets the shape file pattern.</summary>
            <value>This parameter gets and sets the shape file pattern.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.IndexFilePattern">
            <summary>This parameter gets and sets the index file pattern.</summary>
            <value>This parameter gets and sets the index file pattern.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultipleShapeFileFeatureSource.IsEditable">
            <summary>This property returns if the FeatureSource allows edits or is read only.</summary>
            <decimalDegreesValue>
            This property returns if the FeatureSource allows edits or is read only. The
            property returns true if the FeatureSource allows edits and false if the FeatureSource
            is read only.
            </decimalDegreesValue>
            <remarks>
            	<para>This property is useful to check if a specific FeatureSource accepts editing.
                If you call the BeginTransaction and this property is false then an exception will
                be raised.<br/>
            		<br/>
                For developers who are creating or extending a FeatureSource it is expected that
                you override this virtual method if the new FeatureSource you are creating allows
                edits. By default the decimalDegreesValue if false meaning that if you want to allow edits you
                must override this method and return true.</para>
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WorldFile">
            <summary>This class represents the values of a world file.</summary>
            <remarks>
            A world file is an attribute file that is associated with a corresponding image file.
            Typically, the world file consists of 6 lines of numbers.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldFile.#ctor">
            <summary>This is the default constructor for the WorldFile class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldFile.#ctor(System.String)">
            <summary>
            This is the constructor that passes the worldFile text.
            </summary>
            <remarks> The worldFileText is typically read from a world file.</remarks>
            <param name="worldFileText">The world file text containing the world file attribute information.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldFile.#ctor(ThinkGeo.MapSuite.Core.RectangleShape,System.Single,System.Single)">
            <summary>
            This is the constructor that passes the WorldExtent of the image, the height of
            the image, and the width of the image.
            </summary>
            <param name="worldExtent">This parameter specifies the World Coordinate Extent for the image.</param>
            <param name="imageWidth">This parameter specifies the image width for the image.</param>
            <param name="imageHeight">This parameter specifies the image height for the image.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldFile.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            This is a constructor that passes 6 attributes in double associated with the corresponding
            image file.
            </summary>
            <returns>None</returns>
            <param name="horizontalResolution">This parameter specifies the size of pixels in the x direction.</param>
            <param name="rotationRow">This parameter specifies the rotation term for row.</param>
            <param name="rotationColumn">This parameter specifes the rotation term for column.</param>
            <param name="verticalResolution">This parameter specifies the size of pixels in the y direction.</param>
            <param name="upperLeftX">This parameter represents the x coordinate of the center of the upper-leftmost pixel in map units.</param>
            <param name="upperLeftY">This parameter represents the y coordinate of the center of the upper-leftmost pixel in map units.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldFile.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            This is a constructor that passes 6 attributes in float associated with the corresponding
            image file.
            </summary>
            <returns>None</returns>
            <param name="horizontalResolution">This parameter specifies the size of pixels in the x direction.</param>
            <param name="rotationRow">This parameter specifies the rotation term for row.</param>
            <param name="rotationColumn">This parameter specifes the rotation term for column.</param>
            <param name="verticalResolution">This parameter specifies the size of pixels in the y direction.</param>
            <param name="upperLeftX">This parameter represents the x coordinate of the center of the upper-leftmost pixel in map units.</param>
            <param name="upperLeftY">This parameter represents the y coordinate of the center of the upper-leftmost pixel in map units.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldFile.HorizontalResolution">
            <summary>This property gets the horizontal resolution from the world file.</summary>
            <value>This property gets the horizontal resolution from the world file.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldFile.RotationRow">
            <summary>This property gets the rotation in row from the world file.</summary>
            <value>This property gets the rotation in row from the world file.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldFile.RotationColumn">
            <summary>This property gets the rotation in column from the world file.</summary>
            <value>This property gets the rotation in column from the world file.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldFile.VerticalResolution">
            <summary>This property gets the vertical resolution from the world file.</summary>
            <value>This property gets the vertical resolution from the world file.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldFile.UpperLeftX">
            <summary>This property gets the upper left Y coordinate from the world file.</summary>
            <value>This property gets the upper left Y coordinate from the world file.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldFile.UpperLeftY">
            <summary>This property gets the upper left X coordinate from the world file.</summary>
            <value>This property gets the upper left X coordinate from the world file.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoLinearGradientDirection">
            <summary>
            Specifies the direction of a linear gradient.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoLinearGradientDirection.LeftToRight">
            <summary>
            Specifies the color should change in a horizontal direction from the left of the
            display to the right of the display.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoLinearGradientDirection.RightToLeft">
            <summary>
            Specifies the color should change in a horizontal direction from the right of the
            display to the left of the display.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoLinearGradientDirection.TopToBottom">
            <summary>
            Specifies the color should change in a horizontal direction from the top of the
            display to the bottom of the display.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoLinearGradientDirection.BottomToTop">
            <summary>
            Specifies the color should change in a horizontal direction from the bottom of the
            display to the top of the display.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoLinearGradientDirection.UpperLeftToLowerRight">
            <summary>
            Specifies the color should change in a horizontal direction from the upper left of
            the display to the lower right of the display.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoLinearGradientDirection.LowerRightToUpperLeft">
            <summary>
            Specifies the color should change in a horizontal direction from the lower right of
            the display to the upper leftof the display.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoLinearGradientDirection.LowerLeftToUpperRight">
            <summary>
            Specifies the color should change in a horizontal direction from the lower left of
            the display to the upper right of the display.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoLinearGradientDirection.UpperRightToLowerLeft">
            <summary>
            Specifies the color should change in a horizontal direction from the upper right of
            the display to the lower left of the display.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ContactAddress">
            <summary> 
            Information about a contact address for the service. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ContactAddress.AddressType">
            <summary> 
            Type of address. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ContactAddress.City">
            <summary> 
            Contact city.
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ContactAddress.Address">
            <summary> 
            Contact address.
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ContactAddress.StateOrProvince">
            <summary> 
            State or province of contact.
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ContactAddress.PostCode">
            <summary> 
            Postal (zip) code of contact.
            </summary> 
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.InMemoryBitmapTileCache">
            <summary>
            This class is a concrete class inherits from BitmapTileCache.
            In this class, the tiles will be saved in memory and it provides 
            some properties to control it very easily.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryBitmapTileCache.#ctor">
            <summary>
            This is the default constructor.
            </summary>
            <remarks>If you use this constructor, you have to set the properties manually.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryBitmapTileCache.GetTileCore(System.Int64,System.Int64)">
            <summary>
            This method returns the BitmapTile corresponding to passed in row and column. 
            </summary>
            <param name="row">The target row for the tile to fetch.</param>
            <param name="column">The target column for the tile to fetch.</param>
            <returns>Returns the BitmapTile corresponding to the passed in row and column.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryBitmapTileCache.SaveTileCore(ThinkGeo.MapSuite.Core.Tile)">
            <summary>
            This method will save the target tile passed in.
            </summary>
            <param name="tile">The target tile to be saved.</param>
            <remarks>This method will not take effect when the ReadOnly is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryBitmapTileCache.DeleteTileCore(ThinkGeo.MapSuite.Core.Tile)">
            <summary>
            This method will delete the target tile passed in.
            </summary>
            <param name="tile">The target tile to be deleted.</param>
            <remarks>This method will not take effect when the ReadOnly is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryBitmapTileCache.ClearCacheCore">
            <summary>
            This method will clear all the tiles in the tileCache.
            </summary>
            <remarks>This method will not take effect when the ReadOnly is set to true.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryBitmapTileCache.GetHigherScaleTileCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Double)">
            <summary>
            This method overrides the logic in its base class BitmapTileCache.
            This method will return the HigherScale BitmapTile which is always used for preview 
            effects when ZoomIn or ZoomOut.
            </summary>
            <param name="tileBoundingBox">The parameter specifies the current tile bounding box.</param>
            <param name="tileScale">This parameter specifies the current tile scale.</param>
            <returns>Returns the higher scale(higher zoomLevel) bitmap tile.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.InMemoryBitmapTileCache.MaximumTilesCount">
            <summary>
            This property gets or sets the maximum tiles count, if it exceed,it will delete the old first cached tiles.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.InMemoryBitmapTileCache.CachedTilesByScale">
            <summary>
            This property gets the Cached tiles,each item is a Dictionary with scale as its key.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MultipleFeatureSource">
            <summary>
            This <strong>MultipleFeatureSource</strong> is a special
            <strong>FeatureSource</strong> which holds a bunch of
            <strong>FeatureSource</strong>.
            </summary>
            <remarks>
            Almost all API apply to <strong>MultipleFeatureSource</strong> will apply to each
            <strong>FeautureSource</strong> individually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.#ctor">
            <summary>This is the default constructor for the MultipleFeatureSource class.</summary>
            <remarks>All this constructor, you can add FeautureSources to this MultipleFeatureSource by calling the property FeatureSources.</remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.FeatureSource})">
            <summary>
            This is a constructor for the class by passing a group of FeeatureSources.
            </summary>
            <param name="featureSources">The target FeatureSources will be included in this MultipleFeatureSource.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.GetColumnsCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the columns available for the FeatureSources within this MultipleFeatureSource.</summary>
            <returns>This method returns the columns available for the FeatureSources within this MultipleFeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.OpenCore">
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            This API will open all FeatureSource included in this MultipleFEatureSource.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.CloseCore">
            <summary>
            This method closes the FeatureSource and releases any resources it was
            using.
            </summary>
            <remarks>
            This API will close all FeatureSource included in this MultipleFEatureSource.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.GetCountCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <summary>
            This method returns the count of the number of records in this FeatureSource.
            </summary>
            <returns>
            This method returns the count of the number of records in this FeatureSource.
            </returns>
            <remarks>
            This returning features count stands for the total count in all FeatureSource included in this MultipleFeatureSource.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <summary>
            This method returns the bounding box which encompasses all of the FeatureSources in the
            MutlpleFeatureSource.
            </summary>
            <returns>
            This method returns the bounding box which encompasses all of the FeatureSources in the
            MutlpleFeatureSource.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.CommitTransactionCore(ThinkGeo.MapSuite.Core.TransactionBuffer)">
            <summary>
            This API is not supported in this concrete FeatureSource: MultipleFeatureSource.
            </summary>
            <returns>
            The return decimalDegreesValue of this method is a TransactionResult class which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful and any error that were encountered during the
            committing of the transaction.
            </returns>
            <param name="transactions">
            This parameter encapsulates all of the adds, edits and deleted that make up the
            transaction. You will use this data to write the changes to your underlying data
            source.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.GetAllFeaturesCore(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns all of the InternalFeatures in the MutipleFeatureSource.</summary>
            <returns>
            The return value is a collection of all of the InternalFeatures in the
            MutipleFeatureSource.
            </returns>
            <remarks>
            This returning collection of Features will include all the features counting all the FeatureSources in this 
            MultipleFeautureSource.
            </remarks>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.GetFeaturesInsideBoundingBoxCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this MultipleFeatureSource inside of the
            specified bounding box.
            </summary>
            <remarks>
            This returning collection of Features will include all the features insides all the FeatureSources in this 
            MultipleFeautureSource.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures inside of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.GetFeaturesByIdsCore(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns a collection of Features by providing a group of Ids.</summary>
            <returns>This method returns a collection of Features by providing a group of Ids.</returns>
            <remarks>
            This returning collection of Features will include all the features with the passed in Ids insides all the FeatureSources in this 
            MultipleFeautureSource.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids which uniquely identified the Features
            in the FeatureSource.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the ids we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.GetFeaturesForDrawingCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSources with the MultipleFeatureSource in this 
            MultipleFeautureSource. inside of the specified bounding box. 
            </remarks>
            <summary>This method returns the InternalFeatures that will be used for drawing.</summary>
            <returns>This method returns the InternalFeatures that will be used for drawing.</returns>
            <param name="boundingBox">This parameter is the bounding box of the InternalFeatures you want to draw.</param>
            <param name="screenWidth">
            This parameter is the width in screen pixels of the canvas you will draw
            on.
            </param>
            <param name="screenHeight">
            This parameter is the height in screen pixels of the canvas you will draw
            on.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.GetFeaturesNearestToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method will get a user defined number of Features that are closest to the
            TargetShape from all the FeatureSources within the MutlipleFeatureSource.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape from all the FeatureSources within the MutlipleFeatureSource.
            </returns>
            <param name="targetShape">This parameter is the shape you should to find close InternalFeatures to.</param>
            <param name="unitOfData">
            This parameter is the unit of what the TargetShape and the FeatureSource is in
            such as feet, meters etc.
            </param>
            <param name="numberOfItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfItemsToFind that is not greater than 0 it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.GetFeaturesOutsideBoundingBoxCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns all of the Features of this FeatureSource outside of the
            specified bounding box from all the FeatureSources within the MutlipleFeatureSource.
            </returns>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box from all the FeatureSources within the MutlipleFeatureSource.
            </summary>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box. If you are in a transaction and that transaction is live then
            it will also take that into consideration.<br/>
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.GetFeaturesWithinDistanceOfCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.This query will apply to all featureSource 
            within this MultipleFeatureSource.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape. It is important to note that the TargetShape and the FeatureSource
            use the same unit such as feet or meters. If they do not then the results will not be
            predictable or correct. If there is a current transaction and it is marked as live then
            the results will include any transaction Feature that applies.<br/>
            	<br/>
            The implementation we provided create a bounding box around the TargetShape using the
            distance supplied and then queries the features inside of it. This may not the most
            efficient method for this operation. If you underlying data provider exposes a more
            efficient way we recommend you override the Core version of this method and implement
            it.<br/>
            	<br/>
            The default implementation of GetFeaturesWithinDistanceOfCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient. We
            recommend when you override GetFeaturesInsideBoundingBoxCore method that you use any
            spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetShape">The shape you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the unit of the distance parameter such as feet, miles
            or kilometers etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureSource.SpatialQueryCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.QueryType,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <remarks>
            This method returns all of the InternalFeatures based on the target Feature and the
            spatial query type specified below. This spatial query will apply to all featureSource 
            within this MultipleFeatureSource.
            	<br/>
            	<strong>Spatial Query Types:</strong><br/>
            	<br/>
            	<strong>Disjoint</strong> - This method returns InternalFeatures where the specific Feature and
            the targetShape have no points in common.<br/>
            	<br/>
            	<strong>Intersects</strong> - This method returns InternalFeatures where the specific Feature
            and the targetShape have at least one point in common.<br/>
            	<br/>
            	<strong>Touches</strong> - This method returns InternalFeatures where the specific Feature and
            the targetShape have at least one boundary point in common, but no interior
            points.<br/>
            	<br/>
            	<strong>Crosses</strong> - This method returns InternalFeatures where the specific Feature and
            the targetShape share some but not all interior points.<br/>
            	<br/>
            	<strong>Within</strong> - This method returns InternalFeatures where the specific Feature lies
            within the interior of the targetShape.<br/>
            	<br/>
            	<strong>Contains</strong> - This method returns InternalFeatures where the specific Feature
            lies within the interior of the current shape.<br/>
            	<br/>
            	<strong>Overlaps</strong> - This method returns InternalFeatures where the specific Feature and
            the targetShape share some but not all points in common.<br/>
            	<br/>
            	<strong>TopologicalEqual</strong> - This method returns InternalFeatures where the specific
            Feature and the target Shape are topologically equal.<br/>
            	<br/>
            The default implementation of SpatialQueryCore uses the
            GetFeaturesInsideBoundingBoxCore method to pre-filter the spatial query. We strongly
            recommend that you provide your own implementation for this method that will be more
            efficient. We recommend when you override that method that you use any spatial indexes
            you have at your disposal to make this method as fast as possible.
            </remarks>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and the
            spatial query type specified.
            </summary>
            <returns>
            The return value is a collection of Features that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="queryType">This parameter specifies what kind of spatial query you wish to perform.</param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a queryType that is not defined in the enumeration it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid we will throw an ArgumentException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultipleFeatureSource.FeatureSources">
            <summary>
            This property specify the FeatureSource collection within the MultipleFeatureSource.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultipleFeatureSource.IsEditable">
            <summary>This property returns if the FeatureSource allows edits or is read only.</summary>
            <decimalDegreesValue>
            This property returns if the FeatureSource allows edits or is read only. The
            property returns true if the FeatureSource allows edits and false if the FeatureSource
            is read only.
            </decimalDegreesValue>
            <remarks>
            	<para>This property is useful to check if a specific FeatureSource accepts editing.
                If you call the BeginTransaction and this property is false then an exception will
                be raised.<br/>
            		<br/>
                For developers who are creating or extending a FeatureSource it is expected that
                you override this virtual method if the new FeatureSource you are creating allows
                edits. By default the decimalDegreesValue if false meaning that if you want to allow edits you
                must override this method and return true.</para>
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoTiffRasterSource">
            <summary>
            This class allows you to view TIFF image types.
            </summary>
            <remarks>
            This class handles TIFF image types. You will need to ensure that the image file
            is always accompanied by a world file. The world file is text file that store the
            associated geographic information we need to properly display the image along with your
            other feature data.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTiffRasterSource.#ctor">
            <summary>This is the constructor the for the class. If you use this constructor then you need to set
            the required properties manually.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTiffRasterSource.#ctor(System.String)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <remarks>
            This is typically the constructor you want to use for this class. It allows you
            to pass in the TIFF file you wish to work with. Note that the TIFF file is not accessed
            or opened until you call the open command of the class.
            </remarks>
            <param name="imagePathFilename">
            This parameter represents the path and file name of the TIFF file you want to load
            into the class for display.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTiffRasterSource.#ctor(System.String,System.String)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <remarks>
            This is typically the constructor you want to use for this class. It allows you
            to pass in the TIFF file you wish to work with and world file belongs to it. Note that the TIFF file is not accessed
            or opened until you call the open command of the class.
            </remarks>
            <param name="imagePathFilename">
            This parameter represents the path and file name of the TIFF file you want to load
            into the class for display.
            </param>
            <param name="worldfilePathFilename">
            This parameter represents the path and file name of the world file you want to load
            into the class for display.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTiffRasterSource.#ctor(System.String,ThinkGeo.MapSuite.Core.RectangleShape)">
            <overloads>This is the commonly used constructor for the class.</overloads>
            <summary>This is the constructor for the class.</summary>
            <returns>None</returns>
            <remarks>
            This is typically the constructor you want to use for this class. It allows you
            to pass in the TIFF file you wish to work with and image extent belongs to it. Note that the TIFF file is not accessed
            or opened until you call the open command of the class.
            </remarks>
            <param name="imagePathFilename">
            This parameter represents the path and file name of the TIFF file you want to load
            into the class for display.
            </param>
            <param name="imageExtent">
            This parameter represents the extent of the world file you want to load
            into the class for display.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTiffRasterSource.GetImageWidthCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the width of the image in screen coordinates.</summary>
            <returns>This method returns the width of the image in screen coordinates.</returns>
            <remarks>This virtual method is called from the concreate method GetImageWidth.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTiffRasterSource.GetImageHeightCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the height of the image in screen coordinates.</summary>
            <returns>This method returns the height of the image in screen coordinates.</returns>
            <remarks>This virtual method is called from the concreate method GetImageHeight.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTiffRasterSource.OpenCore">
            <summary>
            This method opens the TIFFSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concreate public method Open.
            The open method play an important role as it is responsible for initializing the
            RasterSource. Most methods on the RasterSource will throw an exception if the state of
            the RasterSource is not opened. When the map draws each layer it will open the
            RasterSource as one of its first steps, then after it is finished drawing with that
            layer it will close it. In this way we are sure to release all resources used by the
            RasterSource.<br/>
            	<br/>
            When implementing this virtual method consider opening files for file based source,
            connecting to databases in the database based sources and so on. You will get a chance
            to close these in the Close method of the ImageSource.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a raster source which has already been opened it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTiffRasterSource.CloseCore">
            <summary>
            This method opens the RasterSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concreate public method Close.
            The close method plays an important role in the life cycle of the RasterSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            It is recommended that if you override this method that you take the following things
            into account. This method may be called multiple times so we suggest you write the so
            that that a call to a closed FeatureSource is ignored and does not generate an error.
            We also suggest that in the close you free all resources that have been opened.
            Remember that the object will not be destroyed but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTiffRasterSource.GetImageCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass in a worldExtent which is invalid we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a worldExtent which is invalid we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image width which is smaller than or equal to 0 we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image height which is smaller than or equal to 0 we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened it will throw an InvalidOperationException.</exception>
            <remarks>
            This method is responsible for returning the image based on the parameters passed
            in. As the core version of this method is abstract you will need to override it when
            creating our own RasterSource.
            </remarks>
            <summary>
            This method returns an image based on the worldExtent and image width and
            height.
            </summary>
            <returns>
            This method returns an image based on the worldExtent and image width and
            height.
            </returns>
            <param name="worldExtent">This parameter represents the worldExtent you want to draw.</param>
            <param name="canvasWidth">This parameter represents the width of the image you want to draw.</param>
            <param name="canvasHeight">This parameter represents the height of the image you want to draw.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoTiffRasterSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the RasterSource.</summary>
            <returns>This method returns the bounding box of the RasterSource.</returns>
            <remarks>This method returns the bounding box of the RasterSource.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoTiffRasterSource.PathFilename">
            <summary>
            This property gets and sets the path and filename of the TIFF file you want to
            use.
            </summary>
            <value>
            This property gets and sets the path and filename of the TIFF file you want to
            use.
            </value>
            <remarks>None.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PjDatums">
            <summary>
            definition of class PjDatums
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.OpenDbfFile(System.String,System.IO.FileAccess)">
            <summary>
            Open the DBF file
            </summary>
            <param name="fileName">the file name</param>
            <param name="access">the access mode</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.CreateDBFFile(System.String,System.IO.FileAccess)">
            <summary>
            Create a DBF File
            </summary>
            <param name="FileName">the name of the new dbf file</param>
            <param name="access">the access mode</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GenerateDBTFile">
            <summary>
            Generate DBT file if memo fields exist in dbf
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.InitFileHeaderInfo(System.Byte[],ThinkGeo.MapSuite.Core.GeoDbf)">
            <summary>
            Initialize the File Header Info by the first 32 bytes data
            </summary>
            <param name="arrFileHeader">the first 32 bytes data</param>
            <param name="dbfFile">The dbfFile to be initialized</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.InitFieldsHeaderInfo(System.Byte[],ThinkGeo.MapSuite.Core.GeoDbf)">
            <summary>
            Initialize the Fields Header Info by the header data
            </summary>
            <param name="arrHeader">the file header data</param>
            <param name="dbfFile">The DBF File to be initialized</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.ReadNativeAttribute(System.Int32,System.Int32)">
            <summary>
            Get the Native attribute in string
            </summary>
            <param name="iRecord">the Record Index</param>
            <param name="iField">the Field Index</param>
            <returns>the corresponding attribute in string</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetValidSubString(System.Byte[])">
            <summary>
            Get Valid Length of the Input Bytes, Remove the End '\0'
            </summary>
            <param name="bytesIn">the input byte array</param>
            <returns>the Valid Sub String</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetValidSubString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get Valid Length of the Input Bytes, Remove the End '\0'
            </summary>
            <param name="bytesIn">the input byte array</param>
            <param name="length">the length of the bytes to be converted</param>
            <param name="nIndex">the start index of the bytes to be converted</param>
            <returns>the Valid Sub String</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.ReadNativeAttributeInBytes(System.Int32,System.Int32)">
            <summary>
            Get the Native attribute in string
            </summary>
            <param name="iRecord">the Record Index</param>
            <param name="iField">the Field Index</param>
            <returns>the corresponding attribute in bytes</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.ReadNativeAttributeInBytes_UnEncrypted(System.Int32,System.Int32)">
            <summary>
            Get the Native attribute in string, For UnEncrypted File
            </summary>
            <param name="iRecord">the Record Index</param>
            <param name="iField">the Field Index</param>
            <returns>the corresponding attribute in bytes</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.ReadNativeAttributesInBytes(System.Int32)">
            <summary>
            Get the Native attribute in byte[]
            </summary>
            <param name="iRecord">the Record Index</param>
            <returns>the corresponding attribute in bytep[]</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.ReadNativeAttributes_UnEncrypted(System.Int32)">
            <summary>
            Get the Native attribute in byte[], for UnEncrypted file
            </summary>
            <param name="iRecord">the Record Index</param>
            <returns>the corresponding attribute in bytep[]</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.ReadDBTRecord(System.Int32)">
            <summary>
            Get the Record in DBT file accoring to the block index
            </summary>
            <param name="iBlock">the block index</param>
            <returns>the record in string</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.ReadDBTRecord_UnEncrypted(System.Int32)">
            <summary>
            Get the Record in DBT file accoring to the block index
            </summary>
            <param name="iBlock">the block index</param>
            <returns>the record in string</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.FlushCurrentRecord">
            <summary>
            Flush the Current Record to disk
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.AddBlank(System.Byte[]@,System.Int32,System.Int32,System.Int32,System.Byte)">
            <summary>
            Add Blank Bytes to a bytes array
            </summary>
            <param name="arrUpdateBytes">the bytes array to Write</param>
            <param name="nOffset">the start Pos of the valid SubArray</param>
            <param name="nWrittenBytes">the written bytes in the Valid SubArray</param>
            <param name="nSize">the size of the Valid SubArray</param>
            <param name="byteBlank">the content for blank</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.Write2CurrentRecord(System.Int32,System.Object)">
            <summary>
            Write an object to Current Record
            </summary>
            <param name="iField">the field the object belong to, Start With 0</param>
            <param name="objValue">the object to be added to</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.Write2DBT(System.Object,System.Int32)">
            <summary>
            Write the Value to DBT file
            </summary>
            <param name="Value">the Value to write</param>
            <param name="nOriginalBlock">the number of the Original Block</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.Switch2RightRecord(System.Int32)">
            <summary>
            Switch CurrentRecord to the input Record
            </summary>
            <param name="iRecord">the Index of the Record, which will be the Current Record</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.WriteHeader(System.Boolean)">
            <summary>
            Write out the header and field descriptions before writing any
            actral data records.
            </summary>
            <param name="bHaveMemoField">the HaveMemoField remark</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.UpdateHeader">
            <summary>
            Update the Header 
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.UpdateFields">
            <summary>
            Update the Fields
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetDBTFile(System.String)">
            <summary>
            Get the corresponding dbt file
            </summary>
            <param name="dbf">the dbf file</param>
            <returns>the corresponding dbt file</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.MoveDBFAfterFieldOperation(System.String,System.String)">
            <summary>
            Move DBF/DBT files after the Field operations
            </summary>
            <param name="strSrcDBF">the source dbf, which is a tmp file during the operation
            </param>
            <param name="strDestDBF">the dest dbf, which is the original file</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetTmpDBFFile">
            <summary>
            Get tmp DBF File
            </summary>
            <returns>The tmp DBF File</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.AddField2ExistedFile(System.String,ThinkGeo.MapSuite.Core.DbfColumnType,System.Int32,System.Int32)">
            <summary>
            Add a new Field to this existed dbf file 
            </summary>
            <param name="FieldName">The new Field's Name</param>
            <param name="type">The new Field's Type</param>
            <param name="nDecimals">The new Field's Width</param>
            <param name="nWidth">The new Fields's Decimal Count</param>
            <returns>the new Field Index</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.AddField2BlankFile(System.String,ThinkGeo.MapSuite.Core.DbfColumnType,System.Int32,System.Int32)">
            <summary>
            Add a new Field to this blank dbf file 
            </summary>
            <param name="FieldName">The new Field's Name</param>
            <param name="type">The new Field's Type</param>
            <param name="nDecimals">The new Field's Width</param>
            <param name="nWidth">The new Fields's Decimal Count</param>
            <returns>the new Field Index</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.PackDBFFile(System.Collections.ArrayList)">
            <summary>
            Delete all the "Deleted" records , and Open the new Stream
            </summary>
            <param name="DeletedArray">The deleted Array, which is useful during pack
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.PackDBTFile(System.Collections.ArrayList,System.Collections.ArrayList)">
            <summary>
            Pack the DBT File
            </summary>
            <param name="DeletedArray"> the index of every deleted elements</param>
            <param name="MemoFields">the index of every memo fields</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.PackData_DBF(System.IO.Stream@,System.Collections.ArrayList)">
            <summary>
            Pack the Data for DBF file
            </summary>
            <param name="fsDest"> The Destination FileStream</param>
            <param name="DeletedArray">The Deleted Array</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.PackData_DBT(System.IO.Stream@,System.Collections.ArrayList)">
            <summary>
            Pack the Data for DBT file
            </summary>
            <param name="fsDest"> The Destination FileStream</param>
            <param name="DeletedBlocks">The Memo Array</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.UpdateMemoRecord(System.Collections.ArrayList)">
            <summary>
            Update the MemoRecord pointer in DBF after DBT file was flushed
            </summary>
            <param name="memoFields">the memo Fields index Array</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.CopyData_DBF(System.IO.Stream,System.Int32,System.Int32,System.IO.Stream@,System.Int32)">
            <summary>
            Move the data between iStart and iEnd, to the stream start with iWriteTo, for DBF
            </summary>
            <param name="fsSrc">The Original filestream</param>
            <param name="iStart">Start Record Index in _fsFile</param>
            <param name="iEnd">End Record Index in _fsFile</param>
            <param name="fsDest">The Destination filestream</param>
            <param name="iWriteTo">the begin Index to be written in fsDest</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.CopyData_DBT(System.IO.Stream,System.Int32,System.Int32,System.IO.Stream@,System.Int32)">
            <summary>
            Move the data between iStart and iEnd, to the stream start with iWriteTo, for DBT
            </summary>
            <param name="fsSrc">The Original filestream</param>
            <param name="iStart">Start Record Index in _fsFile</param>
            <param name="iEnd">End Record Index in _fsFile</param>
            <param name="fsDest">The Destination filestream</param>
            <param name="iWriteTo">the Record Index to be written in fsDest</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.UpdateDBTHeader(System.IO.Stream,System.Int32)">
            <summary>
            Update the DBT Header 
            </summary>
            <param name="fsDBT">the DBT File</param>
            <param name="nDeletedBlocks">the Deleted Blocks</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetNewValue(System.Int32)">
            <summary>
            Get the new Value according to the original decimalDegreesValue
            </summary>
            <param name="OriginalValue">the original decimalDegreesValue</param>
            <returns>the new decimalDegreesValue</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.MakeContrastArrays(System.Collections.ArrayList@,System.Collections.ArrayList@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Make the 2 Contrast Arrays, used for updating the memo fields in new dbf 
            </summary>
            <param name="arrOriginal">the original block index arraylist</param>
            <param name="arrNew">the new block index arraylist</param>
            <param name="iOriginalStart">Start index for a copy</param>
            <param name="iOriginalEnd">End index for a copy</param>
            <param name="iNewStart">WriteTo index for a copy</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetDeletedBlocks(System.Collections.ArrayList,System.Collections.ArrayList)">
            <summary>
            Get the Deleted Blocks Array
            </summary>
            <param name="DeletedArray">the index of every deleted elements</param>
            <param name="MemoFields">the index of every memo fields</param>
            <returns>the Deleted Blocks Array</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GenDeletedIndexArray">
            <summary>
            Get the Deleted ArrayList
            </summary>
            <remarks>Read MAX_RECORDS_ONCE_READ Records each time to balance mem and efficiency </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.UpdateDeletedArray">
            <summary>
            Update the Deleted Array, make mark
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetBlockCount(System.Int32,System.Int32)">
            <summary>
            Get the Block Count transferred
            </summary>
            <param name="iStart">the start index</param>
            <param name="iEnd">the end index</param>
            <returns>the block count between them</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetBlockSizeOfRecord(System.IO.Stream,System.Int32)">
            <summary>
            Get the Record Length starts at a Block
            </summary>
            <param name="fsDBT">the DBT filestream</param>
            <param name="iBlock">the block index</param>
            <returns>the Record Length</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetHeaderBytes">
            <summary>
            Get Header in Bytes
            </summary>
            <returns>The Header in Bytes</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.FieldsAreValid(System.Collections.ArrayList)">
            <summary>
            Get whether the fields are valid
            </summary>
            <param name="Fields">the fields info</param>
            <returns>whether the fields are valid</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.CheckEncryptFlag(System.Byte)">
            <summary>
            Check the Encrypted Flag
            </summary>
            <param name="Flag">the Encrypted Flag</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.CheckOpening(System.String)">
            <summary>
            Check whether the File is in Create Mode
            </summary>
            <param name="ErrorMsg">the ErrorMsg to be thrown in Create Mode</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetNewField(ThinkGeo.MapSuite.Core.DbfColumnType,System.Int32,System.Int32)">
            <summary>
            Get Field info according to the input
            </summary>
            <param name="nDecimals">The Field Decimal Count</param>
            <param name="nWidth">The Field Width</param>
            <param name="type">The Field Type</param>
            <returns>The Field Information packed in the DbfFieldInfo struct</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetNewHeaderArray(System.String,ThinkGeo.MapSuite.Core.DbfColumnInfo)">
            <summary>
            Get the new Header Array according to the new Field infomation 
            </summary>
            <param name="Field">the new Field info</param>
            <param name="FieldName">the new Field Name</param>
            <returns>the new Header Array</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetStrByObj(System.Int32,ThinkGeo.MapSuite.Core.DbfColumnType,System.Object)">
            <summary>
            Get the string from the input object and type
            </summary>
            <param name="iField">get the decimal size from iField </param>
            <param name="objValue">The Value of an attribute boxed in object</param>
            <param name="type">the type of the field</param>
            <returns>the string format of the input Value according to the field type</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetDoubleStrByObj(System.Object,System.Int32)">
            <summary>
            Get Double string according to the input object and Decimal Size
            </summary>
            <param name="objValue">the Value boxed in Object</param>
            <param name="nDecimalSize">the decimal Size</param>
            <returns>the Double String</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetInputErrorMsg(System.String,ThinkGeo.MapSuite.Core.DbfColumnType,System.Int32,System.Int32)">
            <summary>
            Get Input Error Message according the input
            </summary>
            <param name="FieldName">the Field Name</param>
            <param name="type">The Field type</param>
            <param name="nWidth">The Width of the Field</param>
            <param name="nDecimals">The Decimal Count of the Field</param>
            <returns>The Error Message of the Input</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.ConvertStr2Int32(System.String)">
            <summary>
            Simulate the atoi function in c++
            </summary>
            <param name="strNum">the Num string </param>
            <returns>the Converted int number</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.ConvertStr2Int32Str(System.String)">
            <summary>
            Simulate the atoi function in c++
            </summary>
            <param name="strNum">the Num string </param>
            <returns>the Converted string according with the format of int</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.WriteInt2Bytes(System.Byte[]@,System.Int32,System.Int32)">
            <summary>
            Write an Int Value to Bytes Array
            </summary>
            <param name="bytes">the bytes Array to be written</param>
            <param name="iStart">the start index in bytes when Writing</param>
            <param name="intValue">the intValue to write</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.ReadIntFromBytes(System.Byte[],System.Int32)">
            <summary>
            Read the Int Value from Bytes Array
            </summary>
            <param name="bytes">the bytes array to read</param>
            <param name="iStart">the start index in bytes when reading</param>
            <returns>the int decimalDegreesValue read from the bytes</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.GetTime(System.Byte[]@)">
            <summary>
            Get the Time Record in File Header
            </summary>
            <param name="FileHeader">the Header bytes</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.CopyHeaderData_DBF(ThinkGeo.MapSuite.Core.GeoDbf,System.IO.Stream@)">
            <summary>
            Copy the Header bytes in dbfFile to fsDest
            </summary>
            <param name="dbfFile">The Source DBaseFile</param>
            <param name="fsDest">The Destination FileStream</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoDbf.CopyHeaderData_DBT(System.IO.Stream,System.IO.Stream@)">
            <summary>
            Copy the Header bytes in dbtFile to fsDest
            </summary>
            <param name="dbtFile">The Source FileStream</param>
            <param name="fsDest">The Destination FileStream</param>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeoDbf._bFileDetached">
            <summary>
            Whether the filestream has been detached
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PointStyleAdvanced">
            <summary>This class represents the advanced drawing options for point styles.</summary>
            <remarks>
            This class allows you to set the CustomBrush. This enables you to use custom
            brushes to achieve effects such as linear gradients and bitmap fills.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyleAdvanced.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyleAdvanced.CustomBrush">
            <summary>This property allows you to get and set a custom brush.</summary>
            <value>This property returns a custom brush.</value>
            <remarks>
            This allows you to use custom brushes to achieve effects such as linear gradients and
            bitmap fills. If you use any brush besides the SolidBrush, you would set it in this
            property.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PenBrushDrawingOrder">
            <summary>This enumeration determines whether the brush or the pen draws first.</summary>
            <remarks>
            This controls if the outline pen or the fill brush will draw first. The
            difference in drawing is subtle, but noticeable. If you draw the outline first and then the brush, the
            brush fill will slightly bleed into the outline and make the outline appear thinner.  If you draw
            the brush first, then the pen will display its normal outline width.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PenBrushDrawingOrder.BrushFirst">
            <summary>The fill brush will draw first.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.PenBrushDrawingOrder.PenFirst">
            <summary>The outline pen will draw first.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.QueryTools">
            <summary>This is a helper class that allows you to execute various queries.</summary>
            <remarks>
            This is a helper class that allows you to execute various queries. It wraps
            the query functionality of the FeatureSource and provides a simpler and more focused
            set of APIs.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor, though it is typically not intended to be
            used.
            </overloads>
            <remarks>
            This is the default constructor, though it is typically not intended to be
            used.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.#ctor(ThinkGeo.MapSuite.Core.FeatureSource)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a FeatureSouce that will provide the
            functionality for this class's methods.
            </overloads>
            <remarks>
            Each of the calls in this class thunk through to the FeatureSource passed
            in.
            </remarks>
            <returns>None</returns>
            <param name="featureSource">
            This parameter is the FeatureSource that will provide the functionality for this
            class's methods.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesByColumnValue(System.String,System.String,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
            <param name="returningColumnType">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesByColumnValue(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
            <param name="returningColumnNames">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesByColumnValue(System.String,System.String)">
            <summary>Get all of the features by passing a columnName and a specified columValue.</summary>
            <returns>The returnning features matches the columnValue.</returns>
            <param name="columnName">The specified columnName to match the columnValue.</param>
            <param name="columnValue">The specified columnValue to match those returning features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesContaining(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that contain the target shape.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that contain the TargetShape you passed in.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that contain the specified target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <overloads>This method returns all of the features that contain the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesContaining(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and
            the spatial query type specified.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that contain the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            	<para><strong>ReturningColumnsType:</strong></para>
            	<para><br/>
            		<strong>NoColumns</strong> - This method ensures that the returning features contain no
                column values.<br/>
            		<br/>
            		<strong>AllColumns</strong> - This method ensures that the returning features contain all
                column values.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that contain the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesContaining(ThinkGeo.MapSuite.Core.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and
            the spatial query type specified.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures that contain the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>ReturningColumnsType:</strong></para>
            	<para><br/>
            		<strong>NoColumns</strong> - This method ensures that the returning features contain no
                column values.<br/>
            		<br/>
            		<strong>AllColumns</strong> - This method ensures that the returning features contain all
                column values.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that contain the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesContaining(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures based on the target Feature and
            the spatial query type specified.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetFeature.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures that contain the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>ReturningColumnsType:</strong></para>
            	<para><br/>
            		<strong>NoColumns</strong> - This method ensures that the returning features contain no
                column values.<br/>
            		<br/>
            		<strong>AllColumns</strong> - This method ensures that the returning features contain all
                column values.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that contain the target feature.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesCrossing(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that cross the target shape.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that cross the TargetShape you passed in.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that cross the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<strong>Crossing</strong> - The Geometries share some but not all interior points, and the 
                dimension of the intersection is less than that of at least one of the Geometries.<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <overloads>This method returns all of the features that cross the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesCrossing(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that cross the target shape.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures that cross the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>ReturningColumnsType:</strong></para>
            	<para><br/>
            		<strong>NoColumns</strong> - This method ensures that the returning features contain no
                column values.<br/>
            		<br/>
            		<strong>AllColumns</strong> - This method ensures that the returning features contain all
                column values.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features which crosses the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesCrossing(ThinkGeo.MapSuite.Core.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that cross the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the Internalfeatures that cross the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>ReturningColumnsType:</strong></para>
            	<para><br/>
            		<strong>NoColumns</strong> - This method ensures that the returning features contain no
                column values.<br/>
            		<br/>
            		<strong>AllColumns</strong> - This method ensures that the returning features contain all
                column values.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that cross the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesCrossing(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that cross the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the Internalfeatures that cross the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>ReturningColumnsType:</strong></para>
            	<para><br/>
            		<strong>NoColumns</strong> - This method ensures that the returning features contain no
                column values.<br/>
            		<br/>
            		<strong>AllColumns</strong> - This method ensures that the returning features contain all
                column values.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that cross the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesDisjointed(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that disjoint the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that disjoint the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Disjoint</strong> - The Geometries have no point in common.<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <overloads>This method returns all of the features that cross the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesDisjointed(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that disjoint the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures that disjoint the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Disjoint</strong> - The Geometries have no point in common.</para>
            	<para></para>
            	<para><strong>ReturningColumnsType:</strong></para>
            	<para><br/>
            		<strong>NoColumns</strong> - This method ensures that the returning features contain no
                column values.<br/>
            		<br/>
            		<strong>AllColumns</strong> - This method ensures that the returning features contain all
                column values.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that disjoint the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesDisjointed(ThinkGeo.MapSuite.Core.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that disjoint the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	<para>This method returns all of the InternalFeatures that disjoint the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Disjoint</strong> - The Geometries have no point in common.</para>
            	<para></para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that disjoint the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesDisjointed(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that disjoint the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that disjoint the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Disjoint</strong> - The Geometries have no point in common.<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that disjoint the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the columns contained in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesIntersecting(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that intersect the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that intersect the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Intersecting</strong> - The Geometries have at least one point in common (the inverse of Disjoint).<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <overloads>This method returns all of the features that intersect the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesIntersecting(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that intersect the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that intersect the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Intersecting</strong> - The Geometries have at least one point in common (the inverse of Disjoint).<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that intersect the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesIntersecting(ThinkGeo.MapSuite.Core.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that intersect the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that intersect the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Intersecting</strong> - The Geometries have at least one point in common (the inverse of Disjoint).<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that intersect the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesIntersecting(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that intersect the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that intersect the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Intersecting</strong> - The Geometries have at least one point in common (the inverse of Disjoint).<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that intersect the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesOverlapping(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that overlap the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that overlap the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Overlapping</strong> - The Geometries share some but not all points in common, and the intersection has the same dimension as the Geometries themselves.<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <overloads>This method returns all of the features that overlap the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesOverlapping(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that overlap the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that overlap the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Overlapping</strong> - The Geometries share some but not all points in common, and the intersection has the same dimension as the Geometries themselves.<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that overlap the target shape.</overloads>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesOverlapping(ThinkGeo.MapSuite.Core.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that overlap the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that overlap the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Overlapping</strong> - The Geometries share some but not all points in common, and the intersection has the same dimension as the Geometries themselves.<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <overloads>This method returns all of the features that overlap the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesOverlapping(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures that overlap the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that overlap the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.<br/>
            		<br/>
            		<strong>Overlapping</strong> - The Geometries share some but not all points in common, and the intersection has the same dimension as the Geometries themselves.<br/>
            		<br/>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <overloads>This method returns all of the features that overlap the target shape.</overloads>
            <param name="targetFeature">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesTopologicalEqual(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that topologicalEqual the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that topologicalEqual the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that topologicalEqual the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesTopologicalEqual(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that topologicalEqual the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that topologicalEqual the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that topologicalEqual the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesTopologicalEqual(ThinkGeo.MapSuite.Core.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that topologicalEqual the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that topologicalEqual the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that topologicalEqual the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesTopologicalEqual(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that topologicalEqual the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that topologicalEqual the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that topologicalEqual the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="targetFeature">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesTouching(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that touch the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that touch the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that touch the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesTouching(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that touch the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that touch the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that touch the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesTouching(ThinkGeo.MapSuite.Core.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that touch the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that touch the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that touch the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesTouching(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that touch the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that touch the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that touch the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesWithin(ThinkGeo.MapSuite.Core.BaseShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are within the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are within the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are within the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesWithin(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are within the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are within the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are within the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="targetShape">This parameter specifies the target shape used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesWithin(ThinkGeo.MapSuite.Core.Feature,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are within the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are within the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are within the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesWithin(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are within the target shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are within the target Feature.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that match the spatial query you
            executed based on the TargetShape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are within the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="targetFeature">This parameter specifies the target feature used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesOutsideBoundingBox(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are outside of the target rectangle shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are outside of the boundingBox.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that are outside of the target rectangle shape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are outside of the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="boundingBox">This parameter specifies the target boundingBox used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesOutsideBoundingBox(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are outside of the target rectangle shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are outside of the boundingBox.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that are outside of the target rectangle shape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are outside of the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="boundingBox">This parameter specifies the target boundingBox used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesInsideBoundingBox(ThinkGeo.MapSuite.Core.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are inside of the target rectangle shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are inside of the boundingBox.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that are inside of the target rectangle shape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are inside of the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <param name="boundingBox">This parameter specifies the target boundingBox used in the spatial query.</param>
            <param name="returningColumnNames">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesInsideBoundingBox(ThinkGeo.MapSuite.Core.RectangleShape,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <overloads>This method returns all of the features that are inside of the target rectangle shape.</overloads>
            <summary>
            This method returns all of the InternalFeatures that are inside of the boundingBox.
            </summary>
            <returns>
            The return value is a collection of InternalFeatures that are inside of the target rectangle shape.
            </returns>
            <remarks>
            	This method returns all of the InternalFeatures that are inside of the target
                shape. If there is a current transaction and it is marked as live, then the results
                will include any transaction Feature that applies.
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ReturningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="boundingBox">This parameter specifies the target boundingBox used in the spatial query.</param>
            <param name="returningColumnNamesType">This parameter specifies the column values in the return features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesNearestTo(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource
                must use the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live, then
                the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided create a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetShape">This parameter is the shape you want to find close InternalFeatures to.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="numberOfItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfItemsToFind that is not greater than 0, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesNearestTo(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,System.Int32,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            	This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource
                must use the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live, then
                the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided create a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetShape">This parameter is the shape you want to find close InternalFeatures to.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="numberOfItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNamesType">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningColumnsType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfItemsToFind that is not greater than 0, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesNearestTo(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetFeature.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetFeature.
            </returns>
            <remarks>
            	This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource
                must use the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live, then
                the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided create a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetFeature">This parameter is the feature you want to find close InternalFeatures to.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="numberOfItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            feature.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfItemsToFind that is not greater than 0, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesNearestTo(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeographyUnit,System.Int32,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetFeature.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetFeature.
            </returns>
            <remarks>
            	This method returns a user defined number of InternalFeatures that are closest to the
                TargetShape. It is important to note that the TargetShape and the FeatureSource
                must use the same unit, such as feet or meters. If they do not, then the results will not be
                predictable or correct. If there is a current transaction and it is marked as live, then
                the results will include any transaction Feature that applies.<br/>
            		<br/>
                The implementation we provided create a small bounding box around the TargetShape
                and then queries the features inside of it. If we reach the number of items to find,
                then we measure the returned InternalFeatures to find the nearest. If we do not find enough
                records, we scale up the bounding box and try again. As you can see, this is not the
                most efficient method. If your underlying data provider exposes a more efficient way,
                we recommend you override the Core version of this method and implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesNearestCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetFeature">This parameter is the feature you want to find close InternalFeatures to.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the TargetShape and the FeatureSource are in,
            such as feet, meters, etc.
            </param>
            <param name="numberOfItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            feature.
            </param>
            <param name="returningColumnNamesType">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a numberOfItemsToFind that is not greater than 0, it will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            	This method returns a collection of InternalFeatures that are within a certain
                distance of the TargetShape. It is important to note that the TargetShape and the
                FeatureSource must use the same unit, such as feet or meters. If they do not, then the
                results will not be predictable or correct. If there is a current transaction and
                it is marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
                The implementation we provided creates a bounding box around the TargetShape using
                the distance supplied and then queries the features inside of it. This may not be the
                most efficient method for this operation. If your underlying data provider exposes a
                more efficient way, we recommend you override the Core version of this method and
                implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesWithinDistanceOfCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetShape">The shape you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the unit of the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit,System.Double,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            	This method returns a collection of InternalFeatures that are within a certain
                distance of the TargetShape. It is important to note that the TargetShape and the
                FeatureSource must use the same unit, such as feet or meters. If they do not, then the
                results will not be predictable or correct. If there is a current transaction and
                it is marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
                The implementation we provided creates a bounding box around the TargetShape using
                the distance supplied and then queries the features inside of it. This may not be the
                most efficient method for this operation. If your underlying data provider exposes a
                more efficient way, we recommend you override the Core version of this method and
                implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesWithinDistanceOfCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetShape">The shape you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the unit of the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNamesType">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentOutOfRangeException">If you pass a null as the returningColumnNamesType, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetFeature.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetFeature.
            </returns>
            <remarks>
            	This method returns a collection of InternalFeatures that are within a certain
                distance of the TargetShape. It is important to note that the TargetShape and the
                FeatureSource must use the same unit, such as feet or meters. If they do not, then the
                results will not be predictable or correct. If there is a current transaction and
                it is marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
                The implementation we provided creates a bounding box around the TargetShape using
                the distance supplied and then queries the features inside of it. This may not be the
                most efficient method for this operation. If your underlying data provider exposes a
                more efficient way, we recommend you override the Core version of this method and
                implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesWithinDistanceOfCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetFeature">The feature you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the unit of the distance parameter, such as feet, miles,
            kilometers, etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesWithinDistanceOf(ThinkGeo.MapSuite.Core.Feature,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit,System.Double,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetFeature.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetFeature.
            </returns>
            <remarks>
            	This method returns a collection of InternalFeatures that are within a certain
                distance of the TargetShape. It is important to note that the TargetShape and the
                FeatureSource must use the same unit, such as feet or meters. If they do not, then the
                results will not be predictable or correct. If there is a current transaction and
                it is marked as live, then the results will include any transaction Feature that
                applies.<br/>
            		<br/>
                The implementation we provided creates a bounding box around the TargetShape using
                the distance supplied and then queries the features inside of it. This may not be the
                most efficient method for this operation. If your underlying data provider exposes a
                more efficient way, we recommend you override the Core version of this method and
                implement it.<br/>
            		<br/>
                The default implementation of GetFeaturesWithinDistanceOfCore uses the
                GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
                provide your own implementation for this method that will be more efficient. When you
                override the GetFeaturesInsideBoundingBoxCore method, we recommend that you use
                any spatial indexes you have at your disposal to make this method as fast as
                possible.<br/>
            		<br/>
            		<br/>
                As this is a concrete public method that wraps a Core method, we reserve the right
                to add events and other logic to pre- or post-process data returned by the Core version
                of the method. In this way, we leave our framework open on our end, but also allow you
                the developer to extend our logic to suit your needs. If you have questions about this,
                please contact our support team as we would be happy to work with you on extending our
                framework.
            </remarks>
            <param name="targetFeature">The feature you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the unit of the distance parameter, such as feet, miles,
            kilometers, etc..
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNamesType">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentNullException" caption="ArgumentOutOfRangeException">If you pass a null as the returningColumnNamesType, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape that is invalid, we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeatureById(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method returns an InternalFeature based on an Id provided.</summary>
            <returns>This method returns an InternalFeature based on an Id provided.</returns>
            <remarks>This method returns an InternalFeature based on an Id provided.</remarks>
            <param name="id">This parameter is the unique Id for the feature you want to find.</param>
            <param name="returningColumnNames">
            This parameter is a list of column names you want returned with the
            Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeatureById(System.String,ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns an InternalFeature based on an Id provided.</summary>
            <returns>This method returns an InternalFeature based on an Id provided.</returns>
            <remarks>This method returns an InternalFeature based on an Id provided.</remarks>
            <param name="id">This parameter is the unique Id for the feature you want to find.</param>
            <param name="returningColumnNamesType">
            This parameter is a list of column names you want returned with the
            Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the id, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass a null as the id, we will throw an ArgumentNullException.</exception>        
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass a null as the returningColumnNamesType, we will throw an ArgumentNullException.</exception>      
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesByIds(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method returns a collection of InternalFeatures based on the collection of Ids
            provided.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures based on the collection of Ids
            provided.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures based on the collection of Ids
            provided.
            </remarks>
            <param name="ids">This parameter is the collection of Ids you want to find.</param>
            <param name="returningColumnNames">
            This parameter is a list of column names you want returned with the
            Features.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetFeaturesByIds(System.Collections.Generic.IEnumerable{System.String},ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <summary>
            This method returns a collection of InternalFeatures based on the collection of Ids
            provided.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures based on the collection of Ids
            provided.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures based on the collection of Ids
            provided.
            </remarks>
            <param name="ids">This parameter is the collection of Ids you want to find.</param>
            <param name="returningColumnNamesType">
            This parameter is a list of column names you want returned with the
            Features.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetBoundingBoxById(System.String)">
            <summary>This method returns the bounding box for the Id specified.</summary>
            <returns>This method returns the bounding box for the Id specified.</returns>
            <remarks>This method returns the bounding box for the Id specified.</remarks>
            <param name="id">
            This parameter is the unique Id of the feature for which you want to find the bounding
            box.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetBoundingBoxesByIds(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method returns a collection of bounding boxes based on the collection of Ids
            provided.
            </summary>
            <returns>
            This method returns a collection of bounding boxes based on the collection of Ids
            provided.
            </returns>
            <remarks>
            This method returns a collection of bounding boxes based on the collection of Ids
            provided.
            </remarks>
            <param name="ids">This parameter is the collection of Ids you want to find.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetColumns">
            <summary>This method returns the collection of columns for this FeatureSource.</summary>
            <returns>This method returns the collection of columns for this FeatureSource.</returns>
            <remarks>This method returns the collection of columns for this FeatureSource.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetCount">
            <summary>This method returns the count of all of the InternalFeatures in the FeatureSource.</summary>
            <returns>This method returns the count of all of the InternalFeatures in the FeatureSource.</returns>
            <remarks>This method returns the count of all of the InternalFeatures in the FeatureSource.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetAllFeatures(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames, we will throw an ArgumentNullException.</exception>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. It will return
            whatever is returned by the GetAllFeaturesCore method, along with any of the additions or
            subtractions made if you are in a transaction and that transaction is configured to be
            live.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We as the framework developers wanted to provide you
            the user with as much default virtual implementation as possible. To do this, we needed
            a way to get access to all of the features. For example, let's say we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class, we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all of the records, then we can brute-force
            the answer. In this way, if you inherited from this class and only implemented this one
            method, we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource,
            it comes with a price: namely, it is very inefficient. In the example we just
            discussed (about finding all of the InternalFeatures in a bounding box), we would not want to look
            at every record to fulfil this method. Instead, we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be faster. For
            example, in Oracle Spatial there is a specific SQL statement to perform this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore, which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. This will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The return value is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.GetAllFeatures(ThinkGeo.MapSuite.Core.ReturningColumnsType)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a FeatureSource which has not been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass a null as the returningColumnNamesType, we will throw an ArgumentNullException.</exception>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. It will return
            whatever is returned by the GetAllFeaturesCore method, along with any of the additions or
            subtractions made if you are in a transaction and that transaction is configured to be
            live.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We as the framework developers wanted to provide you
            the user with as much default virtual implementation as possible. To do this, we needed
            a way to get access to all of the features. For example, let's say we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class, we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all of the records, then we can brute-force
            the answer. In this way, if you inherited from this class and only implemented this one
            method, we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource,
            it comes with a price: namely, it is very inefficient. In the example we just
            discussed (about finding all of the InternalFeatures in a bounding box), we would not want to look
            at every record to fulfil this method. Instead, we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be faster. For
            example, in Oracle Spatial there is a specific SQL statement to perform this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore, which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. This will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.<br/>
            	<br/>
            	<br/>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The return value is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <param name="returningColumnNamesType">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.ExecuteNonQuery(System.String)">
            <summary>Executes a SQL statement against a connection object.</summary>
            <returns>The number of rows affected.</returns>
            <remarks>
            	You can use ExecuteNonQuery to perform catalog
                operations (for example, querying the structure of a database or creating database
                objects such as tables), or to change the data in a database by executing UPDATE,
                INSERT, or DELETE statements.
            	Although ExecuteNonQuery does not return any
                rows, any output parameters or return values mapped to parameters are populated
                with data.
            	For UPDATE, INSERT, and DELETE statements, the return value is the number of
                rows affected by the command.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.ExecuteScalar(System.String)">
            <summary>
            Executes the query and returns the first column of the first row in the result
            set returned by the query. All other columns and rows are ignored.
            </summary>
            <returns>The first column of the first row in the result set.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            requires less code than use the ExcuteQuery method and then performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The SQL statement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QueryTools.ExecuteQuery(System.String)">
            <summary>
            Executes the query and returns the result returned by the query.
            </summary>
            <returns>The result set in the format of dataTable.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            requires less code than use the ExcuteQuery method and then performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The SQL statement to be excuted.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.QueryTools.CanExecuteSqlQuery">
            <summary>
            This property specifies whether FeatureSource can excute a SQL query or not.
            If it is false, then it will throw an exception when the following APIs are called: ExecuteScalar, ExecuteNonQuery, ExecuteQuery
            </summary>
            <remarks>The default implementation is false.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MultipolygonShape">
            <summary>This class represents one or more polygons.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.#ctor">
            <overloads>This overload creates the MultipolygonShape without any polygons.</overloads>
            <summary>This constructor creates the PolygonShape.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.PolygonShape})">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the polygons, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the MultipolygonShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates the MultipolygonShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and the copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.GetPerimeterCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method returns the perimeter of the shape (defined as the sum of the lengths
            of all its sides).
            </summary>
            <overloads>
            In this overload, the return unit is based on the LengthUnit you specify in the
            returningLengthUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the LengthUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>
            You would use this method to find the distance around an area shape.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the DistanceUnit you would like to use as the return value. For example, if
            you select miles as your returningUnit, then the distance will be returned in
            miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.GetAreaCore(ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.AreaUnit)">
            <summary>
            This method returns the area of the shape (defined as the size of the region
            enclosed by the figure).
            </summary>
            <overloads>
            In this overload, the return unit is based on the AreaUnit you specify in the
            returningUnit parameter, regardless of the shape's GeographyUnit.
            </overloads>
            <returns>
            The return unit is based on the AreaUnit you specify in the returningUnit
            parameter, regardless of the shape's GeographyUnit.
            </returns>
            <remarks>You would use this method to find the area inside the shape.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a returningUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="returningUnit">
            This is the AreaUnit you would like to use as the return value. For example, if
            you select square miles as your returningUnit, then the distance will be returned in
            square miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.ScaleUpCore(System.Double)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <remarks>
            This method is useful when you would like to increase the size of the shape. Note
            that a larger percentage will scale the shape up faster, as you are applying the operation
            multiple times. There is also a ScaleDown method that will shrink the shape.
            </remarks>
            <summary>
            This method increases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <param name="percentage">This is the percentage by which to increase the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.ScaleDownCore(System.Double)">
            <summary>
            This method decreases the size of the area shape by the percentage given in the
            percentage parameter.
            </summary>
            <returns>
            This method is useful when you would like to decrease the size of the shape. Note
            that a larger percentage will scale the shape down faster, as you are applying the operation
            multiple times. There is also a ScaleUp method that will enlarge the shape.
            </returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid percentage which is less than 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="percentage">This is the percentage by which to decrease the shape's size.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.RegisterCore(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on the DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another based on an X
                and Y offset distance. It is important to note that with this overload the X and Y
                offset units are based off of the distanceUnit parameter. For example if your shape
                is in decimal degrees and you call this method with an X offset of one and a Y
                offset of one and you're going to move this shape one unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way you can easily move a shape in decimal degrees five miles to
                on the X axis and 3 miles on the Y axis.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified by
            the distanceUnit parameter.
            </param>
            <param name="yOffsetDistance">
            This is the number of vertical units of movement in the DistanceUnit specified by
            the distanceUnit parameter.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the move.
                For example, if you select miles as your distanceUnit, then the xOffsetDistance and yOffsetDistance
                will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on a
            direction in degrees and distance.
            </summary>
            <overloads>In this overload the distance is in the same GeographicUnit as the shape.</overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an
                angleInDegrees and distance parameter. With this overload, it is important to note
                that the distance units are the same GeographicUnit as the shape. For example,
                if your shape is in decimal degrees and you call this method with a distance of 1,
                you're going to move this shape 1 decimal degree in direction of the
                angleInDegrees. In many cases it is more useful to specify the DistanceUnit of movement,
                such as in miles or yards, so for these scenarios there is another overload you may
                want to use instead.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape in the angle specified. The
            distance unit will be the same as the GeographyUnit for the shape. The distance must be
            greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure of the
                translate. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.RotateCore(ThinkGeo.MapSuite.Core.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.GetClosestPointToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.GetDistanceToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <returns>
            This method returns the distance between the current shape and the
            targetShape.
            </returns>
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <remarks>None</remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.GetWellKnownTextCore">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric shapes.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Core.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe a geometry as a binary array. Well-known
            binary is useful when you want to save a geometry in an efficient format using as little
            space as possible. An alternative to well-known binary is well-known text, which is a
            textual representation of a geometry object. We have methods that work with well-known
            text as well.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies whther the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.GetBoundingBoxCore">
            <summary>
            This method calculates the smallest RectangleShape that encompasses the entire
            geometry.
            </summary>
            <returns>
            The RectangleShape returned is the smallest RectangleShape that can encompass the
            entire geometry.
            </returns>
            <remarks>
            	<para>The GetBoundingBox method calculates the smallest RectangleShape that can
                encompass the entire geometry by examining each point in the geometry.</para>
            	<para><br/>
                Depending on the number of PointShapes and complexity of the geometry, this
                operation can take longer for larger objects.</para>
            	<para><br/>
                If the shape is a PointShape, then the bounding box's upper left and lower right
                points will be equal. This will create a RectangleShape with no area.<br/>
            		<br/>
            		<br/>
                Overriding:<br/>
            		<br/>
                Please ensure that you validate the parameters being passed in and raise the exceptions
                defined above.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to get the bounding box from a shape which has no points, it will throw an InvalidOperationException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.ValidateCore(ThinkGeo.MapSuite.Core.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.GetCrossingCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.RemoveVertex(ThinkGeo.MapSuite.Core.Vertex,ThinkGeo.MapSuite.Core.MultipolygonShape)">
            <summary>
            This method removes the selected vertex from multipolygon shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of multipolygon shape, otherwise it will return false and multipolygon shape will keep the same.</param>
            <param name="multipolygonShape">The multipolygon shape will be removed one vertex.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipolygonShape.RemoveVertex(ThinkGeo.MapSuite.Core.Vertex)">
            <summary>
            This method removes the selected vertex from multipolygon shape.
            </summary>
            <param name="selectedVertex">The selected vertex must be a vertex of multipolygon shape, otherwise it will return false and multipolygon shape will keep the same.</param>
            <returns>If remove sucess it will return true, otherwise return false.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultipolygonShape.Polygons">
            <summary>This property is the collection of PolygonShapes that make up the MultipolygonShape.</summary>
            <decimalDegreesValue>This property is the collection of PolygonShapes that make up the MultipolygonShape.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultipolygonShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <decimalDegreesValue>This property specifies whether the shape can be rotated.</decimalDegreesValue>
            <remarks>
            If this property returns false and you attempt call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeographyUnit">
            <summary>Units describing the way geographies are stored in a data source.</summary>
            <remarks>
            The geography unit defines how your map data is stored. More specifically, it
            describes what the change in X and Y mean in relationship to the data itself. For
            example, if your data is stored in a geographic unit of feet, an increase of one
            on the x-axis means that you've moved one foot in the X direction. Nearly all map data is
            stored using three simple units, which are decimal degrees, feet, and meters. It is
            important to note that this has very little to do with the projection that the data is
            in.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeographyUnit.Unknown">
            <summary>Unknown</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeographyUnit.DecimalDegree">
            <summary>Decimal Degrees</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeographyUnit.Feet">
            <summary>Feet</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.GeographyUnit.Meter">
            <summary>Meters </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DistanceUnit">
            <remarks>
            Length units are most commonly used when calling APIs that measure lengths.
            Regardless of the unit of measure your shapes are in, many of our APIs allow you to
            specify what unit of measure you want the result of the method call to be in. For
            example, you may have a LineShape whose points are in decimal degrees; however, you want
            to know the length in miles. This is easy to accomplish. Simply call the GetLength method on the
            LineShape, passing in the first parameter of decimal degrees (which defines what unit
            the shape is in), and then miles as the length unit you would like the result to be in.
            </remarks>
            <summary>Units describing various ways you can measure lengths.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DistanceUnit.Meter">
            <summary>Meter</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DistanceUnit.Feet">
            <summary>Feet</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DistanceUnit.Kilometer">
            <summary>Kilometer</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DistanceUnit.Mile">
            <summary>Mile</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DistanceUnit.UsSurveyFeet">
            <summary>US Survey Feet</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DistanceUnit.Yard">
            <summary>Yard</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DrawingLineJoin">
            <remarks>None</remarks>
            <summary>
            	<para>This enumeration specifies how to join consecutive line or curve
                segments.</para>
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineJoin.Bevel">
            <summary>Specifies a beveled join. This produces a diagonal corner.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineJoin.Miter">
            <summary>
            Specifies a mitered join. This produces a sharp corner or a clipped corner,
            depending on whether the length of the miter exceeds the miter limit.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineJoin.MiterClipped">
            <summary>
            Specifies a mitered join. This produces a sharp corner or a beveled corner,
            depending on whether the length of the miter exceeds the miter limit.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingLineJoin.Round">
            <summary>
            Specifies a circular join. This produces a smooth, circular arc between the
            lines.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ExceptionDescription">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.AddTransactionError">
            <summary>
              Looks up a localized string similar to The add transaction failed for an unknown reason..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.BothIconFilePathAndIconImageAreInvalid">
            <summary>
              Looks up a localized string similar to You can provide a path and file name to an icon or an image but not both..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.CellHeightLessThanZero">
            <summary>
              Looks up a localized string similar to The cellHeight needs to be greater than zero..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.CellWidthLessThanZero">
            <summary>
              Looks up a localized string similar to The cellWidth needs to be greater than zero..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.CheckIsOpenedWhenCloneDeep">
            <summary>
              Looks up a localized string similar to You can not CloneDeep because the object is open or drawing, please close or end drawing first..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.CheckLayerIsOpened">
            <summary>
              Looks up a localized string similar to The Layer must be opened before you can perform this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.CheckMapEngineCurrentExtentIsNotValid">
            <summary>
              Looks up a localized string similar to The current extent provided is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ClassBreakNumberShouldBeGreaterThanOne">
            <summary>
              Looks up a localized string similar to The ClassBreak Number should be greater than one..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ClassBreaksIsValid">
            <summary>
              Looks up a localized string similar to The class breaks you have provided are invalid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ColorDoesNotExist">
            <summary>
              Looks up a localized string similar to The color you have provided does not exist..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ColumnNumberExceedTotalRowCount">
            <summary>
              Looks up a localized string similar to The parameter column exceeds the total column count..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.CommonImageSourceIsAlreadyOpen">
            <summary>
              Looks up a localized string similar to The ImageSource is already open..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ConnectionStringCannotBeNull">
            <summary>
              Looks up a localized string similar to The connection string can not be null..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.CreateShapeFileFailed">
            <summary>
              Looks up a localized string similar to The creation of the shape file has failed..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.CurrentExtentNotAssigned">
            <summary>
              Looks up a localized string similar to The CurrentExtent property must be set before calling this method. If you want to use a custom extent, please use the static method.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.DbfColumnsIsEmpty">
            <summary>
              Looks up a localized string similar to The DbfColumns collection is empty, you should add at least one DbfColumn when you create a new shape file..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.DecimalDegreeLatitudeOutOfRange">
            <summary>
              Looks up a localized string similar to The decimal degree latitude value you provided was out of range..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.DecimalDegreeLongitudeOutOfRange">
            <summary>
              Looks up a localized string similar to The decimal degree longitude value you provided was out of range..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.DecimalDegreeSecondsStringNull">
            <summary>
              Looks up a localized string similar to The degreesMinutesSeconds string may not be null or empty..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.DecimalLengthInValidForStringColumnType">
            <summary>
              Looks up a localized string similar to DecimalLength is Invalid(it should be 0) for StringColumnType, it only make sense for DoubleColumnType..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.DefaultAndCustomStyleDuplicate">
            <summary>
              Looks up a localized string similar to You are trying to use both a default style and the custom styles collection.  You may only use one or the other..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.DefaultAndCustomStyleDuplicateForRestrictedLayer">
            <summary>
              Looks up a localized string similar to You are trying to use both a default style and the custom styles collection. If you want to add custom styles, please set RestrictionStyle as RestrictionStyle.UseCustomStyles..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.DegreesMinutesSecondsInputError">
            <summary>
              Looks up a localized string similar to The DegreesMinutesSeconds value is invalid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.DeleteTransactionError">
            <summary>
              Looks up a localized string similar to The delete transaction failed for an unknown reason..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.DoubleOutOfRange">
            <summary>
              Looks up a localized string similar to The input double value is out of range..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.EditingNotSupported">
            <summary>
              Looks up a localized string similar to You have set IsEditable to true but have not overridden the CommitTransactionCore method.  Please override this the CommitTransactionCore method to prevent this exception..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.EllipseIsNotValid">
            <summary>
              Looks up a localized string similar to The ellipse is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.EnumerationOutOfRange">
            <summary>
              Looks up a localized string similar to The value for the enumeration is not on of the valid values..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.EvalNotInstall">
            <summary>
              Looks up a localized string similar to The evaluation edition has not been installed..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.EvaluationExpired">
            <summary>
              Looks up a localized string similar to The evaluation has expired.  Please contact ThinkGeo for purchasing option or an extension to the trial..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ExtentNotIntersectsWithBoundingBox">
            <summary>
              Looks up a localized string similar to The passed extent needs to intersect with the bounding box of the gid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FeatureCollectionIsEmpty">
            <summary>
              Looks up a localized string similar to The collection of Features may not be empty..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FeatureColumnValueDoesNotContainColon">
            <summary>
              Looks up a localized string similar to The feature column values should be entered as string[] {&quot;Key1:Value1&quot;, &quot;Key2:Value2&quot;}.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FeatureIsInvalidInThisStyle">
            <summary>
              Looks up a localized string similar to The feature is invalid in in this style..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FeatureIsNotValid">
            <summary>
              Looks up a localized string similar to The Feature you provided is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FeatureSourceCanNotExecuteSqlQuery">
            <summary>
              Looks up a localized string similar to Executing sql queries is not supported and the user should always check the CanExecuteSqlQueries to ensure the FeatureSource support it before calling..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FeatureSourceCollectionIsEmpty">
            <summary>
              Looks up a localized string similar to There are no FeatureSources..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FeatureSourceColumnCollectionIsEmpty">
            <summary>
              Looks up a localized string similar to The collection of FeatureSourceColumns may not be empty..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FeatureSourceIsAlreadyInTransaction">
            <summary>
              Looks up a localized string similar to The FeatureSource is already in a transaction..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FeatureSourceIsAlreadyOpen">
            <summary>
              Looks up a localized string similar to The FeatureSource is already opened..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FeatureSourceIsNotEditable">
            <summary>
              Looks up a localized string similar to The FeatureSource is not editable..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FeatureSourceIsNotInTransaction">
            <summary>
              Looks up a localized string similar to The FeatureSource is not in a transaction..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FeatureSourceIsNotOpen">
            <summary>
              Looks up a localized string similar to The FeatureSource is not open.   Please call the Open method before calling this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FieldNameIsNotInFeature">
            <summary>
              Looks up a localized string similar to The requested column name is not in the Feature..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FileAccessError">
            <summary>
              Looks up a localized string similar to File access error, you should open the shape file with ReadWrite mode..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FileAlreadyExists">
            <summary>
              Looks up a localized string similar to The file already exists..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FileIsNotExist">
            <summary>
              Looks up a localized string similar to The file specified does not exist..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FileIsSupportedByCommonImageSource">
            <summary>
              Looks up a localized string similar to This file type is not supported..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FileNotSupportedForSql">
            <summary>
              Looks up a localized string similar to One of the fields in the database is not supported by SQL. The first character of this field name must be an alphabetic letter..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.FirstClassBreakValueError">
            <summary>
              Looks up a localized string similar to The first ClassBreak value should be double.MinValue..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.GdipLoadImageFromFileError">
            <summary>
              Looks up a localized string similar to GDI+ threw a status error code..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.GeoCacheIsNotOpen">
            <summary>
              Looks up a localized string similar to The GeoCache is not open.  Please call the Open method before calling this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.GeocanvasIsNotInDrawing">
            <summary>
              Looks up a localized string similar to The GeoCanvas is currently not drawing.  Please call the BeginDraw method before calling this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.GeographicUnitNotValidWithGoogle">
            <summary>
              Looks up a localized string similar to The map unit you are using is not compatable with the GoogleLayer .  Make sure you are using Meters and that your projection is 90013 to ensure compatability..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.GeographicUnitNotValidWithOpenStreetMap">
            <summary>
              Looks up a localized string similar to The map unit you are using is not compatable with the OpenStreetMap .  Make sure you are using Meters to ensure compatability with OpenStreetMap service..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.GeoImageIsNotValid">
            <summary>
              Looks up a localized string similar to The input GeoImage object is not a valid GeoImage type..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.GeometriesInvalidExist">
            <summary>
              Looks up a localized string similar to We have found geometries that are invalid according to the SQL Server STIsValid() Function. To automaticly fix these you can call the MakeAllGeometriesValid method. The SQL To Determine which records are invalid:.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.GeometrytypeIsWrong">
            <summary>
              Looks up a localized string similar to Geometry type not recognized. .
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.GettingSridNotSupported">
            <summary>
              Looks up a localized string similar to The current GeoImage implementation does not support the GetSrid operation..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.GroupLayerIsEmpty">
            <summary>
              Looks up a localized string similar to You must have at least one layer..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.HtmlColorIsInvalid">
            <summary>
              Looks up a localized string similar to The input string HtmlColor is invalid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.IdColumnCannotBeNullOrEmpty">
            <summary>
              Looks up a localized string similar to Id column can&apos;t be null or empty..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.IEnumerableIsEmptyOrNull">
            <summary>
              Looks up a localized string similar to The collection may not be empty or null..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ImageInPointStyleCanNotBeNull">
            <summary>
              Looks up a localized string similar to The image property can&apos;t be null..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ImageScaleShouldBiggerThanZero">
            <summary>
              Looks up a localized string similar to The ImageScaled property must be larger than 0..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ImageSourceIsAlreadyOpen">
            <summary>
              Looks up a localized string similar to The ImageSource is already open..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ImageSourceIsNotOpen">
            <summary>
              Looks up a localized string similar to The ImageSource is not open.  Please call the Open method before calling this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.IndexFileAlreadyExists">
            <summary>
              Looks up a localized string similar to Index File already exist, please change the BuildIndexMode if you want to rebuild this index..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.IndexFileIsInvalid">
            <summary>
              Looks up a localized string similar to The format of your index file is not valid, please check. Or you can use BuildIndexFile function to build a new one..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.IndexFileNotExisted">
            <summary>
              Looks up a localized string similar to You don&apos;t have the corresponding idx file for your shape file. You can use the static method ShapeFileFeatureSource.BuildIndexFile() or ShapeFileFeatureLayer.BuildIndexFile()  to build an idx file for the shape file, or you can set the RequireIndex property to false..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.InputGeometryTypeIsNotValid">
            <summary>
              Looks up a localized string similar to Input Geometry Type Is Not Valid.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.InvalidGeometryInMsSqlForSpatialQuery">
            <summary>
              Looks up a localized string similar to There&apos;re some invalid geometry instance in table not valid. About invalid geometry please have a look at http://msdn.microsoft.com/en-us/library/bb933890.aspx website. To solve this problem, we provide MakeAllGeometryValid function to make the invalid geometry to be valid, because of the function updating your data, you need to backup your data before using this function..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.InvalidOperationExceptionError">
            <summary>
              Looks up a localized string similar to Invalid Operation Exception..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ItemNotFoundInGeoCollectionByItem">
            <summary>
              Looks up a localized string similar to The GeoCollection does not contain the item you specified..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ItemNotFoundInGeoCollectionByKey">
            <summary>
              Looks up a localized string similar to The GeoCollection does not contain the item you specified..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.JpegImageCompressionShouldBeBetweenZeroAndOneHundred">
            <summary>
              Looks up a localized string similar to The value should be between zero and one hundred..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.KeyColorIsNotSupported">
            <summary>
              Looks up a localized string similar to Do not support KeyColor in the specify GeoCanvas..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.LayerDoesNotHaveBoundingBox">
            <summary>
              Looks up a localized string similar to This Layer doesn&apos;t have a boundingBox..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.LayersTypeIsOutOfRange">
            <summary>
              Looks up a localized string similar to The layer type you have provided is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.MapEngineCurrentExtentIsNotValid">
            <summary>
              Looks up a localized string similar to The current extent you have provided is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.MapEngineCurrentExtentIsNull">
            <summary>
              Looks up a localized string similar to The current extent you have provided may not be null..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.MrSidGeoImageSourceIsAlreadyOpen">
            <summary>
              Looks up a localized string similar to The MrSidGeoImageSource is already open..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.MrSidGeoImageSourceIsNotOpen">
            <summary>
              Looks up a localized string similar to The MrSidGeoImageSource is not open.  Please open it before calling this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.MultiFieldNamesNotSupportedError">
            <summary>
              Looks up a localized string similar to The format of Multi-FieldNames isn&apos;t correct..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.MultiLineCannotReorderForInputParams">
            <summary>
              Looks up a localized string similar to Can&apos;t Reorder for the multi-line because it does not satisfy the reorder condition based on the given startPoint and given tolerance..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.MultiLineInvalidForReorder">
            <summary>
              Looks up a localized string similar to Can&apos;t Reorder for the multi-line because it does not satisfy the reorder condition based on the given tolerance..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.NotAllValidLayersAreOpen">
            <summary>
              Looks up a localized string similar to Not all valid layers are open..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.NotSupported">
            <summary>
              Looks up a localized string similar to This feature is currently not supported..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.NotSupportedFileType">
            <summary>
              Looks up a localized string similar to The file type you provided is currently not supported..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.NotSupportedSqlQueryMode">
            <summary>
              Looks up a localized string similar to The SQL Query mode is not supported..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.NumberShouldBeByte">
            <summary>
              Looks up a localized string similar to The number should be between 0 and 255.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ParameterCanNotConvert">
            <summary>
              Looks up a localized string similar to We cannot get the AreaUnit from input unit..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ParameterIdsIsNotIntegers">
            <summary>
              Looks up a localized string similar to Parameter Ids should be from 1 to the record number in ShapeFileFeatureSource.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ParameterIsEmpty">
            <summary>
              Looks up a localized string similar to The parameter you supplied may not be empty..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ParameterIsInvalid">
            <summary>
              Looks up a localized string similar to The shape you provided does not pass our simple validation..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ParameterIsNull">
            <summary>
              Looks up a localized string similar to The parameter you supplied may not be null..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ParameterIsTransparent">
            <summary>
              Looks up a localized string similar to The parameter is transparent..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ProjectionInitializationError">
            <summary>
              Looks up a localized string similar to Projection initialization failed..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ProjectionIsNotOpen">
            <summary>
              Looks up a localized string similar to The projection is not open.  Please open it before calling this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.RasterLayerDoesNotHaveProjectionInformation">
            <summary>
              Looks up a localized string similar to This RasterLayer does not have projection information embedded in it.  If you wish to avoid this exception you can first check the HasProjectionTextProperty..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.RasterSourceNotContainsProjectionInformation">
            <summary>
              Looks up a localized string similar to This RasterSource does not have projection information embedded in it.  If you wish to avoid this exception you can first check the HasProjectionTextProperty..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.RebuildDbfFailed">
            <summary>
              Looks up a localized string similar to The rebuild of the DBF failed for an unknown reason.  Please see the inner exception..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.RebuildIdxFailed">
            <summary>
              Looks up a localized string similar to The spatial index generation failed for an unknown reason.    Please see the inner exception..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.RebuildShapeFileFailed">
            <summary>
              Looks up a localized string similar to the rebuilding of the shape file failed for an unknown reason.    Please see the inner exception..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.RecordIsInvalid">
            <summary>
              Looks up a localized string similar to The record is invalid, please call Validate method to check the failed reason..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ReturnTypeNotCorrect">
            <summary>
              Looks up a localized string similar to This operation&apos;s return type is not correct..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ReturnValueIsNull">
            <summary>
              Looks up a localized string similar to Return value is null..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.RingShapeIsInvalidForOperationVertexCountLessThan4">
            <summary>
              Looks up a localized string similar to This ring is not closed.  To close a ring the last point must be the same as the first point.  All rings must have at least four points..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.RotateNotSupported">
            <summary>
              Looks up a localized string similar to Rotation is not supported on this class..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.RowNumberExceedTotalRowCount">
            <summary>
              Looks up a localized string similar to The parameter row exceeds the total row count..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ShapeFileBoundingBoxIsValid">
            <summary>
              Looks up a localized string similar to The shape file bounding box is invalid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ShapefileFeatureSourceIdNotFromZero">
            <summary>
              Looks up a localized string similar to The Shapefile Id is one based, zero is an invalid Id..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ShapeFileNameIsInvalid">
            <summary>
              Looks up a localized string similar to The shape file name is invalid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ShapeIsInvalidForOperation">
            <summary>
              Looks up a localized string similar to The shape you provided does not pass our simple validation..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ShapeIsInvalidForValidation">
            <summary>
              Looks up a localized string similar to There are no points in the shape..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ShapeTypeNotImplement">
            <summary>
              Looks up a localized string similar to This shape has not been implemented yet..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.ShxFileIsNotOpen">
            <summary>
              Looks up a localized string similar to The shape file index is not open..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.SpatialIndexIsNotRemovable">
            <summary>
              Looks up a localized string similar to The features in SpatialIndex are not removable..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.SridIsInvalid">
            <summary>
              Looks up a localized string similar to Input srid is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.StringIsNotBlank">
            <summary>
              Looks up a localized string similar to The input string value is not blank..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.TargetShapeIsNotValidType">
            <summary>
              Looks up a localized string similar to Target Shape Is Not Valid Type..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.TheFieldTtypeShouldBeNumeric">
            <summary>
              Looks up a localized string similar to The field type should be numeric..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.TheFormatOfImageIsNotSupported">
            <summary>
              Looks up a localized string similar to The format of the image is not supported..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.TheValueShouldBeGreaterThanZero">
            <summary>
              Looks up a localized string similar to The value should be greater than zero..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.Unlicensed">
            <summary>
              Looks up a localized string similar to Unlicensed..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.UnsupportedEditingShapeType">
            <summary>
              Looks up a localized string similar to Currently we do not support editing this kind of shape type. Shape type:.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.UpdateTansactionError">
            <summary>
              Looks up a localized string similar to The update transaction failed for an unknown reason..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.UriNotValid">
            <summary>
              Looks up a localized string similar to The input Uri is not valid.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.UseGeoTiffRasterInstead">
            <summary>
              Looks up a localized string similar to The TIFF files(.tif or .tiff) are not supported in GdiPlusRasterSource any longer, please use the GeoTiffRasterSource instead..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WkbIsInvalid">
            <summary>
              Looks up a localized string similar to The format of the well known binary is incorrect..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WkbIsNotValidForDrawing">
            <summary>
              Looks up a localized string similar to The well known binary is not valid for drawing..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WkbTypeError">
            <summary>
              Looks up a localized string similar to The well known binary type is incorrect..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WktFormatIsWrong">
            <summary>
              Looks up a localized string similar to The format of the well known text is incorrect..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WmsCRSNotSet">
            <summary>
              Looks up a localized string similar to Coordinate Reference System not set..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WmsCRSNotSupport">
            <summary>
              Looks up a localized string similar to This CRS is not supported in the Wms server: .
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WmsGetMapTimeOut">
            <summary>
              Looks up a localized string similar to The Wms server has timed out..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WmsLayerDoesNotExists">
            <summary>
              Looks up a localized string similar to The Wms request LAYERS parameter is missing..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WmsNoLayerExists">
            <summary>
              Looks up a localized string similar to No layers exist in the Service Description..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WmsRequestParaNotExists">
            <summary>
              Looks up a localized string similar to The requested parameter does not exists in this Service Description..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WmsServerNotSupportFormat">
            <summary>
              Looks up a localized string similar to This image format is not supported in the Wms server: .
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WmsServerNotSupportLayer">
            <summary>
              Looks up a localized string similar to This layer is not supported in the Wms server: .
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WmsServerNotSupportStyle">
            <summary>
              Looks up a localized string similar to This style is not supported in the Wms server: .
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WmsStyleDoesNotExists">
            <summary>
              Looks up a localized string similar to The Wms request STYLES parameter is missing..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WorldExtentIsNotValid">
            <summary>
              Looks up a localized string similar to The world extent is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WorldFileShould6Lines">
            <summary>
              Looks up a localized string similar to World file should has 6 lines..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WpfCommonGeoImageSourceIsAlreadyOpen">
            <summary>
              Looks up a localized string similar to The ImageSource is already open..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ExceptionDescription.WpfCommonGeoImageSourceIsNotOpen">
            <summary>
              Looks up a localized string similar to The ImageSource is not opened.  Please open it before calling this method..
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Vertex">
            <summary>
            This structure represents the point at which the sides of an angle
            intersect.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Vertex.#ctor(System.Double,System.Double)">
            <summary>This is the constructor used to create a vertex.</summary>
            <remarks>None</remarks>
            <overloads>This constructor takes X and Y coordinates.</overloads>
            <param name="x">This parameter represents the horizontal value.</param>
            <param name="y">This parameter represents the vertical value.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Vertex.#ctor(ThinkGeo.MapSuite.Core.PointShape)">
            <summary>This is the constructor used to create a vertex.</summary>
            <overloads>This constructor takes a PointShape.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="point">This parameter is the PointShape you want to convert to a Vertex.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Vertex.ToString">
            <summary>This method is an override of the ToString functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Vertex.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Vertex.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Vertex.Add(ThinkGeo.MapSuite.Core.Vertex)">
            <summary>This method adds the target vertex to the current vertex.</summary>
            <remarks>None</remarks>
            <param name="targetVertex">
            This parameter represents the vertex you wish to add to the current
            vertex.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Vertex.op_Addition(ThinkGeo.MapSuite.Core.Vertex,ThinkGeo.MapSuite.Core.Vertex)">
            <summary>This method is an override of the + functionality.</summary>
            <remarks>None</remarks>
            <param name="vertex1">This parameter represents the first vertex to add.</param>
            <param name="vertex2">This parameter represents the second vertex to add.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Vertex.op_Equality(ThinkGeo.MapSuite.Core.Vertex,ThinkGeo.MapSuite.Core.Vertex)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <param name="vertex1">This parameter represents the first vertex to compare.</param>
            <param name="vertex2">This parameter represents the second vertex to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Vertex.op_Inequality(ThinkGeo.MapSuite.Core.Vertex,ThinkGeo.MapSuite.Core.Vertex)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <param name="vertex1">This parameter represents the first vertex to compare.</param>
            <param name="vertex2">This parameter represents the second vertex to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Vertex.FindMiddleVertexBetweenTwoVertices(ThinkGeo.MapSuite.Core.Vertex,ThinkGeo.MapSuite.Core.Vertex)">
            <summary>
            This method returns the middle Vertex of a straight line which two vertices are passing in.
            </summary>
            <param name="vertex1">start vertex of a straight line</param>
            <param name="vertex2">en vertex of a straight line</param>
            <returns>This method returns the middle Vertex between the vertices which passing in.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Vertex.X">
            <summary>This property returns the horizontal value of the vertex.</summary>
            <value>This property returns the horizontal value of the vertex.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Vertex.Y">
            <summary>This property returns the vertical value of the vertex.</summary>
            <value>This property returns the vertical value of the vertex.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.TransactionResultStatus">
            <summary>This enumeration represents the results from a FeatureSource transaction.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.TransactionResultStatus.Success">
            <summary>This means that each item in the transaction buffer succeeded.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.TransactionResultStatus.Failure">
            <summary>
            This means that at least one of the items in the transaction buffer failed. It
            may mean that other record did succeed. This depends on the implementation of the
            specific FeatureSource.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.TransactionResultStatus.Cancel">
            <summary>This means that the transaction was canceled.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.TransactionResult">
            <summary>This class represents the results of a transaction that was processed.</summary>
            <remarks>
            This class holds the results of a transaction. It can tell the users the number
            of succeeded record and the number of failed records. It also has a dictionary that
            holds the individual reasons that certain records fails by FeatureId. If you are
            implementing this class it is important that you provide as much information about the
            transaction results to your users.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TransactionResult.#ctor">
            <summary>This is the class constructor.</summary>
            <overloads>This is the default constructor and is typically not used.</overloads>
            <returns>None</returns>
            <remarks>This is the default constructor and is typically not used.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TransactionResult.#ctor(System.Int32,System.Int32,System.Collections.Generic.Dictionary{System.String,System.String},ThinkGeo.MapSuite.Core.TransactionResultStatus)">
            <summary>This is the class constructor.</summary>
            <overloads>This is the constructor for this class allows you pass in the necessary 
            properties in the class.</overloads>
            <returns>None</returns>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TransactionResult.TotalSuccessCount">
            <summary>
            This property gets and sets the total number of records that we committed
            successfully.
            </summary>
            <decimalDegreesValue>
            This property gets the total number of records that we committed
            successfully.
            </decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TransactionResult.TotalFailureCount">
            <summary>
            This property gets and sets the total number of records that we committed
            unsuccessfully.
            </summary>
            <decimalDegreesValue>
            This property gets the total number of records that we committed
            unsuccessfully.
            </decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TransactionResult.TransactionResultStatus">
            <summary>This property gets and sets the result status of the transaction.</summary>
            <decimalDegreesValue>This property gets the result status of the transaction.</decimalDegreesValue>
            <remarks>
            This property returns the results of the transaction. If all of the records
            committed fine then you get a success status. If any of the records fail then you get a
            failure status though some of the records may have committed.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TransactionResult.FailureReasons">
            <summary>
            This property gets and sets the dictionary that contains the reasons for
            failure.
            </summary>
            <decimalDegreesValue>This property gets the dictionary that contains the reasons for failure.</decimalDegreesValue>
            <remarks>
            If there are failing records we suggest you add the failure reasons to this
            dictionary. It is also suggested that you use the FeatureId as the key of the
            Dictionary.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RecordElement">
            <summary>
            Structure that holds RecordElement.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PointRecord">
            <summary>
            PointRecord contains point information and manipulation.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointRecord.#ctor">
            <summary>
            DefauLb constructor
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointRecord.#ctor(ThinkGeo.MapSuite.Core.RECORD_HEADER,ThinkGeo.MapSuite.Core.POINT,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="rh"> RECORD_HEADER object </param>
            <param name="pt"> POINT object </param>
            <param name="idx">index of the current record</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointRecord.ToString">
            <summary>
            For debug
            </summary>
            <returns>contents of pointrecord</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointRecord.GetPoint">
            <summary>
            Get point object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointRecord.Read(System.IO.BinaryReader,System.Boolean)">
            <summary>
            Read one PointRecord.
            </summary>
            <param name="isFloat">This parameter specifies whether the rTree is using float or double.</param>
            <param name="r">BinaryReader object</param>
            <returns>
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointRecord.Write(System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write one PointRecord.
            </summary>
            <param name="w">BinaryWriter object</param>
            <param name="isFloat">This parameter specifies whether the rTree is using float or double.</param>
            <returns>
            	true for success 
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointRecord.IsContained(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Test if the record is contained by the specified rectangle.
            </summary>
            <param name="rect">RECTANGLE_D object</param>
            <returns>
            	true for yes
            	false for otherwise
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointRecord.IsContains(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Test if the record contains the specified rectangle.
            </summary>
            <param name="rect">RECTANGLE_D object</param>
            <returns>false</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointRecord.IsOverlaps(ThinkGeo.MapSuite.Core.RECTANGLE_D)">
            <summary>
            Test if the record overlaps with the specified rectangle.
            </summary>
            <param name="rect">RECTANGLE_D object</param>
            <returns>false</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointRecord.GetSize(System.Boolean)">
            <summary>
            Get the size of PointRecord.
            </summary>
            <returns>Size of PointRecord</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointRecord.GetArea">
            <summary>
            Get the area of PointRecord.
            </summary>
            <returns>0</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointRecord.Point">
            <summary>
            Property point
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.IconValueItem">
            <summary>This class is a single item in an IconValueStyle.</summary>
            <remarks>
            	<para>This item is used in the IconValueStyle to determine which way to draw the
                feature based on the FieldValue property.<br/>
            		<br/>
                How IconValueStyle works:<br/>
            		<br/>
                When you create an IconValueStyle, you need to add multiple IconValueItems to its
                collection. You input the column name in the IconValueStyle and it will compare the
                data's value to each IconValueItem's FieldValue. If they match, then it will draw
                the Feature using the properties of the IconValueItem. In this way, you can render
                different data with different icons or text.<br/>
            		<br/>
                The MinimumLength and MaximumLength properties are important because they are used
                to ensure that a properly sized icon is used to draw things like road signs. For example,
                you can set the minimum and maximum values so that the sign icon for a single-digit road
                number uses one icon, while a two-digit road uses another, wider sign icon
                in a separate IconValueItem.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconValueItem.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>This is the default constructor for the class.</overloads>
            <returns>None</returns>
            <remarks>
            If you use the constructor, then you should set all the properties
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconValueItem.#ctor(System.String,System.String,ThinkGeo.MapSuite.Core.TextStyle)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to set the field value, the path and filename of the
            icon and the text style you want to use to render it.
            </overloads>
            <returns>None</returns>
            <remarks>
            You would typically use this constructor if you are using an icon that's located on disk.
            If you need to use an image from a stream instead, there is another overload that takes a
            GeoImage.
            </remarks>
            <param name="fieldValue">This parameter is the value you want to match.</param>
            <param name="iconPathFilename">This parameter is the path and filename of the image you want to use.</param>
            <param name="textStyle">This parameter is the TextStyle of how you want the text drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconValueItem.#ctor(System.String,ThinkGeo.MapSuite.Core.GeoImage,ThinkGeo.MapSuite.Core.TextStyle)">
            <remarks>
            You will typically use this overload if you need to use a stream for the image.
            If you need to use a file located on disk instead, there is another overload that takes the path and
            filename to an image.
            </remarks>
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to set the field value, the GeoImage, and the text
            style you want to use to render it.
            </overloads>
            <returns>None</returns>
            <param name="fieldValue">This parameter is the value you want to match.</param>
            <param name="iconImage">This parameter is the GeoImage of the image you want to use.</param>
            <param name="textStyle">This parameter is the TextStyle of how you want the text drawn.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.IconValueItem.GetIconImage">
            <summary>This method gets the icon we will draw as a GeoImage.</summary>
            <returns>This method gets the icon we will draw as a GeoImage.</returns>
            <remarks>
            This method is used when drawing to get the image as a GeoImage. We will
            internally either pass along the GeoImage the user set, or create a GeoImage from the
            IconFilePathName that was set.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueItem.TextStyle">
            <summary>
            This property gets and sets the style that will be used to draw the text in the
            icon.
            </summary>
            <value>
            This property gets the style that will be used to draw the text in the
            icon.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueItem.FieldValue">
            <summary>
            This property gets and sets the field value that has to match in the
            IconValueStyle.
            </summary>
            <value>
            This property gets the field value that has to match in the
            IconValueStyle.
            </value>
            <remarks>
            For an explanation on how the IconValueStyle works, see the IconValueStyle Class
            remarks.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueItem.IconFilePathName">
            <summary>
            This property gets and sets the path and filename of the icon that will be
            drawn.
            </summary>
            <value>
            This property gets the path and filename of the icon that will be
            drawn.
            </value>
            <remarks>
            If you need to use a GeoImage, you can set the GeoImage in the constructor or
            use the property.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueItem.TextValueLengthMin">
            <summary>
            This property gets and sets the minimum string length for this item to
            match.
            </summary>
            <value>This property gets the minimum string length for this item to match.</value>
            <remarks>
            This is an important property because it is used to ensure that that a properly sized
            icon is used to draw things like road signs. For example,
            you can set the minimum and maximum values so that the sign icon for a single-digit road
            number uses one icon, while a two-digit road uses another, wider sign icon
            in a separate IconValueItem.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.IconValueItem.TextValueLengthMax">
            <remarks>
            This is an important property because it is used to ensure that that a properly sized
            icon is used to draw things like road signs. For example,
            you can set the minimum and maximum values so that the sign icon for a single-digit road
            number uses one icon, while a two-digit road uses another, wider sign icon
            in a separate IconValueItem.
            </remarks>
            <summary>
            This property gets and sets the maximum string length for this item to
            match.
            </summary>
            <value>This property gets the maximum string length for this item to match.</value>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ContactPerson">
            <summary> 
            Information about a contact person for the service. 
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ContactPerson.Person">
            <summary> 
            Primary contact person.
            </summary> 
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.ContactPerson.Organization">
            <summary> 
            Organization of the primary contact person.
            </summary> 
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.Pj_Prime_Meridians">
            <summary>
            definition of class Pj_Prime_Meridians for meridians
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.BitmapTile">
            <summary>
            This class represents a NativeImageTile, which is defined as scale, RectangleBox
            and a byte array for its tile bitmap.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BitmapTile.#ctor">
            <summary>
            This is the default constructor without passing any parameters. All its
            properties should be set via the properties.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BitmapTile.#ctor(ThinkGeo.MapSuite.Core.RectangleShape,System.Double)">
             <summary>
            This is the constructor for Tile by passing the boundingBox and scale.
             </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BitmapTile.#ctor(System.Drawing.Bitmap,ThinkGeo.MapSuite.Core.RectangleShape,System.Double)">
             <summary>
            This is the constructor for Tile by passing image bitmap and the boundingBox and scale.
             </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BitmapTile.Finalize">
            <summary>
            This method is the destructorof this class. Destructor cannot be called and only will be invoked automatically. 
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.BitmapTile.Dispose">
            <summary>
            This method is targeting releasing or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.BitmapTile.Bitmap">
            <summary>This property is the Bitmap showing the tile image.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.UnsafeHelper">
            <summary>
            This static class is a wrapper contains unsafe native methods
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.UnsafeHelper.CopyImage(System.Drawing.Bitmap,System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            This method transfers pixels from source bitmap to destination bitmap within a specified rectangle. 
            </summary>
            <param name="source">source bitmap</param>
            <param name="target">target bitmap</param>
            <param name="r">the specified rectangle</param>
            <remarks>It will call GDI32.dll API CreateCompatibleDC and BitBlt.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.UnsafeHelper.CopyImage(System.Drawing.Bitmap,System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.CopyPixelOperation)">
            <summary>
            This method transfers pixels from source bitmap with a specified source rectangle to destination a specified destination rectangle by specified CopyPixelOperation.
            </summary>
            <param name="source">source bitmap</param>
            <param name="target">target graphics</param>
            <param name="sourceRectangle">the specified rectangle for source bitmap</param>
            <param name="targetRectangle">the specified rectangle for target graphics</param>
            <param name="copyPixelOperation">Specifies a raster-operation code.These codes define how the color data for the source rectangle is to be combined with the color data for the destination rectangle to achieve the final color. </param>
            <remarks>It will call GDI32.dll API CreateCompatibleDC and BitBlt.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.UnsafeHelper.IsKeyPressed(System.Windows.Forms.Keys)">
            <summary>
            Returns a value represents is a specified key pressed or not.
            </summary>
            <param name="keys">An enum represents which key is pressed or not.</param>
            <returns>Returns a value represents is a specified key pressed or not.</returns>
            <remarks>It will call User32.dll API GetAsyncKeyState internally.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.TextStyleAdvanced">
            <summary>This class represents the advanced drawing options for text styles.</summary>
            <remarks>
            This class allows you to set the TextCustomBrush. This enables you to use custom
            brushes to achieve effects such as linear gradients and bitmap fills.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TextStyleAdvanced.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TextStyleAdvanced.TextCustomBrush">
            <summary>This property allows you to get and set a custom  brush.</summary>
            <value>This property returns a custom brush.</value>
            <remarks>
            This allows you to use custom brushes to achieve effects such as linear gradients and
            bitmap fills. If you use any brush besides the SolidBrush, you would set it in this
            property.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.ShapeValidationMode">
            <summary>This enumeration describes the type of validation test to run on shapes.</summary>
            <remarks>
            The simple tests are used internally before any method call is made to a shape.
            In this way, we have a certain level of confidence that the operation will succeed. The
            advanced tests are meant to be performed by users if they get a shape from an
            external source and consider it suspect.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeValidationMode.Simple">
            <summary>The simple tests are designed to be very fast.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.ShapeValidationMode.Advanced">
            <summary>
            The advanced tests are designed to be comprehensive with no regard to
            speed.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.InMemoryFeatureLayer">
            <summary>
            This layer is backed by memory and is typically used for temporary
            features.
            </summary>
            <remarks>
            This layer is backed by memory and is typically used for temporary features. You
            can use the MapShapes layer for user-drawn InternalFeatures, InternalFeatures that come from an
            external device such as a GPS unit, or any InternalFeatures that are not saved to disk or
            a database.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureLayer.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to
            specify the FeatureSource column manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, then you need to specify the FeatureSource column
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureLayer.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.FeatureSourceColumn},System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature})">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the FeatureSource columns and features for the layer.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="featureSourceColumns">This parameter is the FeatureSourceColumn in this class that you want to use.</param>
            <param name="features">This parameter represents the features in this class that you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureLayer.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.FeatureSourceColumn},System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.BaseShape})">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide the FeatureSource columns and shapes for the layer.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="featureSourceColumns">This parameter is the FeatureSourceColumn in this class that you want to use.</param>
            <param name="shapes">This parameter represents the shapes in this class that you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureLayer.GetColumns">
            <summary>
            This method returns the columns of data for the InternalFeatures in this
            Layer.
            </summary>
            <decimalDegreesValue>This method returns the columns of data for the InternalFeatures in this Layer.</decimalDegreesValue>
            <remarks>
            You should set the column names for the data that the InternalFeatures will hold. For
            example, if you have some features that represent road signs, then one column you may
            want to add is "Sign Type". Then, for every Feature you add to the layer, you need to add
            the "Sign Type" and a value to the InternalFeatures' ColumnValues dictionary. If you provide
            this information, then you can use things like ValueStyles, Labeling, etc. based on the
            columns you have defined.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureLayer.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a Layer which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method opens the Layer so that it is initialized and ready to use.</summary>
            <remarks>
            This abstract method is called from the concrete public method Open. The open
            method plays an important role, as it is responsible for initializing the Layer. Most
            methods on the Layer will throw an exception if the state of the Layer is not opened.
            When the map draws each layer, the layer will be opened as one of its first steps; then, after it
            is finished drawing with that layer, it will close it. In this way, we are sure to
            release all resources used by the Layer.<br/>
            	<br/>
            When implementing the abstract method, consider opening the FeatureSource or
            RasterSource. You will get a chance to close these in the Close method of the
            Layer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.InMemoryFeatureLayer.BuildIndex">
            <summary>
            This method build a spatial index for a passed group of featurs which increases access speed.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.InMemoryFeatureLayer.Columns">
            <summary>
            This property gets the columns of data for the InternalFeatures in this
            Layer.
            </summary>
            <decimalDegreesValue>This property gets the columns of data for the InternalFeatures in this Layer.</decimalDegreesValue>
            <remarks>
            You should set the column names for the data that the InternalFeatures will hold. For
            example, if you have some features that represent road signs, then one column you may
            want to add is "Sign Type". Then, for every Feature you add to the layer, you need to add
            the "Sign Type" and a value to the InternalFeatures' ColumnValues dictionary. If you provide
            this information, then you can use things like ValueStyles, Labeling, etc. based on the
            columns you have defined.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.InMemoryFeatureLayer.InternalFeatures">
            <summary>This property gets the dictionary that holds your InternalFeatures.</summary>
            <decimalDegreesValue>This property gets the dictionary that holds your InternalFeatures.</decimalDegreesValue>
            <remarks>
            The dictionary is a quick way to access your InternalFeatures. You can easily add,
            remove or edit features in this dictionary and they instantly take effect in the layer.
            You can always use the EditTools to do the same thing, but this is a shortcut, as
            the data is backed in memory so it is very pliable.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.InMemoryFeatureLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In InMemoryFeatureLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoFont">
            <summary>
            This class represents a font that is used to label features on a
            GeoCanvas.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoFont.#ctor">
            <overloads>This overload creates the GeoFont using its default property values.</overloads>
            <remarks>None</remarks>
            <summary>
            This constructor creates a GeoFont to be used for labeling features on a
            GeoCanvas.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoFont.#ctor(System.String,System.Single)">
            <summary>
            This constructor creates a GeoFont to be used for labeling features on a
            GeoCanvas.
            </summary>
            <overloads>
            This overload creates the GeoFont by specifying the font name and font
            size.
            </overloads>
            <remarks>None</remarks>
            <param name="fontName">This parameter represents the name of the font to be used.</param>
            <param name="size">This parameter represents the size of the font to be used.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null or empty string as the fontName, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a size value that is not greater than zero, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoFont.#ctor(System.String,System.Single,ThinkGeo.MapSuite.Core.DrawingFontStyles)">
            <summary>
            This constructor creates a GeoFont to be used for labeling features on a
            GeoCanvas.
            </summary>
            <overloads>
            This overload creates the GeoFont by specifying the font name, font size and font
            style.
            </overloads>
            <remarks>None</remarks>
            <param name="fontName">This parameter represents the name of the font to be used.</param>
            <param name="size">This parameter represents the size of the font to be used.</param>
            <param name="style">This parameter represents the style of the font to be used.</param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null or empty string as the fontName, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a size value that is not greater than zero, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a style that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoFont.IsBold">
            <summary>This property gets the bold property of the font.</summary>
            <value>This property gets the bold property of the font.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoFont.IsStrikeout">
            <summary>This property gets the strikeout property of the font.</summary>
            <value>This property gets the strikeout property of the font.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoFont.IsItalic">
            <summary>This property gets the italic property of the font.</summary>
            <value>This property gets the italic property of the font.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoFont.IsUnderline">
            <summary>This property gets the underline property of the font.</summary>
            <value>This property gets the underline property of the font.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoFont.FontName">
            <summary>This property gets the font name property of the font.</summary>
            <value>This property gets the font name property of the font.</value>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null or empty string as the FontName, we will throw an ArgumentNullException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoFont.Size">
            <summary>This property gets the font size property of the font.</summary>
            <value>This property gets the font size property of the font.</value>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a size value that is not greater than zero, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoFont.Style">
            <summary>This property gets the font style property of the font.</summary>
            <value>This property gets the font style property of the font.</value>
            <remarks>None</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a Style that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DrawingFontStyles">
            <summary>This enumeration specifies the type of font style for drawing text.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingFontStyles.Regular">
            <summary>This member represents standard text.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingFontStyles.Bold">
            <summary>This member represents bold text.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingFontStyles.Italic">
            <summary>This member represents italic text.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingFontStyles.Underline">
            <summary>This member represents underlined text.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingFontStyles.Strikeout">
            <summary>This member represents strikeout text.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GdiPlusRasterSource">
            <summary>
            This class allows you to view standard .NET GDI+ image types such as BMP, TIF,
            JPG, and PNG.
            </summary>
            <remarks>
            This class handles all default supported image types of GDI+. As none of these
            types embed geographic information in them, you will need to ensure that the image file
            is always accompanied by a world file. The world file is text file that stores the
            associated geographic information we need to properly display the image along with your
            other feature data.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.#ctor">
            <summary>This is the constructor the for the class.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.#ctor(System.String)">
            <summary>This is the constructor the for the class.</summary>
            <overloads>
            This constructor allows you to pass in a path and filename for the image you
            want to load.
            </overloads>
            <returns>None</returns>
            <remarks>
            You can specify a path and filename that does not actually exist if you use the
            StreamLoading event. This event only uses the PathFileName parameter as a unique string
            that will be passed to you in the event, so that you can determine what stream you want
            to pass back.
            </remarks>
            <param name="imagePathFilename">This parameter represents the image you want to load.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.#ctor(System.String,System.String)">
            <summary>This is the constructor the for the class.</summary>
            <overloads>
            This constructor allows you to pass in a path and filename, and a world file path and filename, for the image you
            want to load.
            </overloads>
            <returns>None</returns>
            <remarks>
            You can specify a path and filename that does not actually exist if you use the
            StreamLoading event. This event only uses the PathFileName parameter as a unique string
            that will be passed to you in the event, so that you can determine what stream you want
            to pass back.
            </remarks>
            <param name="imagePathFilename">This parameter represents the image you want to load.</param>
            <param name="worldfilePathFilename">This parameter represents the world file path and filename you want to load.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.#ctor(System.String,ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This is the constructor the for the class.</summary>
            <overloads>
            This constructor allows you to pass in a path, filename and extent for the image you
            want to load.
            </overloads>
            <returns>None</returns>
            <remarks>
            You can specify a path and filename that does not actually exist if you use the
            StreamLoading event. This event only uses the PathFileName parameter as a unique string
            that will be passed to you in the event, so that you can determine what stream you want
            to pass back.
            </remarks>
            <param name="imagePathFilename">This parameter represents the image you want to load.</param>
            <param name="imageExtent">This parameter represents the extnet of the image you want to load.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.OnStreamLoading(ThinkGeo.MapSuite.Core.StreamLoadingEventArgs)">
            <summary>This method allows you to raise the StreamLoading event.</summary>
            <returns>None</returns>
            <remarks>
            This method allows you to raise the StreamLoading event. Normally events are not
            accessible to derived classes, so we exposed a way to raise the event as necessary
            through this protected method.
            </remarks>
            <param name="e">
            This parameter represents the event arguments you want to raise the StreamLoading
            event with.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.GetImageWidthCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the width of the image in screen coordinates.</summary>
            <returns>This method returns the width of the image in screen coordinates.</returns>
            <remarks>This method returns the width of the image in screen coordinates.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.GetImageHeightCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the height of the image in screen coordinates.</summary>
            <returns>This method returns the height of the image in screen coordinates.</returns>
            <remarks>This method returns the height of the image in screen coordinates.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.OpenCore">
            <summary>
            This method opens the ImageSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concrete public method Open.
            The Open method plays an important role, as it is responsible for initializing the
            ImageSource. Most methods on the ImageSource will throw an exception if the state of
            the ImageSource is not opened. When the map draws each layer, it will open the
            ImageSource as one of its first steps; then, after it is finished drawing with that
            layer, it will close it. In this way, we are sure to release all resources used by the
            ImageSource.<br/>
            	<br/>
            When implementing this abstract method, consider opening files for file-based sources,
            connecting to databases in the database-based sources and so on. You will get a chance
            to close these in the Close method of the ImageSource.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has already been opened, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.NotSupportedException" caption="NotSupportedException">If the file format you passed is not one of these: .bmp, .gif, .exig, .jpg, .png, or .tiff, we will throw a NotSupportedException.</exception>
            <exception cref="T:System.IO.FileNotFoundException" caption="FileNotFoundException">If the world file cannot be found using the filename you passed, we will throw an FileNotFoundException when the source is not from a stream.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.CloseCore">
            <summary>
            This method opens the ImageSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concrete public method Close.
            The Close method plays an important role in the life cycle of the ImageSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            If you override this method, it is recommended that that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed FeatureSource is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.GetImageCore(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass in a worldExtent that is invalid, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a worldExtent that is invalid, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image width that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a image height that is smaller than or equal to 0, we will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <remarks>
            This method is responsible for returning the image based on the parameters passed
            in.
            </remarks>
            <summary>
            This method returns an image based on the worldExtent, image width and
            image height.
            </summary>
            <returns>
            This method returns an image based on the worldExtent, image width and
            image height.
            </returns>
            <param name="worldExtent">This parameter represents the worldExtent you want to draw.</param>
            <param name="canvasWidth">This parameter represents the width of the image you want to draw.</param>
            <param name="canvasHeight">This parameter represents the height of the image you want to draw.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a image source which has not been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method returns the bounding box of the RasterSource.</summary>
            <returns>This method returns the bounding box of the RasterSource.</returns>
            <remarks>This method returns the bounding box of the RasterSource.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.BlueComponent">
            <summary>This property gets and sets the blue decimalDegreesValue of the image.</summary>
            <decimalDegreesValue>This property gets the blue decimalDegreesValue of the image.</decimalDegreesValue>
            <remarks>
            This property allows you to modify the color saturation of the image. Valid
            values are between -255 and 255.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.RedComponent">
            <summary>This property gets and sets the red decimalDegreesValue of the image.</summary>
            <decimalDegreesValue>This property gets the red decimalDegreesValue of the image.</decimalDegreesValue>
            <remarks>
            This property allows you to modify the color saturation of the image. Valid
            values are between -255 and 255.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.GreenComponent">
            <summary>This property gets and sets the green decimalDegreesValue of the image.</summary>
            <decimalDegreesValue>This property gets the green decimalDegreesValue of the image.</decimalDegreesValue>
            <remarks>
            This property allows you to modify the color saturation of the image. Valid
            values are between -255 and 255.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.IsNegative">
            <summary>This property gets and sets whether the image shows as negative (inverted colors).</summary>
            <decimalDegreesValue>This property gets whether the image shows as negative (inverted colors).</decimalDegreesValue>
            <remarks>You can set this property to show the negative of the image.</remarks>        
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.IsGrayscale">
            <summary>This property gets and sets whether the image shows in grayscale.</summary>
            <decimalDegreesValue>This property gets whether the image shows in grayscale.</decimalDegreesValue>
            <remarks>This property allows you to show the image in grayscale.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.AlphaComponent">
            <summary>This property gets and sets the transparency decimalDegreesValue of the image.</summary>
            <decimalDegreesValue>This property gets the transparency decimalDegreesValue of the image.</decimalDegreesValue>
            <remarks>
            This property allows you to make the image opaque or semi transparent. Valid
            values range from 0 to 255.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.FileName">
            <summary>This property returns the filename part of the PathFileName.</summary>
            <decimalDegreesValue>This property returns the filename part of the PathFileName.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.FilePath">
            <summary>This property returns the path part of the PathFileName.</summary>
            <decimalDegreesValue>This property returns the path part of the PathFileName.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.PathFilename">
            <summary>
            This property returns the path and filename of the image you want to
            represent.
            </summary>
            <decimalDegreesValue>
            This property returns the path and filename of the image you want to
            represent.
            </decimalDegreesValue>
            <remarks>
            When you specify the path and filename, it should be in the correct format as
            such; however, the file does not need to actually exist on the file system. This is to allow us
            to accept streams supplied by the developer at runtime. If you choose to provide a file
            that exists, we will attempt to use it. If we cannot find it, then we will raise the
            SteamLoading event and allow you to supply the stream. For example, you can pass in
            "C:\NotARealPath\File1.jpg" which does not exist on the file system. When we raise the
            event for you to supply a stream, we will pass to you the path and filename so you can
            differentiate the files.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Setting an invalid FilePathName structure will throw an ArgumentException.</exception>
        </member>
        <member name="E:ThinkGeo.MapSuite.Core.GdiPlusRasterSource.StreamLoading">
            <summary>
            This event allows you to pass in your own stream to represent the
            image.
            </summary>
            <remarks>
            If you wish, you can pass in your own stream to represent the image. The
            stream can come from a variety of places, including isolated storage, a compressed file,
            or an encrypted stream. When the image is finished with the stream it will dispose
            of it, so be sure to keep this in mind when passing the stream in. If you do not pass in
            an alternate stream, the class will attempt to load the file from the file system
            using the PathFileName property.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer">
            <summary>This class represents a layer backed by Microsoft SQL 2008.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>This is the default constructor, but it is not typically used.</overloads>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer.#ctor(System.String,System.String,System.String)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in all of the data to create the
            Layer.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="connectionString">This parameter represents the connection string that will be used to connect to the server.</param>
            <param name="tableName">This parameter represents the table name being accessed.</param>
            <param name="featureIdColumn">
            This parameter represents the name of the column that holds the unique feature
            Id.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer.#ctor(System.String,System.String,System.String,System.Int32)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in all of the data to create the
            Layer.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="connectionString">This parameter represents the connection string that will be used to connect to the server.</param>
            <param name="tableName">This parameter represents the table name being accessed.</param>
            <param name="featureIdColumn">
            This parameter represents the name of the column that holds the unique feature
            Id.
            </param>
            <param name="srid">Specify what kind srid data to be used.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer.Validate">
            <summary>
            Check if all geometry are valid for spatial query.
            </summary>
            <returns>If all geometry are valid, the count of the returning dictionary is 0.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer.BuildIndex(ThinkGeo.MapSuite.Core.BuildIndexMode)">
            <summary>
            Build Spatial index
            </summary>
            <param name="buildIndexMode">Build Index Mode</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer.MakeAllGeometriesValid">
            <summary>
            To make the geometry type data valid, and update the table.
            </summary>
            <remarks>
                This function will check whether the geometry is valid for spatial query,
                if it is not, then the function will make it valid and save it back to the 
                table.
                For example: Here's a invalid LineString LINESTRING(0 2,1 1,1 0,1 1,2 2))
                which is overlaps itself, it's invalid. After use this function, it will be 
                MULTILINESTRING((0 2,1 1,2 2),(1 1,1 0))
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer.GetFirstGeometryType">
            <summary>
            Get The shape type from the first record.
            </summary>
            <returns>The shape type of the first record.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer.ExecuteNonQuery(System.String)">
            <summary>This method executes a query that does not return a SQL result.</summary>
            <returns>None</returns>
            <remarks>This methods executes a query that has no results.</remarks>
            <param name="sqlStatement">This parameter represents the SQL statement that will be executed.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer.CommandTimeout">
            <summary>
            This property gets and sets the amount of time that can elapse before the command will
            timeout and abort.
            </summary>
            <value>
            This property gets the amount of time that can elapse before the command will timeout and
            abort.
            </value>
            <remarks>You can use this to set a time limit for the query before it times out.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer.ConnectionString">
            <summary>
            This property gets and sets the connection string that will be used to connect to the
            server.
            </summary>
            <value>This property gets the connection string that will be used to connect to the server.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer.TableName">
            <summary>This property gets or sets the table name that the database will use.</summary>
            <value>This property gets the table name that the database will use.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In MsSql2008FeatureLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer.Srid">
            <summary>
            Specify what kind srid data to be used.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MsSql2008FeatureLayer.FeatureIdColumn">
            <summary>
            This property gets or sets the name of the column that holds the unique feature
            Id.
            </summary>
            <value>
            This property gets the name of the column that holds the unique feature
            Id.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.NodeElement">
            <summary>
            Structure that holds NodeElement.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileBoundingBox.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.ShapeFileBoundingBox.MergeBoundingBox(ThinkGeo.MapSuite.Core.ShapeFileBoundingBox)">
            <summary>
            merge the input Bounding Box, store the result
            </summary>
            <param name="targetBox">the input BoundingBox to be merged</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.QualityFamilyAreaStyle">
            <summary>This class is used to draw area features.</summary>
            <remarks>
            You should use this class to draw area features. You can specify a base color and the number of 
            colors you want based on that color to draw the interior, and you can specify an outline pen
            with which to draw the border. You can optionally choose to
            use only the outline pen or the fill brush to generate different effects.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QualityFamilyAreaStyle.#ctor">
            <summary>This is the constructor the for the class. If you use this constructor, then you need to set
            the required properties manually.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QualityFamilyAreaStyle.#ctor(ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoColor,System.Int32)">
            <summary>This is the constructor the for the class.</summary>
            <overloads>This is the constructor for this class.</overloads>
            <returns>None</returns>
            <remarks>None.</remarks>
            <param name="outlinePen">This parameter represents the outline pen that will be used on the style.</param>
            <param name="baseColor">This parameter represents the base color that will be used in the class.</param>
            <param name="numberOfColors">
            This prameter represents how many colors will be used in the style, based on the
            base color.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QualityFamilyAreaStyle.#ctor(ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoColor,System.Int32,ThinkGeo.MapSuite.Core.PenBrushDrawingOrder)">
            <summary>This is the constructor the for the class.</summary>
            <overloads>This is the constructor for this class.</overloads>
            <returns>None</returns>
            <remarks>None.</remarks>
            <param name="outlinePen">This parameter represents the outline pen that will be used on the style.</param>
            <param name="baseColor">This parameter represents the base color that will be used in the class.</param>
            <param name="numberOfColors">
            This prameter represents how many colors will be used in the style, based on the
            base color.
            </param>
            <param name="penBrushDrawingOrder">This parameter describes the PenBrushDrawingOrder that will be used when drawing the area type feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QualityFamilyAreaStyle.ClearCache">
            <summary>This method clears the cached style in the cache.</summary>
            <returns>None.</returns>
            <remarks>This method clears the cached style in the cache.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.QualityFamilyAreaStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If OutlinePen is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If FillSolidBrush is null, we will throw an ArgumentNullException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.QualityFamilyAreaStyle.NumberOfColors">
            <summary>This gets or sets the number of colors in the style.</summary>
            <value>This gets or sets the number of colors in the style.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.QualityFamilyAreaStyle.Cache">
            <summary>This gets the cached style in the class.</summary>
            <value>This gets the cached style in the class.</value>
            <remarks>
            This gets the cached style in the class. The key of the style in the cache is
            feature.Id &amp; feature.GetHashCode().
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.QualityFamilyAreaStyle.BaseColor">
            <summary>This gets or sets the base color of the style.</summary>
            <value>This gets or sets the base color of the style.</value>
            <remarks>None.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.TileMatrixCell">
            <summary>
            This structure represents the TileMatrixCell  which will be used in the TileMatrix system.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileMatrixCell.#ctor(System.Int64,System.Int64,ThinkGeo.MapSuite.Core.RectangleShape)">
            <summary>This is the constructor used to create a TileMatrixCell.</summary>
            <remarks>None</remarks>
            <param name="row">This parameter represents the row number of the TileMatrixCell.</param>
            <param name="column">This parameter represents the column number of the TileMatrixCell.</param>
            <param name="boundingBox">This parameter represents the boundingBox of the TileMatrixCell.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileMatrixCell.ToString">
            <summary>This method is an override of the ToString functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileMatrixCell.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileMatrixCell.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileMatrixCell.op_Equality(ThinkGeo.MapSuite.Core.TileMatrixCell,ThinkGeo.MapSuite.Core.TileMatrixCell)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <param name="cell1">This parameter represents the first TileMatrixCell to compare.</param>
            <param name="cell2">This parameter represents the second TileMatrixCell to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileMatrixCell.op_Inequality(ThinkGeo.MapSuite.Core.TileMatrixCell,ThinkGeo.MapSuite.Core.TileMatrixCell)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <param name="cell1">This parameter represents the first TileMatrixCell to compare.</param>
            <param name="cell2">This parameter represents the second TileMatrixCell to compare.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileMatrixCell.Row">
            <summary>
            This property gets or sets the Row number of the stucture.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileMatrixCell.Column">
            <summary>
            This property gets or sets the Column number of the stucture.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileMatrixCell.BoundingBox">
            <summary>
            This property gets or sets the BoundingBox of the stucture.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Unit.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,ThinkGeo.MapSuite.Core.PJUnit})">
             <summary>
            Constructor of Unit
             </summary>
             <param name="args">parameter array</param>
             <param name="pj_Units_List">Hashtable of PJUnit</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Unit.GetUnitID(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Obtain UnitID
            </summary>
            <param name="args">parameter string ditionary</param>
            <returns>id value of PJUnit</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Unit._InitUnit(System.String)">
            <summary>
            If unitID is not null which initialize unit
            </summary>
            <param name="unitID">obtain id value of PJUnit</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Unit.CurrentUnit">
            <summary>
            obtain PJUnit object of corresponding ID 
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataInstance.#ctor">
            <summary>
            get the instances of specified
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DataInstance.GetProjType(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            get a ProjType instance
            </summary>
            <param name="projID">ProjID in proj.xml</param>
            <param name="desc">the string of description</param>
            <returns>the ProjType instance</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.RegexStyle">
            <remarks>
            	<para>RegexStyle:</para>
            	<para>The RegexStyle allows you to use complex regular expression matching to determine how
                your features are drawn. A regular expression is a matching syntax that allows you to
                match a string based on very complex criteria. For example, let's say you have a layer that has a
                column in the data that contains school names. Most school names include the type of school
                they are. For instance, you may have "Lincoln Middle School" or "Bush High School." There are
                variations to these names though, containing words such as "Elementary" or "Prep." With a regular
                expression, you can create matching criteria that will allow you to match on many
                variations of the names. It is especially useful for fuzzy matches where your data is
                not clearly categorized. Another classic example is for matching or validating email
                addresses, where matching rules can become complex.</para>
            	<para>In the RegexStyle, you specify the matching criteria string and also the style you want
                to use to draw the feature if the criteria matches. It is a simple yet powerful style
                for dealing with complex rule sets and imprecise data.</para>
            </remarks>
            <summary>
            This class allows you to draw features differently based on regular expression
            matching.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RegexStyle.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor for the class. If you use this constructor, you
            need to set the various properties manually.
            </overloads>
            <remarks>
            If you use this constructor, you need to set the various properties
            manually.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RegexStyle.#ctor(System.String,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.RegexItem})">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you specify the columnName and regexItems for the class.  You
            can also set the various properties manually.
            </overloads>
            <remarks>
            None.
            </remarks>
            <returns>None</returns>
             <param name="columnName">This parameter is the columnName you want to use in the style.</param>
             <param name="regexItems">This parameter specifies the regexItems in the style.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RegexStyle.#ctor(System.String,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.RegexItem},ThinkGeo.MapSuite.Core.RegexMatching)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you specify the columnName, regexItems and regexMatching rule for the class. You
            can also set the various properties manually.
            </overloads>
            <remarks>
            None.
            </remarks>
            <returns>None</returns>
             <param name="columnName">This parameter is the columnName you want to use in the style.</param>
             <param name="regexItems">This parameter specifies the regexItems in the style.</param>
             <param name="regexMatching">This parameter specifies the regexMatching rule for the style.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RegexStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style based on its properties may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If columnName is null, we will throw an ArgumentNullException.</exception>        
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.RegexStyle.GetRequiredColumnNamesCore">
            <remarks>
            This abstract method is called from the concrete public method
            GetRequiredFieldNames. In this method, we return the column names that are required for
            the style to draw the feature properly. For example, if you have a style that colors
            areas blue when a certain column value is over 100, then you need to be sure you include
            that column name. This will ensure that the column data is returned to you in the
            feature when it is ready to draw.<br/>
            	<br/>
            In many of the styles, we add properties to allow the user to specify which field they
            need; then, in the GetRequiredColumnNamesCore, we read that property and add it to the
            collection.
            </remarks>
            <summary>
            This method returns the column data for each feature that is required for the
            style to properly draw.
            </summary>
            <returns>This method returns a collection of the column names that it needs.</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If columnName is null, we will throw an ArgumentNullException.</exception>        
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RegexStyle.RegexMatchingRule">
            <summary>
            This property gets and sets the regular expression matching rule. The rule
            determines whether we match the entire string or just any portion of it.
            </summary>
            <value>This property gets the regular expression matching rule.</value>
            <remarks>
            This is used to determine how much of a string needs to match a regular expression in order
            to declare it a match for that expression.
            Sometimes, you only need one part of the string to match in order for the expression to
            be considered a match; other times you may want the entire string to match.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RegexStyle.ColumnName">
            <summary>
            This property gets and sets the column name whose value will be tested against the regular
            expression.
            </summary>
            <value>
            This property gets the column name whose value will be tested against the regular
            expression.
            </value>
            <remarks>This is the column we use for matching.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.RegexStyle.RegexItems">
            <summary>
            This property gets the collection of RegexItems. Each item can have its own
            regular expression to match.
            </summary>
            <value>This property gets the collection of RegexItems.</value>
            <remarks>
            You will want to add RegexItems to this collection. Each item can have its own
            style and matching string.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PointStyle">
            <summary>This class allows you to define how points are drawn on the canvas.</summary>
            <remarks>
            This class allows you to define how points are drawn on the canvas. There are
            three main drawing types: bitmap, character, and symbol. The bitmap allows you to
            represent each point with a bitmap. The character allows you to choose a font and an
            index in the font so you can use that character for the point. This is especially helpful
            with fonts like Wingdings that have many feature-style graphics. The symbol type is a
            collection of simple geometric symbols that we have assembled to represent abstract
            items on the map.<br/>
            	<br/>
            When you select a PointType, you need to be sure to set the various properties
            associated with that type. The property names are prefixed to help you. For example, all
            of the character-related properties are prefixed with "Character" and the symbol properties
            follow a similar pattern.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyle.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, you should set the
            various properties manually.
            </overloads>
            <remarks>
            If you use this constructor, you should set the various properties manually.
            Specifically, you will want to set the PointType, which allows you to choose between
            bitmap, character and symbol as an option for displaying your points.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyle.#ctor(ThinkGeo.MapSuite.Core.GeoImage)">
            <summary>This is a constructor for the class.</summary>
            <overloads>This constructor is used for bitmap based points.</overloads>
            <returns>None</returns>
            <remarks>If you use this constructor, the PointStyle will be set to Bitmap.</remarks>
            <param name="image">
            This parameter is the GeoImage of the image you want to use to display the
            point.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyle.#ctor(ThinkGeo.MapSuite.Core.GeoFont,System.Int32,ThinkGeo.MapSuite.Core.GeoSolidBrush)">
            <summary>This is a constructor for the class.</summary>
            <overloads>This constructor is used for character based points.</overloads>
            <returns>None</returns>
            <remarks>If you use this constructor, the PointStyle will be set to Character.</remarks>
            <param name="characterFont">This parameter is the font from which the character will be selected.</param>
            <param name="characterIndex">This parameter is the index of the character in the chosen font.</param>
            <param name="characterSolidBrush">This parameter is the SolidBrush used to draw the character.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyle.#ctor(ThinkGeo.MapSuite.Core.PointSymbolType,ThinkGeo.MapSuite.Core.GeoSolidBrush,System.Int32)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor is used for symbol-based points (such as squares and circles) with
            only a fill.
            </overloads>
            <returns>None</returns>
            <remarks>If you use this constructor, the PointStyle will be set to Symbol.</remarks>
            <param name="symbolType">
            This parameter is the type of symbol you want to use, such as a square or a
            circle.
            </param>
            <param name="symbolSolidBrush">
            This parameter is the SolidBrush you want to use to fill the inside of the
            symbol.
            </param>
            <param name="symbolSize">This parameter is the size you want the symbol to be.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyle.#ctor(ThinkGeo.MapSuite.Core.PointSymbolType,ThinkGeo.MapSuite.Core.GeoSolidBrush,ThinkGeo.MapSuite.Core.GeoPen,System.Int32)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor is used for symbol-based points (such as squares and circles) with
            a fill and outline.
            </overloads>
            <returns>None</returns>
            <remarks>If you use this constructor, the PointStyle will be set to Symbol.</remarks>
            <param name="symbolType">
            This parameter is the type of symbol you want to use, such as a square or a
            circle.
            </param>
            <param name="symbolSolidBrush">
            This parameter is the SolidBrush you want to use to fill the inside of the
            symbol.
            </param>
            <param name="symbolPen">This parameter is the Pen used to draw the outline of the symbol.</param>
            <param name="symbolSize">This parameter is the size you want the symbol to be.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If symbolPen is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If symbolSolidBrush is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If characterSolidBrush is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If characterFont is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a pointSymbolType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a pointType that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a imageScale that is less or equal to 0, it will throw an ArgumentOutOfRangeException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointStyle.DrawSampleCore(ThinkGeo.MapSuite.Core.GeoCanvas)">
            <summary>This method draws a sample feature on the canvas you provided.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. In this
            method, we draw a sample style on the canvas you provided. This is typically used to
            display a legend or other sample area.<br/>
            	<br/>
            When implementing this virtual method, consider the canvas size and draw the sample
            image appropriately. You should keep in mind that the sample typically shows up on a
            legend.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.XOffsetInPixel">
            <summary>This property gets and sets the X pixel offset for drawing each feature.</summary>
            <value>This property gets the X pixel offset for drawing each feature.</value>
            <remarks>
            This property allows you to specify an X offset. When combined with a Y offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.YOffsetInPixel">
            <summary>This property gets and sets the Y pixel offset for drawing each feature.</summary>
            <value>This property gets the Y pixel offset for drawing each feature.</value>
            <remarks>
            This property allows you to specify a Y offset. When combined with an X offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.CustomPointStyles">
            <summary>
            This property returns a collection of area styles allowing you to stack multiple
            area styles on top of each other.
            </summary>
            <value>This property returns a collection of area styles.</value>
            <remarks>
            Using this collection, you can stack multiple styles on top of each other.
            When we draw the feature, we will draw them in order that they exist in the collection. You can use
            these stacks to create drop shadow effects, multiple colored outlines,
            etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.PointType">
            <summary>This property gets and sets the type of point you want to draw.</summary>
            <value>This property gets the type of point you want to draw.</value>
            <remarks>
            When using the PointStyle you choose between a bitmap, a font or a predefined symbol
            to represent the point. Each of these options has corresponding properties on the point
            symbol. If you set the type to character, then you need to set the properties that start
            with "Character," such as "CharacterFont." The same is true for the symbol.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.RotationAngle">
            <summary>
            This property gets and sets the angle of rotation for the drawing of the
            point.
            </summary>
            <value>This property gets the angle of rotation for the drawing of the point.</value>
            <remarks>
            This property controls the rotation of the bitmap, character or symbol, depending
            on the PointType.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.Image">
            <summary>
            This property gets and sets the image used if the PointType property is
            Bitmap.
            </summary>
            <value>This property gets the image used if the PointType property is Bitmap.</value>
            <remarks>
            This property is where you can set the image for the points if the PointType is
            Bitmap. It uses a GeoImage, so you can either reference a file or supply a
            stream.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.ImageScale">
            <summary>This property gets and sets the scale of the image you want to draw.</summary>
            <value>This property gets the scale of the image you want to draw.</value>
            <remarks>
            This property allows you to scale the image up and down depending on how large or
            small you want it. It can be changed dynamically, so you could change it at every scale
            level to resize the bitmap based on the current scale. A scale of 1 would be the original size,
            while a scale of 2 would double the size. A scale of .5 would reduce the size of the image by half,
            and so on.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.CharacterFont">
            <summary>
            This property gets and sets the font that is used for the character if the
            PointType is Character.
            </summary>
            <value>
            This property gets the font that is used for the character if the PointType is
            Character.
            </value>
            <remarks>
            This property allows you to set the font from which to select a character index if you choose the
            Character PointType.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.CharacterIndex">
            <summary>
            This property gets and sets the index position of the character you want to use
            from the font you selected in the CharacterFont property.
            </summary>
            <value>
            This property gets the index position of the character you want to use from the
            font you selected in the CharacterFont property.
            </value>
            <remarks>
            You need to specify the index position of the character you want to use from the
            font you selected. For example, if you choose 1, then we will use the first character in
            the font you set in the CharacterFont property.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.CharacterSolidBrush">
            <summary>
            This property gets and sets the SolidBrush used to color the font character for
            the point.
            </summary>
            <value>
            This property gets the SolidBrush used to color the font character for the
            point.
            </value>
            <remarks>
            This brush is used to draw the character. It is only used if the PointType is
            Character. If you need a brush other than the SolidBrush, you should look in the
            advanced property of the class.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.SymbolType">
            <summary>
            This property gets and sets the type of symbol you want to use if the PointType
            is Symbol.
            </summary>
            <value>
            This property gets the type of symbol you want to use if the PointType is
            Symbol.
            </value>
            <remarks>
            You can choose between a number of predefined symbols. The symbols are simple
            geometric objects that are typically used for abstract representations on a map. If there is
            a specific symbol you need that is not part of our symbol collection, you can submit it to us
            and we will consider adding it.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.SymbolSolidBrush">
            <summary>
            This property gets and sets the SolidBrush used to color the interior of the
            Symbol.
            </summary>
            <remarks>
            This brush is used to draw the interior of the symbol. It is only used if the
            PointType is Symbol. If you need a brush other than the SolidBrush, you should look in
            the advanced property of the class.
            </remarks>
            <value>
            This property gets the SolidBrush used to color the interior of the
            Symbol.
            </value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.SymbolPen">
            <summary>
            This property gets and sets the SolidBrush used to draw the oultine of the
            Symbol.
            </summary>
            <value>This property gets the SolidBrush used to draw the outline of the Symbol.</value>
            <remarks>
            This pen is used to draw the outline of the Symbol. By default the pen draws a
            transparent (invisible) color, which just leaves you with a fill.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.SymbolSize">
            <summary>
            This property gets and sets the size of the symbol if the PointType is
            Symbol.
            </summary>
            <value>This property gets the size of the symbol if the PointType is Symbol.</value>
            <remarks>The allows you to make the symbol larger and smaller.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointStyle.Advanced">
            <summary>This property gets the advanced properties of the PointStyle.</summary>
            <value>This property gets the advanced properties of the PointStyle.</value>
            <remarks>This allows you to set the advanced properties of the style.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LineStyle">
            <summary>This class is the style used to draw lines.</summary>
            <remarks>
            This class is commonly used to draw lines on the GeoCanvas. It is specialized for
            drawing roads, as this is the main kind of line feature that is most often drawn. You can set an inner,
            outer and center pen to give you a nice effect. The outer pen draws first, and should
            typically be black and larger then the inner pen. The inner pen draws next, and should
            be set as the color of the road you want. It should be thinner than the outer pen. The
            center pen draws last, and is used to represent a centerline in the road. We suggest that you
            only use the center pen for highways at low zoom level, as the dashed pen has some performance
            penalties.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineStyle.#ctor">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineStyle.#ctor(ThinkGeo.MapSuite.Core.GeoPen)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <overloads>
            This constructor allows you to pass in a single outer pen. Use this when you do
            not need any additional pens to draw the feature.
            </overloads>
            <remarks>Use this when you do not need any additional pens to draw the feature.</remarks>
            <param name="outerPen">This parameter is the outer pen used to draw the feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineStyle.#ctor(ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoPen)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <overloads>
            This constructor allows you to pass in an outer and inner pen. This is common for
            drawing roads.
            </overloads>
            <remarks>This is a common constructor for drawing roads.</remarks>
            <param name="outerPen">This parameter is the outer pen used to draw the feature.</param>
            <param name="innerPen">This parameter is the inner pen used to draw the feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineStyle.#ctor(ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoPen,ThinkGeo.MapSuite.Core.GeoPen)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <overloads>
            This constructor allows you to pass in an outer, inner and center pen. This is
            common for drawing low level highways with center lines.
            </overloads>
            <remarks>This is common for drawing low level highways with center lines.</remarks>
            <param name="outerPen">This parameter is the outer pen used to draw the feature.</param>
            <param name="innerPen">This parameter is the inner pen used to draw the feature.</param>
            <param name="centerPen">This parameter is the center pen used to draw the feature.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineStyle.DrawCore(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.Feature},ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate},System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the features on the canvas you provided.</summary>
            <remarks>
            This overridden method is called from the concrete public method Draw. In this
            method, we take the features you passed in and draw them on the canvas you provided.
            Each style (based on its properties) may draw each feature differently.<br/>
            	<br/>
            	<br/>
            When overriding this method, consider each feature and its column data values. You can
            use the full power of the GeoCanvas to do the drawing. If you need column data for a
            feature, be sure to override the GetRequiredColumnNamesCore and add the columns you need
            to the collection. In many of the styles, we add properties to allow the user to specify
            which field they need; then, in the GetRequiredColumnNamesCore, we read that property and
            add it to the collection.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the features, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If OuterPen is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If InnerPen is null, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If CenterPen is null, we will throw an ArgumentNullException.</exception>
            <param name="features">This parameter represents the features you want to draw on the canvas.</param>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
            <param name="labelsInThisLayer">The labels will be drawn in the current layer only.</param>
            <param name="labelsInAllLayers">The labels will be drawn in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineStyle.DrawSampleCore(ThinkGeo.MapSuite.Core.GeoCanvas)">
            <summary>This method draws a sample feature on the canvas you provided.</summary>
            <remarks>
            This virtual method is called from the concrete public method Draw. In this
            method, we draw a sample style on the canvas you provided. This is typically used to
            display a legend or other sample area.<br/>
            	<br/>
            When implementing this virtual method, consider the canvas size and draw the sample
            image appropriately. You should keep in mind that the sample typically shows up on a
            legend.
            </remarks>
            <returns>None</returns>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the canvas, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method when the GeoCanvas's IsDrawing mode is false, it will throw an InvalidOperationException.</exception>
            <param name="canvas">This parameter represents the canvas you want to draw the features on.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyle.XOffsetInPixel">
            <summary>This property gets and sets the X pixel offset for drawing each feature.</summary>
            <value>This property gets the X pixel offset for drawing each feature.</value>
            <remarks>
            This property allows you to specify an X offset. When combined with a Y offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyle.YOffsetInPixel">
            <summary>This property gets and sets the Y pixel offset for drawing each feature.</summary>
            <value>This property gets the Y pixel offset for drawing each feature.</value>
            <remarks>
            This property allows you to specify an Y offset. When combined with an X offset, it is
            useful to allow you to achieve effects such as drop shadows, etc. There also may be times
            when you need to modify the location of feature data so as to better align it with raster
            satellite data.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyle.CustomLineStyles">
            <summary>
            This property returns a collection of line styles, allowing you to stack multiple
            line styles on top of each other.
            </summary>
            <value>This property returns a collection of line styles.</value>
            <remarks>
            Using this collection, you can stack multiple styles on top of each other.
            When we draw the feature, we will draw them in order that they exist in the collection. You can use
            these stacks to create drop shadow effects, multiple colored outlines,
            etc.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyle.OuterPen">
            <summary>This property gets and sets the outer pen for the line.</summary>
            <value>This property gets the outer pen for the line.</value>
            <remarks>
            You can set an inner,
            outer and center pen to give you a nice effect. The outer pen draws first, and should
            typically be black and larger then the inner pen. The inner pen draws next, and should
            be set as the color of the road you want. It should be thinner than the outer pen. The
            center pen draws last, and is used to represent a centerline in the road. We suggest that you
            only use the center pen for highways at low zoom level, as the dashed pen has some performance
            penalties.
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyle.InnerPen">
            <remarks>
            You can set an inner,
            outer and center pen to give you a nice effect. The outer pen draws first, and should
            typically be black and larger then the inner pen. The inner pen draws next, and should
            be set as the color of the road you want. It should be thinner than the outer pen. The
            center pen draws last, and is used to represent a centerline in the road. We suggest that you
            only use the center pen for highways at low zoom level, as the dashed pen has some performance
            penalties.
            </remarks>
            <summary>This property gets and sets the inner pen for the line.</summary>
            <value>This property gets the inner pen for the line.</value>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyle.CenterPen">
            <remarks>
            You can set an inner,
            outer and center pen to give you a nice effect. The outer pen draws first, and should
            typically be black and larger then the inner pen. The inner pen draws next, and should
            be set as the color of the road you want. It should be thinner than the outer pen. The
            center pen draws last, and is used to represent a centerline in the road. We suggest that you
            only use the center pen for highways at low zoom level, as the dashed pen has some performance
            penalties.
            </remarks>
            <summary>This property gets and sets the center pen for the line.</summary>
            <value>This property gets the center pen for the line.</value>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.PointShape">
            <summary>This class represents a single point.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.#ctor">
            <summary>This constructor creates a PointShape.</summary>
            <overloads>This overload creates the PointShape with its default values.</overloads>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.#ctor(System.Double,System.Double)">
            <summary>This constructor create a PointShape.</summary>
            <overloads>This overload creates a PointShape by specifying the X and Y values.</overloads>
            <remarks>None</remarks>
            <param name="x">This parameter represents the X (horizontal) axis.</param>
            <param name="y">This parameter represents the Y (vertical) axis.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.#ctor(System.Double,System.Double,System.Double)">
            <overloads>This overload creates a PointShape by specifying the X,Y, and Z values.</overloads>
            <summary>This constructor create a PointShape.</summary>
            <remarks>None</remarks>
            <param name="x">This parameter represents the X (horizontal) axis.</param>
            <param name="y">This parameter represents the Y (vertical) axis.</param>
            <param name="z">This parameter represents the Z (depth) axis.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.#ctor(ThinkGeo.MapSuite.Core.Vertex)">
            <summary>
            This overload creates a PointShape by specifying the vertex.
            </summary>
            <param name="vertex">This parameter represents the vertex that will be used to construct the PointShape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.#ctor(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This constructor creates the PointShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known text.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.#ctor(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <returns>None</returns>
            <remarks>None</remarks>
            <summary>This constructor creates the PointShape.</summary>
            <overloads>This constructor allows you to build the shape from well-known binary.</overloads>
            <param name="wellKnownBinary">This parameter is the well-known binary used to build the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.Equal2D(ThinkGeo.MapSuite.Core.PointShape)">
            <summary>
            Compare the current PointShape with the target PointShape.
            </summary>
            <param name="targetShape">The targetPointShape to be compared with.</param>
            <returns>True if both X and Y coordinates of the current shape are equal to those of the target shape.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.Equal2D(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            Compare the current PointShape with the target Point Feature.
            </summary>
            <param name="targetPointFeature">The targetPointFeature to be compared with.</param>
            <returns>True if both X and Y coordinates of the current shape are equal to those of the PointShape contained in the target PointFeature.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.CloneDeepCore">
            <remarks>
            When you override this method, you need to ensure that there are no references in
            common between the original and the copy.
            </remarks>
            <summary>
            This method returns a complete copy of the shape without any references in
            common.
            </summary>
            <returns>
            This method returns a complete copy of the shape without any references in
            common.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.RegisterCore(ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.PointShape,ThinkGeo.MapSuite.Core.DistanceUnit,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns a BaseShape which has been registered from its original
            coordinate system to another based on two anchor PointShapes.
            </summary>
            <returns>
            	<para>This method returns a BaseShape which has been registered from its original
                coordinate system to another based on two anchor PointShapes.</para>
            </returns>
            <remarks>
            	<para>Registering allows you to take a geometric shape generated in a planar system
                and attach it to the ground in a Geographic Unit.</para>
            	<para>A common scenario is integrating geometric shapes from external programs
                (such as CAD software or a modeling system) and placing them onto a map. You may have
                the schematics of a building in a CAD system and the relationship between all the
                points of the building are in feet. You want to then take the CAD image and attach
                it to where it really exists on a map. You would use the register method to do
                this.</para>
            	<para>Registering is also useful for scientific modeling, where software models things such
                as a plume of hazardous materials or the fallout from a volcano. The modeling
                software typically generates these models in a fictitious planar system. You would
                then use the register to take the abstract model and attach it to a map with real
                coordinates.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a fromUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a toUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the fromPoint parameter will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the toPoint parameter will throw an ArgumentNullException.</exception>
            <param name="fromPoint">This parameter is the anchor PointShape in the coordinate of origin.</param>
            <param name="toPoint">This parameter is the anchor PointShape in the coordinate of destination.</param>
            <param name="fromUnit">This parameter is the DistanceUnit of the coordinate of origin.</param>
            <param name="toUnit">This parameter is the GeographyUnit of the coordinate of destination.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.TranslateByOffsetCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another based on an X and Y
            offset distance.
            </summary>
            <overloads>
            In this overload, the X and Y offset are based on the DistanceUnit you specify,
            regardless of the shape's GeographicUnit.
            </overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an X
                and Y offset distance. With this overload, it is important to note that the X and Y
                offset units are based on the distanceUnit parameter. For example, if your shape
                is in decimal degrees and you call this method with an X offset of 1 and a Y
                offset of 1, you're going to move this shape 1 unit of the distanceUnit in
                the horizontal direction and one unit of the distanceUnit in the vertical
                direction. In this way, you can easily move a shape in decimal degrees five miles to
                on the X axis and 3 miles on the Y axis.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method from a shape which has no points, it will throw an InvalidOperationException.</exception>
            <param name="xOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="yOffsetDistance">
            This is the number of horizontal units of movement in the DistanceUnit specified as
            the distanceUnit.
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            	<para>This is the DistanceUnit you would like to use as the measure for the
                move. For example, if you select miles as your distanceUnit, then the xOffsetDistance
                and yOffsetDistance will be calculated in miles.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.TranslateByDegreeCore(System.Double,System.Double,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <summary>
            This method moves the base shape from one location to another, based on a
            distance and a direction in degrees.
            </summary>
            <overloads>In this overload, the distance is in the same GeographicUnit as the shape.</overloads>
            <remarks>
            	<para>This method moves the base shape from one location to another, based on an
                angleInDegrees and distance parameter. With this overload, it is important to note
                that the distance units are the same GeographicUnit as the shape. For example,
                if your shape is in decimal degrees and you call this method with a distance of 1,
                you're going to move this shape 1 decimal degree in direction of the
                angleInDegrees. In many cases it is more useful to specify the DistanceUnit of movement,
                such as in miles or yards, so for these scenarios there is another overload you may
                want to use instead.</para>
            	<para>If you pass a distance of 0, then the operation is ignored.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid angleInDegrees which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid distance which is not greater than or equal to 0 will throw an ArgumentOutOfRangeException.</exception>
            <param name="distance">
            The distance is the number of units to move the shape in the angle specified. The
            distance unit will be the same as the GeographyUnit for the shape. The distance must be
            greater than or equal to 0.
            </param>
            <param name="angleInDegrees">
            	<para>A number between 0 and 360 degrees that represents the direction you wish to
                move the shape, with 0 being up.</para>
            </param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.RotateCore(ThinkGeo.MapSuite.Core.PointShape,System.Single)">
            <summary>
            This method rotates the shape a number of degrees based on a pivot
            point.
            </summary>
            <remarks>
            	<para>This method rotates the shape by a number of degrees based on a pivot point.
                By placing the pivot point in the center of the shape, you can achieve in-place
                rotation. By moving the pivot point outside of the center of the shape, you can
                translate the shape in a circular motion. Moving the pivot point further outside of
                the center will make the circular area larger.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the pivotPoint, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">Passing an invalid degreeAngle which is not between 0 and 360 will throw an ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which is not valid, it will throw an InvalidOperationException.</exception>
            <param name="pivotPoint"><para>The pivotPoint represents the center of rotation.</para></param>
            <param name="degreeAngle"><para>The number of degrees of rotation required from 0 to 360.</para></param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.GetClosestPointToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method returns the point of the current shape that is closest to the target
            shape.
            </summary>
            <returns>
            A PointShape representing the closest point of the current shape to the
            targetShape.
            </returns>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <remarks>
            This method returns the point of the current shape that is closest to the target shape.
            It is often the case that the point returned is not a point of the object itself. An
            example would be a line with two points that are far apart from each other. If you set the
            targetShape to be a point midway between the points but a short distance away from the line, the
            method would return a point that is on the line but not either of the two points that make up the
            line.
            </remarks>
            <param name="targetShape"><para>The shape you are trying to find the closest point to.</para></param>
            <param name="shapeUnit">
            	<para>This is the GeographicUnit of the shape you are performing the operation
                on.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.GetWellKnownTextCore">
            <summary>This method returns the well-known text representation of this shape.</summary>
            <returns>This method returns a string that represents the shape in well-known text.</returns>
            <remarks>
            	<para>This method returns a string that represents the shape in well-known text.
                Well-known text allows you to describe a geometry as a string of text. Well-known
                text is useful when you want to save a geometry in a format such as a text file, or when you
                simply want to cut and paste the text between other applications. An alternative
                to well-known text is well-known binary, which is a binary representation of a
                geometry object. We have methods that work with well-known binary as well.
                Below are some samples of what well-known text might look like for various kinds of
                geometric shapes.</para>
            	<para>POINT(5 17)</para>
            	<para>LINESTRING(4 5,10 50,25 80)</para>
            	<para>POLYGON((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3))</para>
            	<para>MULTIPOINT(3.7 9.7,4.9 11.6)</para>
            	<para>MULTILINESTRING((4 5,11 51,21 26),(-4 -7,-9 -7,-14 -3))</para>
            	<para>MULTIPOLYGON(((2 2,6 2,6 6,2 6,2 2),(3 3,4 3,4 4,3 4,3 3)),((4 4,7 3,7 5,4
                4)))</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.GetWellKnownTypeCore">
            <summary>This method returns the well-known type for the shape.</summary>
            <returns>This method returns the well-known type for the shape.</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.LoadFromWellKnownDataCore(System.String)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known text in the wellKnownText parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the wellKnownText parameter will throw an ArgumentNullException.</exception>
            <summary>This method hydrates the current shape with its data from well-known text.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="wellKnownText">This parameter is the well-known text you will use to hydrate your object.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.LoadFromWellKnownDataCore(System.Byte[])">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Passing invalid well-known binary in the bytes parameter will throw an ArgumentException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">Passing a null as the bytes parameter will throw an ArgumentNullException.</exception>
            <summary>
            This method hydrates the current shape with its data from well-known
            binary.
            </summary>
            <returns>None</returns>
            <remarks>
            This is used when you want to hydrate a shape based on well-known binary. You can
            create the shape and then load the well-known binary using this method.<br/>
            </remarks>
            <param name="wellKnownBinary">This parameter is the well-known binary used to populate the shape.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.GetWellKnownBinaryCore(ThinkGeo.MapSuite.Core.WkbByteOrder)">
            <summary>
            This method returns a byte array that represents the shape in well-known
            binary.
            </summary>
            <returns>
            This method returns a byte array that represents the shape in well-known
            binary.
            </returns>
            <remarks>
            This method returns a byte array that represents the shape in well-known binary.
            Well-known binary allows you to describe a geometry as a binary array. Well-known
            binary is useful when you want to save a geometry in an efficient format using as little
            space as possible. An alternative to well-known binary is well-known text, which is a
            textual representation of a geometry object. We have methods that work with well-known
            text as well.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a ByteOrder that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <param name="byteOrder">This parameter specifies whether the byte order is big- or little-endian.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.ValidateCore(ThinkGeo.MapSuite.Core.ShapeValidationMode)">
            <summary>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </summary>
            <returns>
            This method returns a ShapeValidationResult based on a series of
            tests.
            </returns>
            <remarks>
            We use this method, with the simple enumeration, internally before doing any kind
            of other methods on the shape. In this way, we are able to verify the integrity of the
            shape itself. If you wish to test things such as whether a polygon self-intersects, we invite
            you to call this method with the advanced ShapeValidationMode. One thing to consider is
            that for complex polygon shapes this operation could take some time, which is why we
            only run the basic, faster test. If you are dealing with polygon shapes that are
            suspect, we suggest you run the advanced test.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a validationMode that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <param name="validationMode">
            This parameter determines whether the test is simple or advanced. In some cases, the
            advanced tests can take some time. The simple test is designed to always be
            fast.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.GreatCircle(ThinkGeo.MapSuite.Core.PointShape)">
            <summary>
            This method returns a MultilineShape that represents the shortest line between
            two points on the globe.
            </summary>
            <returns>
            This method returns a MultilineShape that represents the shortest line between
            two points on the globe.
            </returns>
            <remarks>
            This method is useful when you want to display on the map the shortest line between two
            points in decimal degrees. The line will be curved, and possibly disconnected
            if it is close to travel from the end of the map.
            </remarks>
            <param name="pointShape">This parameter is the target point to be measured to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.GreatCircle(ThinkGeo.MapSuite.Core.Feature)">
            <summary>
            This method returns a MultilineShape which represents the shortest line between
            the current point and the specified feature on the globe.
            </summary>
            <returns>
            This method returns a MultilineShape which represents the shortest line between
            the current point and the specified feature on the globe.
            </returns>
            <remarks>
            This method is useful when you want to display on the map the shortest line between two
            points in decimal degrees. The line will be curved, and possibly disconnected
            if it is close to travel from the end of the map.
            </remarks>
            <param name="pointFeature">This parameter is the target feature to be measured to.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.GetDistanceToCore(ThinkGeo.MapSuite.Core.BaseShape,ThinkGeo.MapSuite.Core.GeographyUnit,ThinkGeo.MapSuite.Core.DistanceUnit)">
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which does not have any points, we will throw an ArgumentException. </exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a shapeUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined in the enumeration, it will throw a ArgumentOutOfRangeException.</exception>
            <returns>
            This method returns the distance between the current shape and the
            targetShape.
            </returns>
            <summary>
            This method computes the distance between the current shape and the
            targetShape.
            </summary>
            <remarks>None</remarks>
            <param name="targetShape"><para>The shape you are trying to find the distance to.</para></param>
            <param name="shapeUnit">
            This is the GeographyUnit of the shape you are performing the operation
            on.
            </param>
            <param name="distanceUnit">
            This is the DistanceUnit you would like to use for the distance parameter. For
            example, if you select miles as your distanceUnit, then the distance will be measured
            in miles.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.GetCrossingCore(ThinkGeo.MapSuite.Core.BaseShape)">
            <summary>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </summary>
            <returns>
            This method returns the crossing points between the current shape and the passed-in target shape.
            </returns>
            <remarks>
            As this is a concrete public method that wraps a Core method, we reserve the right
            to add events and other logic to pre- or post-process data returned by the Core version
            of the method. In this way, we leave our framework open on our end, but also allow you
            the developer to extend our logic to suit your needs. If you have questions about this,
            please contact our support team as we would be happy to work with you on extending our
            framework.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a shape which has no points, it will throw an InvalidOperationException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape, we will throw an ArgumentNullException.</exception>
            <param name="targetShape">The target shape you wish to get crossing with.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.PointShape.ToString">
            <summary>
            Override the ToString() API by returning the X, Y , Z
            </summary>
            <returns>The returned string shows the X, Y , Z values.</returns>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointShape.X">
            <summary>This property represents the X (horizontal) axis.</summary>
            <decimalDegreesValue>This property represents the X (horizontal) axis.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointShape.Y">
            <summary>This property represents the Y (vertical) axis.</summary>
            <decimalDegreesValue>This property represents the Y (vertical) axis.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointShape.Z">
            <summary>This property represents the Z (depth) axis.</summary>
            <decimalDegreesValue>This property represents the Z (depth) axis.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.PointShape.CanRotate">
            <summary>This property specifies whether the shape can be rotated.</summary>
            <decimalDegreesValue>This property specifies whether the shape can be rotated.</decimalDegreesValue>
            <remarks>
            If this property returns false and you attempt call the rotate method, it will
            throw a NotImplementedException.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.LineStyles">
            <summary>
            This class is a collection of predefined styles and helper methods to create
            styles.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineStyles.CreateSimpleLineStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,System.Boolean)">
            <summary>This method returns a LineStyle based on the parameters passed in.</summary>
            <returns>This method returns a LineStyle based on the parameters passed in.</returns>
            <remarks>None</remarks>
            <overloads>This overload draws a simple line with an optional round cap.</overloads>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineStyles.CreateSimpleLineStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.LineDashStyle,System.Boolean)">
            <summary>This method returns a LineStyle based on the parameters passed in.</summary>
            <returns>This method returns a LineStyle based on the parameters passed in.</returns>
            <remarks>None</remarks>
            <overloads>This overload draws a dashed line with an optional round cap.</overloads>
            <param name="centerlineColor">This parameter is the center line color.</param>
            <param name="centerlineWidth">This paramter is the the center line width.</param>
            <param name="centerlineDashStyle">This parameter is the dash style for the center line.</param>
            <param name="roundCap">This parameter defines whether you want a rounded end cap.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineStyles.CreateSimpleLineStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor,System.Single,System.Boolean)">
            <summary>This method returns a LineStyle based on the parameters passed in.</summary>
            <returns>This method returns a LineStyle based on the parameters passed in.</returns>
            <remarks>None</remarks>
            <overloads>
            This overload draws a line with an inner and outer area and optional round cap.
            You would use this for roads.
            </overloads>
            <param name="innerLineColor">This parameter is the inner line color.</param>
            <param name="innerLineWidth">This parameter is the inner line width.</param>
            <param name="outerLineColor">This parameter is the outer line color.</param>
            <param name="outerLineWidth">This parameter is the outer line width.</param>
            <param name="roundCap">This parameter defines whether you want a rounded end cap.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineStyles.CreateSimpleLineStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.LineDashStyle,ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.LineDashStyle,System.Boolean)">
            <summary>This method returns a LineStyle based on the parameters passed in.</summary>
            <returns>This method returns a LineStyle based on the parameters passed in.</returns>
            <remarks>None</remarks>
            <param name="innerLineColor">This parameter is the inner line color.</param>
            <param name="innerLineWidth">This parameter is the inner line width.</param>
            <param name="innerLineDashStyle">This parameter is the inner line dash style.</param>
            <param name="outerLineColor">This parameter is the outer line color.</param>
            <param name="outerLineWidth">This parameter is the outer line width.</param>
            <param name="outerLineDashStyle">This parameter is the outer line dash style.</param>
            <param name="roundCap">This parameter defines whether you want a rounded end cap.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineStyles.CreateSimpleLineStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.GeoColor,System.Single,System.Boolean)">
            <summary>This method returns a LineStyle based on the parameters passed in.</summary>
            <returns>This method returns a LineStyle based on the parameters passed in.</returns>
            <remarks>None</remarks>
            <overloads>This overload is used to draw things like roads wth a solid centerline.</overloads>
            <param name="centerlineColor">This parameter is the center line color.</param>
            <param name="centerlineWidth">This parameter is the center line width.</param>
            <param name="innerLineColor">This parameter is the inner line color.</param>
            <param name="innerLineWidth">This parameter is the inner line width.</param>
            <param name="outerLineColor">This parameter is the outer line color.</param>
            <param name="outerLineWidth">This parameter is the outer line width.</param>
            <param name="roundCap">This parameter defines whether you want a rounded end cap.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.LineStyles.CreateSimpleLineStyle(ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.LineDashStyle,ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.LineDashStyle,ThinkGeo.MapSuite.Core.GeoColor,System.Single,ThinkGeo.MapSuite.Core.LineDashStyle,System.Boolean)">
            <summary>This method returns a LineStyle based on the parameters passed in.</summary>
            <returns>This method returns a LineStyle based on the parameters passed in.</returns>
            <remarks>None</remarks>
            <overloads>This overload is used to draw things like roads wth a dashed centerline.</overloads>
            <param name="centerlineColor">This parameter is the center line color.</param>
            <param name="centerlineWidth">This parameter is the center line width.</param>
            <param name="centerlineDashStyle">This parameter is the center line dash style.</param>
            <param name="innerLineColor">This parameter is the inner line color.</param>
            <param name="innerLineWidth">This parameter is the inner line width.</param>
            <param name="innerLineDashStyle">This parameter is the inner line dash style.</param>
            <param name="outerLineColor">This parameter is the outer line color.</param>
            <param name="outerLineWidth">This parameter is the outer line width.</param>
            <param name="outerLineDashStyle">This parameter is the outer line dash style.</param>
            <param name="roundCap">This parameter defines whether you want a rounded end cap.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.LocalRoad1">
            <summary>This property gets a style that represents LocalRoad1.</summary>
            <value>This property gets a style that represents LocalRoad1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.LocalRoad2">
            <summary>This property gets a style that represents LocalRoad2.</summary>
            <value>This property gets a style that represents LocalRoad2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.LocalRoad3">
            <summary>This property gets a style that represents LocalRoad3.</summary>
            <value>This property gets a style that represents LocalRoad3.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.LocalRoad4">
            <summary>This property gets a style that represents LocalRoad4.</summary>
            <value>This property gets a style that represents LocalRoad4.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.SecondaryRoad1">
            <summary>This property gets a style that represents SecondaryRoad1.</summary>
            <value>This property gets a style that represents SecondaryRoad1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.SecondaryRoad2">
            <summary>This property gets a style that represents SecondaryRoad2.</summary>
            <value>This property gets a style that represents SecondaryRoad2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.MajorRoad1">
            <summary>This property gets a style that represents MajorRoad1.</summary>
            <value>This property gets a style that represents MajorRoad1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.MajorRoad2">
            <summary>This property gets a style that represents MajorRoad2.</summary>
            <value>This property gets a style that represents MajorRoad2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.MajorRoad3">
            <summary>This property gets a style that represents MajorRoad3.</summary>
            <value>This property gets a style that represents MajorRoad3.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.MajorRoad4">
            <summary>This property gets a style that represents MajorRoad4.</summary>
            <value>This property gets a style that represents MajorRoad4.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.MajorStreet1">
            <summary>This property gets a style that represents MajorStreet1.</summary>
            <value>This property gets a style that represents MajorStreet1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.MajorStreet2">
            <summary>This property gets a style that represents MajorStreet2.</summary>
            <value>This property gets a style that represents MajorStreet2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.MajorStreet3">
            <summary>This property gets a style that represents MajorStreet3.</summary>
            <value>This property gets a style that represents MajorStreet3.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Highway1">
            <summary>This property gets a style that represents Highway1.</summary>
            <value>This property gets a style that represents Highway1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Highway2">
            <summary>This property gets a style that represents Highway2.</summary>
            <value>This property gets a style that represents Highway2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Highway3">
            <summary>This property gets a style that represents Highway3.</summary>
            <value>This property gets a style that represents Highway3.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Highway4">
            <summary>This property gets a style that represents Highway4.</summary>
            <value>This property gets a style that represents Highway4.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Highway5">
            <summary>This property gets a style that represents Highway5.</summary>
            <value>This property gets a style that represents Highway5.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Interstate1">
            <summary>This property gets a style that represents Interstate1.</summary>
            <value>This property gets a style that represents Interstate1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Interstate2">
            <summary>This property gets a style that represents Interstate2.</summary>
            <value>This property gets a style that represents Interstate2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Interstate3">
            <summary>This property gets a style that represents Interstate3.</summary>
            <value>This property gets a style that represents Interstate3.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Interstate4">
            <summary>This property gets a style that represents Interstate4.</summary>
            <value>This property gets a style that represents Interstate4.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.InternationalBorder1">
            <summary>This property gets a style that represents InternationalBorder1.</summary>
            <value>This property gets a style that represents InternationalBorder1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.InternationalBorder2">
            <summary>This property gets a style that represents InternationalBorder2.</summary>
            <value>This property gets a style that represents InternationalBorder2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Railway1">
            <summary>This property gets a style that represents Railway1.</summary>
            <value>This property gets a style that represents Railway1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Railway2">
            <summary>This property gets a style that represents Railway2.</summary>
            <value>This property gets a style that represents Railway2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Railway3">
            <summary>This property gets a style that represents Railway3.</summary>
            <value>This property gets a style that represents Railway3.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Railway4">
            <summary>This property gets a style that represents Railway4.</summary>
            <value>This property gets a style that represents Railway4.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.StateBorder1">
            <summary>This property gets a style that represents StateBorder1.</summary>
            <value>This property gets a style that represents StateBorder1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.River1">
            <summary>This property gets a style that represents River1.</summary>
            <value>This property gets a style that represents River1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.River2">
            <summary>This property gets a style that represents River2.</summary>
            <value>This property gets a style that represents River2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Canal1">
            <summary>This property gets a style that represents Canal1.</summary>
            <value>This property gets a style that represents Canal1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.ContestedBorder1">
            <summary>This property gets a style that represents ContestedBorder1.</summary>
            <value>This property gets a style that represents ContestedBorder1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.ContestedBorder2">
            <summary>This property gets a style that represents ContestedBorder2.</summary>
            <value>This property gets a style that represents ContestedBorder2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.DegreeLine1">
            <summary>This property gets a style that represents DegreeLine1.</summary>
            <value>This property gets a style that represents DegreeLine1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Equator1">
            <summary>This property gets a style that represents Equator1.</summary>
            <value>This property gets a style that represents Equator1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.RiverIntermittent1">
            <summary>This property gets a style that represents RiverIntermittent1.</summary>
            <value>This property gets a style that represents RiverIntermittent1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Pipeline1">
            <summary>This property gets a style that represents Pipeline1.</summary>
            <value>This property gets a style that represents Pipeline1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Pipeline2">
            <summary>This property gets a style that represents Pipeline2.</summary>
            <value>This property gets a style that represents Pipeline2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Pipeline3">
            <summary>This property gets a style that represents Pipeline3.</summary>
            <value>This property gets a style that represents Pipeline3.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Utility1">
            <summary>This property gets a style that represents Utility1.</summary>
            <value>This property gets a style that represents Utility1.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Utility2">
            <summary>This property gets a style that represents Utility2.</summary>
            <value>This property gets a style that represents Utility2.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.LineStyles.Utility3">
            <summary>This property gets a style that represents Utility3.</summary>
            <value>This property gets a style that represents Utility3.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DrawingRectangleF">
            <summary>This structure represents the drawing of a rectangle in screen coordinates.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DrawingRectangleF.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            This method represents the constructor that should be used to create the
            structure.
            </summary>
            <example>
            None
            </example>
            <param name="centerX">This parameter represents the center horizontal value of the rectangle.</param>
            <param name="centerY">This parameter represents the center vertical value of the rectangle.</param>
            <param name="width">This parameter represents the width of the rectangle.</param>
            <param name="height">This parameter represents the height of the rectangle.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DrawingRectangleF.op_Equality(ThinkGeo.MapSuite.Core.DrawingRectangleF,ThinkGeo.MapSuite.Core.DrawingRectangleF)">
            <summary>This method is an override of the == functionality.</summary>
            <remarks>None</remarks>
            <param name="rectangleF1">This parameter represents the first DrawingRectangleF to compare.</param>
            <param name="rectangleF2">This parameter represents the second DrawingRectangleF to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DrawingRectangleF.op_Inequality(ThinkGeo.MapSuite.Core.DrawingRectangleF,ThinkGeo.MapSuite.Core.DrawingRectangleF)">
            <summary>This method is an override of the != functionality.</summary>
            <remarks>None</remarks>
            <param name="rectangleF1">This parameter represents the first DrawingRectangleF to compare.</param>
            <param name="rectangleF2">This parameter represents the second DrawingRectangleF to compare.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DrawingRectangleF.Equals(System.Object)">
            <summary>This method is an override of the Equals functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DrawingRectangleF.GetHashCode">
            <summary>This method is an override of the GetHashCode functionality.</summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DrawingRectangleF.CenterX">
            <summary>This parameter represents the center horizontal value of the rectangle.</summary>
            <value>This parameter returns the center horizontal value of the rectangle.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DrawingRectangleF.CenterY">
            <summary>This parameter represents the center vertical value of the rectangle.</summary>
            <value>This parameter returns the center vertical value of the rectangle.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DrawingRectangleF.Width">
            <summary>This parameter returns the width of the rectangle.</summary>
            <value>This parameter returns the width of the rectangle.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DrawingRectangleF.Height">
            <summary>This parameter returns the height of the rectangle.</summary>
            <value>This parameter returns the height of the rectangle.</value>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DbfColumnType">
            <summary>This enumeration represents the column type in the DBF.</summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DbfColumnType.Null">
            <summary>Null</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DbfColumnType.String">
            <summary>A string type.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DbfColumnType.Double">
            <summary>8 byte numeric type.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DbfColumnType.Logical">
            <summary>
            1 byte to include:<br/>
            	<br/>
            ? - Default<br/>
            Y,y - Yes<br/>
            N,n - No<br/>
            F,f - False<br/>
            T,t - True
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DbfColumnType.Integer">
            <summary>8 byte numeric type.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DbfColumnType.Memo">
            <summary>10 digit pointer to memo file.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DbfColumnType.Date">
            <summary>Date in format - YYYYMMDD</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DbfColumn">
            <summary>This class represents the column information specific to a DBF column.</summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DbfColumn.#ctor">
            <summary>This method is the constructor for the DbfColumn.</summary>
            <overloads>This is the default constructor.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.DbfColumn.#ctor(System.String,ThinkGeo.MapSuite.Core.DbfColumnType,System.Int32,System.Int32)">
            <summary>This method is the constructor for the DbfColumn.</summary>
            <overloads>This constructor is intended to be used to create the object.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="columnName">This parameter represents the name of the column in the DBF.</param>
            <param name="columnType">This parameter represents the type of the column in the DBF.</param>
            <param name="length">This parameter represents the length of the column in the DBF.</param>
            <param name="decimalLength">
            This parameter represents the number of decimal places the column has, if it is a
            numeric type.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DbfColumn.ColumnName">
            <summary>This property returns the name of the column in the DBF.</summary>
            <decimalDegreesValue>This property returns the name of the column in the DBF.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DbfColumn.ColumnType">
            <summary>This property returns the type of the column in the DBF.</summary>
            <decimalDegreesValue>This property returns the type of the column in the DBF.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DbfColumn.Length">
            <summary>This property returns the length of the column in the DBF.</summary>
            <decimalDegreesValue>This property returns the length of the column in the DBF.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.DbfColumn.DecimalLength">
            <summary>This property returns the decimal length of the column in the DBF.</summary>
            <decimalDegreesValue>This property returns the decimal length of the column in the DBF.</decimalDegreesValue>
            <remarks>
            This is the number of decimal places the number represents. This is only
            applicable if the column type is numeric.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.CommittingTransactionEventArgs">
            <summary>
            This class represents the parameters passed in through the CommittingTransaction
            event.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.CommittingTransactionEventArgs.#ctor(ThinkGeo.MapSuite.Core.TransactionBuffer)">
            <overloads>This is the constructor that allows you to pass in a transaction buffer.</overloads>
            <summary>This is the default constructor for the event.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="transactionBuffer">
            This parameter represents the transaction buffer that needs to be
            committed.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.CommittingTransactionEventArgs.#ctor">
            <summary>This is the constructor of the event arguments.</summary>
            <overloads>This is the default constructor for the event arguments.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.CommittingTransactionEventArgs.Cancel">
            <summary>This property allows you to cancel the transaction.</summary>
            <decimalDegreesValue>This property allows you to cancel the transaction.</decimalDegreesValue>
            <remarks>This property allows you to cancel the transaction.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.CommittingTransactionEventArgs.TransactionBuffer">
            <summary>This property returns the transaction buffer that needs to be committed.</summary>
            <decimalDegreesValue>This property returns the transaction buffer that needs to be committed.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WkbByteOrder">
            <summary>
            This enumeration represents the byte order that well-known binary will be written
            in.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.WkbByteOrder.LittleEndian">
            <summary>The least significant byte value is at the lowest address.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.WkbByteOrder.BigEndian">
            <summary>The most significant byte value is at the lowest address.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.GeoHatchBrush">
            <summary>This class represents a brush that fills with various patterns.</summary>
            <remarks>This class represents a brush that fills with various patterns.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoHatchBrush.#ctor(ThinkGeo.MapSuite.Core.GeoHatchStyle,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a foreground color for the pattern
            fill.
            </overloads>
            <returns>None</returns>
            <remarks>
            You will use this constructor when you want to only specify the foreground color
            of the pattern and leave the background transparent.
            </remarks>
            <param name="hatchStyle">This property is the hatch pattern you want to use to fill the area.</param>
            <param name="foregroundColor">This property is the foreground color you want to use for the pattern.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.GeoHatchBrush.#ctor(ThinkGeo.MapSuite.Core.GeoHatchStyle,ThinkGeo.MapSuite.Core.GeoColor,ThinkGeo.MapSuite.Core.GeoColor)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a foreground and background color for the
            pattern fill.
            </overloads>
            <returns>None</returns>
            <remarks>
            This constructor allows you to choose both the background and foreground color
            for the pattern.
            </remarks>
            <param name="hatchStyle">This property is the hatch pattern you want to use to fill the area.</param>
            <param name="foregroundColor">This property is the foreground color you want to use for the pattern.</param>
            <param name="backgroundColor">This property is the background color you want to use for the pattern.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoHatchBrush.HatchStyle">
            <summary>This property gets and sets the pattern you want to use for the fill.</summary>
            <value>This property gets the pattern you want to use for the fill.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoHatchBrush.ForegroundColor">
            <summary>This property gets and sets the foreground color for the fill pattern.</summary>
            <value>This property gets the foreground color for the fill pattern.</value>
            <remarks>In this case the background color will be transparent.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.GeoHatchBrush.BackgroundColor">
            <summary>This property gets and sets the background color for the fill pattern.</summary>
            <remarks>In this case the foreground color will be transparent.</remarks>
            <value>This property gets the background color for the fill pattern.</value>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.SLOT_T">
            <summary>
            Contains a record's offset and length.
            It is stored in the end area of the page.
            Its size must be 4 bytes.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.SLOT_T.Init">
            <summary>
            Init SLOT_T
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.SLOT_T.GetSize">
            <summary>
            Return the size of the this struct.
            </summary>
            <returns> Size of SLOT_T</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.SLOT_T.Read(System.IO.BinaryReader)">
            <summary>
            Read contents from BinaryReader object.
            </summary>
            <param name="r">BinaryReader object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.SLOT_T.Write(System.IO.BinaryWriter)">
            <summary>
            Write contents to BinaryWriter object.
            </summary>
            <param name="w">BinaryWriter object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.SLOT_T.ToString">
            <summary>
            For debugging.
            </summary>
            <returns> dumped string</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.FILE_HEADER">
            <summary>
             Index file header.
             It is stored in page 0.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FILE_HEADER.Init">
            <summary>
            Init struct
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FILE_HEADER.Read(System.IO.BinaryReader)">
            <summary>
            Read contents from BinaryReader object.
            </summary>
            <param name="r"> BinaryReader object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FILE_HEADER.Write(System.IO.BinaryWriter)">
            <summary>
            Write contents into BinaryWriter object.
            </summary>
            <param name="w">BinaryWriter object</param>
            <returns>		
            	true for success
            	false for failure
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.FILE_HEADER.ToString">
            <summary>
            For debug
            </summary>
            <returns> dumped string</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.WorldMapKitLayer">
            <summary>
            This class is use for world map kit, and you also can get map from ThinkGeo world map kit server.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.#ctor">
            <summary>
            The default constructor
            </summary>
            <remarks>The constructor initilizes the properties. UpperThreshold is set to double.MaxValue, LowerThreshold is set to double.MinValue.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.#ctor(System.String,System.String)">
            <summary>
            This is the constructor the for the class.
            </summary>
            <param name="clientId">The clientId for the WorldMapKit Server.</param>
            <param name="privateKey">The privateKey for the WorldMapKit Server.</param>
            <remarks>This constructor initializes a new layer and assgin a license key.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.ClearCache">
            <summary>
            This method clears the tile cache.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a Layer which has already been opened, it will throw an InvalidOperationException.</exception>
            <summary>This method opens the Layer so that it is initialized and ready to use.</summary>
            <remarks>
            This abstract method is called from the concrete public method Open. The
            open method plays an important role, as it is responsible for initializing the Layer.
            Most methods on the Layer will throw an exception if the state of the Layer is not
            opened. When the map draws each layer, the layer will be opened as one of its first steps;
            then, after it is finished drawing with that layer, it will close it. In this way, we
            are sure to release all resources used by the Layer.<br/>
            <br/>
            When implementing the abstract method, consider opening the FeatureSource or
            RasterSource. You will get a chance to close these in the Close method of the
            Layer.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.GetServerLayerNames">
            <summary>This method returns the names of all layers at the server side.</summary>
            <returns>This method returns the names of all layers at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.GetServerStyleNames">
            <summary>This method returns the names of all styles at the server side.</summary>
            <returns>This method returns the names of all styles at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.GetServerOutputFormats">
            <summary>This method returns the output format at the server side.</summary>
            <returns>This method returns the output format at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.GetServerCrss">
            <summary>
            This method returns the projected or geographic coordinate reference systems to be used.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.GetServerExceptionFormats">
            <summary>This method returns the exception format at the server side.</summary>
            <returns>The exception format at the server side.</returns>
            <remarks>None.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.GetServiceVersion">
            <summary>
            This API gets the WMS server version of the service.
            </summary>
            <returns>Returns a string reflecting the version of the service in WMS.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.GetRequestUrl(ThinkGeo.MapSuite.Core.RectangleShape,System.Int32,System.Int32)">
            <summary>
            Get the request URLs from the client to the WMS servers.
            </summary>
            <param name="worldExtent">The world extent requested by the client to get the map.</param>
            <param name="canvasWidth">The returning map width, as well as the drawing canvas width.</param>
            <param name="canvasHeight">The returning map height, as well as the drawing canvas height.</param>
            <returns>The request URLs from the client to the WMS servers.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.CloseCore">
            <summary>
            This method closes the Layer and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This abstract method is called from the concrete public method Close. The close
            method plays an important role in the life cycle of the Layer. It may be called after
            drawing to release any memory and other resources that were allocated since the Open
            method was called.<br/>
            	<br/>
            If you override this method, it is recommended that you take the following things
            into account: This method may be called multiple times, so we suggest you write the method so
            that that a call to a closed Layer is ignored and does not generate an error.
            We also suggest that in the Close you free all resources that have been opened.
            Remember that the object will not be destroyed, but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.DrawImage(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
             <summary>
             This method draws image on the canvas with specified labelsInAllLayers
             </summary>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.
             This parameter represents the labels used for collision detection and duplication
             checking.
            </param>
            <param name="labelsInAllLayers">This parameter is the labels in all layers.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.DrawCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Collections.ObjectModel.Collection{ThinkGeo.MapSuite.Core.SimpleCandidate})">
            <summary>This method draws the Layer.</summary>
            <remarks>
            This method is the concrete wrapper for the abstract method DrawCore. This
                method draws the representation of the layer based on the extent you provided.<br/>
            	<br/>
            When implementing this abstract method, consider each feature and its column data
            values. You can use the full power of the GeoCanvas to do the drawing. If you need
            column data for a feature, be sure to override the GetRequiredColumnNamesCore and add
            the columns you need to the collection. In many of the styles, we add properties that
            allow the user to specify which field they need; then, in the GetRequiredColumnNamesCore,
            we read that property and add it to the collection.
            </remarks>
            <returns>None</returns>
            <param name="canvas">This parameter is the canvas object or a GeoImage to draw on.</param>
            <param name="labelsInAllLayers">
            This parameter represents the labels used for collision detection and duplication
            checking.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.IsExtentWithinThreshold(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,System.Double,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit)">
            <summary>
            This method retures a value represents whether the currentExtent is within the passing in thresholds.
            </summary>
            <param name="currentExtent">The RectangleShape represents the current extent.</param>
            <param name="upperThreshold">The upper threshold for scale.</param>
            <param name="lowerThreshold">The lower threshold for scale.</param>
            <param name="canvasWidth">The width of canvas which will use to draw.</param>
            <param name="mapUnit">The GeographyUnit represents map unit for currentExtent</param>
            <returns>This method retures a value represents whether the currentExtent is within the passing in thresholds. If returns true, is within. otherwise out of thresholds.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.IsExtentWithinThreshold(ThinkGeo.MapSuite.Core.RectangleShape,System.Double,System.Double,System.Int32,ThinkGeo.MapSuite.Core.GeographyUnit,System.Single)">
            <summary>
            This method retures a value represents whether the currentExtent is within the passing in thresholds.
            </summary>
            <param name="currentExtent">The RectangleShape represents the current extent.</param>
            <param name="upperThreshold">The upper threshold for scale.</param>
            <param name="lowerThreshold">The lower threshold for scale.</param>
            <param name="canvasWidth">The width of canvas which will use to draw.</param>
            <param name="mapUnit">The GeographyUnit represents map unit for currentExtent</param>
            <param name="dpi">This parameter is the dpi of the current extent.</param>
            <returns>This method retures a value represents whether the currentExtent is within the passing in thresholds. If returns true, is within. otherwise out of thresholds.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.WorldMapKitLayer.DrawExceptionCore(ThinkGeo.MapSuite.Core.GeoCanvas,System.Exception)">
            <summary>
            This method will draw on the canvas when the layer.Draw throw exception and 
            the DrawExceptionMode is set to DrawException instead of ThrowException.
            </summary>
            <param name="canvas">The target canvas to draw the layer.</param>
            <param name="e">The exception thrown when layer.Draw().</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitLayer.ClientId">
            <summary>
            Gets or sets a value that is your Client Id.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitLayer.PrivateKey">
            <summary>
            Gets or sets a value that is unique to your client ID, please keep your key secure.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitLayer.Projection">
            <summary>
            Gets or sets a WorldMapKitProjection represents which projection will be use.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitLayer.Proxy">
            <summary>
            This property gets or sets the proxy used for requesting a Web Response.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitLayer.TileCache">
            <summary>
            Gets or sets a BitmapTileCache represents which tile cache will be use.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitLayer.UpperThreshold">
            <summary>
            Gets or sets a value represents upper threshold for scale.
            </summary>
            <remarks>Is the current scale is beyond this value, the map will not render.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitLayer.LowerThreshold">
            <summary>
            Gets or sets a value represents lower threshold for scale.
            </summary>
            <remarks>Is the current scale is less than this value, the map will not render.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitLayer.TimeoutInSecond">
            <summary>
            This property specifies the timeout of the web request in seconds.  The default timeout value is 20 seconds.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitLayer.HasBoundingBox">
            <summary>
            This property indicates whether a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs.
            </summary>
            <remarks>The value of WorldMapKitLayer is false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.WorldMapKitLayer.IsOpenCore">
            <summary>This property returns true if the Layer is open and false if it is not.</summary>
            <decimalDegreesValue>This property returns true if the Layer is open and false if it is not.</decimalDegreesValue>
            <remarks>
            Various methods on the Layer require that it be in an open state. If one of those
            methods is called when the state is not open, then the method will throw an exception.
            To enter the open state, you must call the Layer Open method. The method will raise an
            exception if the current Layer is already open.
            </remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.TileMatrixSet">
            <summary>
            This class holds a collection of TileMatrix shared the same Crs.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.TileMatrixSet.#ctor">
            <summary>
            Default constrctor or the class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileMatrixSet.TileMatrices">
            <summary>
            Gets the collection of TileMatrix for the TileMatrixSet.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileMatrixSet.Id">
            <summary>
            Gets or sets the id of the TileMatrixSet.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.TileMatrixSet.Crs">
            <summary>
            Gets or sets the Crs(Coorindate reference system) for the TileMatrixSet.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.SendingTiledWmsLayerEventArgs">
            <summary>
            The event args containing the event data used by SecuredTiledWmsRasterSource.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.SendingTiledWmsLayerEventArgs.#ctor(System.Uri)">
            <summary>
            Create an instance of SendingTiledWmsLayerEventArgs
            </summary>
            <param name="requestUri"></param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.SendingTiledWmsLayerEventArgs.RequestUri">
            <summary>
            The request uri
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.MultipleFeatureLayer">
            <summary>This class represents a Layer backed by multiple Shape Files.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureLayer.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.MultipleFeatureLayer.#ctor(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Core.FeatureSource})">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide information about the FeatureSources for the MultipleFeatureLayer.
            </overloads>
            <returns>None</returns>
            <remarks>This constructor gets the layer ready to use.</remarks>
            <param name="featureSources">This parameter represents the FeatureSources in this class that you want to use.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultipleFeatureLayer.FeatureSources">
            <summary>
            This property gets the FeatureSources you want to use.
            </summary>
            <value>This property gets the FeatureSources you want to use.</value>
            <remarks>This property gets the FeatureSources you want to use.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.MultipleFeatureLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In MultipleFeatureLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Core.DrawingExceptionMode">
            <summary>
            This enum is used to describe some choice when exception hanppens 
            during drawing Layers or Overlays.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingExceptionMode.Default">
            <summary>
            Default mode used in MapSuite component.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingExceptionMode.ThrowException">
            <summary>
            This item means the exception will be throw out and the rest of drawing will be terminated.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Core.DrawingExceptionMode.DrawException">
            <summary>
            This item means that we will catch the exception and draw it to show error happens, while the user 
            cannot catch it any more.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Meridian.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,ThinkGeo.MapSuite.Core.Pj_Prime_Meridians},System.Int32@)">
             <summary>
            constructor of Meridian
             </summary>
             <param name="args">user inputed parameter</param>
             <param name="meridiansList">list of meridian</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Meridian.GetMeridianID(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            obtain ID value of meridian
            </summary>
            <param name="args">dictionary of parameter</param>
            <returns>ID value of Meridian</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Core.Meridian._InitMeridian(System.String,System.Int32@)">
            <summary>
            set object of meridian
            </summary>
            <param name="id"></param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Core.Meridian.Meri">
            <summary>
            obtain object of meridian
            </summary>
        </member>
    </members>
</doc>
